<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.15">
<title>Java Language</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Java Language</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_типы_данных_и_переменные">Типы данных и переменные</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Одной из основных особенностей <strong>Java</strong> является то, что данный язык является <strong>строго типизированным</strong>. А это значит, что каждая переменная и константа представляет определенный тип и данный тип строго определен. Тип данных определяет диапазон значений, которые может хранить переменная или константа.</p>
</div>
<div class="sect2">
<h3 id="_базовые_типы">Базовые типы</h3>
<div class="paragraph">
<p>Итак, рассмотрим систему встроенных базовых типов данных, которая используется для создания переменных в Java. А она представлена следующими типами.</p>
</div>
<div class="paragraph">
<p><code>boolean</code>: хранит значение <code>true</code> или <code>false</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">boolean isActive = false;
boolean isAlive = true;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>byte</code>: хранит целое число от <code>-128</code> до <code>127</code> и занимает <code>1 байт</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">byte a = 3;
byte b = 8;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>short</code>: хранит целое число от <code>-32768</code> до <code>32767</code> и занимает <code>2 байта</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">short a = 3;
short b = 8;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>int</code>: хранит целое число от <code>-2147483648</code> до <code>2147483647</code> и занимает <code>4 байта</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 4;
int b = 9;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>long</code>: хранит целое число от <code>-9 223 372 036 854 775 808</code> до <code>9 223 372 036 854 775 807</code> и занимает <code>8 байт</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">long a = 5;
long b = 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>double</code>: хранит число с плавающей точкой от <code>-1.7E+308</code> до <code>1.7E+308</code> (стандарт <strong>IEEE 754</strong>) и занимает <code>8 байт</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">double x = 8.5;
double y = 2.7;</code></pre>
</div>
</div>
<div class="paragraph">
<p>В качестве разделителя целой и дробной части в дробных литералах используется <strong>ТОЧКА</strong>.</p>
</div>
<div class="paragraph">
<p><code>float</code>: хранит число с плавающей точкой от <code>-3.4E+38</code> до <code>3.4E+38</code> (стандарт <strong>IEEE 754</strong>) и занимает <code>4 байта</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">float x = 8.5F;
float y = 2.7F;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>char</code>: хранит одиночный символ в кодировке <strong>Unicode</strong> и занимает <code>2 байта</code>, поэтому диапазон хранимых значений от <code>0</code> до <code>65536</code>.</p>
</div>
<div class="paragraph">
<p>При этом переменная может принимать только те значения, которые соответствуют ее типу. Если переменная представляет целочисленный тип, то она не может хранить дробные числа.</p>
</div>
<div class="sect3">
<h4 id="_целые_числа">Целые числа</h4>
<div class="paragraph">
<p>Все целочисленные литералы, например, <code>10</code>, <code>4</code>, <code>-5</code>, воспринимаются как значения типа <code>int</code>, однако мы можем присваивать целочисленные литералы другим целочисленным типам: <code>byte</code>, <code>long</code>, <code>short</code>. В этом случае Java автоматически осуществляет соответствующие преобразования:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">byte a = 1;
short b = 2;
long c = 2121;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как правило, значения для целочисленных переменных задаются в десятичной системе счисления, однако мы можем применять и другие системы исчисления. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int num111 = 0x6F; // шестнадцатеричная система, число 111
int num8 = 010; // восьмеричная система, число 8
int num13 = 0b1101; // двоичная система, число 13</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для задания шестнадцатеричного значения после символов <code>0x</code> указывается число в шестнадцатеричном формате. Таким же образом восьмеричное значение указывается после символа <code>0</code>, а двоичное значение - после символов <code>0b</code>.</p>
</div>
<div class="paragraph">
<p>Также целые числа поддерживают разделение разрядов числа с помощью знака подчеркивания:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int x = 123_456;
int y = 234_567__789;
System.out.println(x); // 123456
System.out.println(y); // 234567789</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_числа_с_плавающей_точкой">Числа с плавающей точкой</h4>
<div class="paragraph">
<p>При присвоении переменной типа <code>float</code> дробного литерала с плавающей точкой, например, <code>3.1</code>, <code>4.5</code> и т.д., Java автоматически рассматривает этот литерал как значение типа <code>double</code>. Чтобы указать, что данное значение должно рассматриваться как <code>float</code>, нам надо использовать суффикс <code>f</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">float fl = 30.6f;
double db = 30.6;</code></pre>
</div>
</div>
<div class="paragraph">
<p>И хотя в данном случае обе переменных имеют практически одно значения, но эти значения будут по-разному рассматриваться и будут занимать разное место в памяти.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ссылочные_типы">Ссылочные типы</h3>
<div class="paragraph">
<p>Все остальные за исключением примитивных. Если быть точным, то любой <code>Object</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_переменные">Переменные</h3>
<div class="paragraph">
<p>Для хранения данных в программе предназначены переменные. Переменная представляет именованную область памяти, которая хранит значение определенного типа. Каждая переменная имеет тип, имя и значение. Тип определяет, какую информацию может хранить переменная или диапазон допустимых значений.</p>
</div>
<div class="paragraph">
<p>Переменные объявляются следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">тип_данных имя_переменной;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например, определим переменную, которая будет называться <code>x</code> и будет иметь тип <code>int</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом выражении мы объявляем переменную <code>x</code> типа <code>int</code>. То есть <code>x</code> будет хранить некоторое число не больше <code>4 байт</code>.</p>
</div>
<div class="paragraph">
<p>В качестве имени переменной может выступать любое произвольное название, которое удовлетворяет следующим требованиям:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>имя может содержать любые алфавитно-цифровые символы, а также знак подчеркивания, при этом первый символ в имени не должен быть цифрой</p>
</li>
<li>
<p>в имени не должно быть знаков пунктуации и пробелов</p>
</li>
<li>
<p>имя не может быть ключевым словом языка Java</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Кроме того, при объявлении и последующем использовании надо учитывать, что <strong>Java - регистрозависимый язык</strong>, поэтому следующие объявления <code>int num;</code> и <code>int NUM;</code> будут представлять две разных переменных.</p>
</div>
<div class="paragraph">
<p>Объявив переменную, мы можем присвоить ей значений:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int x; // объявление переменной
x = 10; // присвоения значения
System.out.println(x); // 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Также можно присвоить значение переменной при ее объявлении. Этот процесс называется инициализацией:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int x = 10; // объявление и инициализация переменной
System.out.println(x); // 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если мы не присвоим переменной значение до ее использования, то мы можем получить ошибку, например, в следующем случае:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int x;
System.out.println(x);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Через запятую можно объявить сразу несколько переменных одного типа:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int x, y;
x = 10;
y = 25;
System.out.println(x); // 10
System.out.println(y); // 25</code></pre>
</div>
</div>
<div class="paragraph">
<p>Также можно их сразу инициализировать:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int x = 8, y = 15;
System.out.println(x); // 8
System.out.println(y); // 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>Отличительной особенностью переменных является то, что мы можем в процессе работы программы изменять их значение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int x = 10;
System.out.println(x); // 10
x = 25;
System.out.println(x); // 25</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_ключевое_слово_var">Ключевое слово var</h4>
<div class="paragraph">
<p>Начиная с Java 10 в язык было добавлено ключевое слово <code>var</code>, которое также позволяет определять переменную:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">var x = 10;
System.out.println(x); // 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Слово <code>var</code> ставится вместо типа данных, а сам тип переменной выводится из того значения, которое ей присваивается. Например, переменой <code>x</code> присваивается число <code>10</code>, значит, переменная будет представлять тип <code>int</code>.</p>
</div>
<div class="paragraph">
<p>Но если переменная объявляется с помощью <code>var</code>, то мы обязательно должны инициализировать ее, то есть предоставить ей начальное значение, иначе мы получим ошибку, как, например, в следующим случае:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">var x; // ! Ошибка, переменная не инициализирована
x = 10;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_значения_в_других_системах_счисления">Значения в других системах счисления</h3>
<div class="paragraph">
<p>Как правило, значения для целочисленных переменных задаются в десятичной системе счисления, однако мы можем применять и другие системы исчисления. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int num111 = 0x6F; // шестнадцатеричная система, число 111
int num8 = 010; // восьмеричная система, число 8
int num13 = 0b1101; // двоичная система, число 13</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для задания шестнадцатеричного значения после символов <code>0x</code> указывается число в шестнадцатеричном формате. Таким же образом восьмеричное значение указывается после символа <code>0</code>, а двоичное значение — после символов <code>0b</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_символы_и_строки">Символы и строки</h3>
<div class="paragraph">
<p>В качестве значения переменная символьного типа получает одиночный символ, заключенный в ординарные кавычки: <code>char ch='e';</code>. Кроме того, переменной символьного типа также можно присвоить целочисленное значение от <code>0</code> до <code>65536</code>. В этом случае переменная опять же будет хранить символ, а целочисленное значение будет указывать на номер символа в таблице символов <code>Unicode</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">char ch=102; // символ 'f'
System.out.println(ch);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Еще одной формой задания символьных переменных является шестнадцатеричная форма: переменная получает значение в шестнадцатеричной форме, которое следует после символов <code>"\u"</code>. Например, <code>char ch='\u0066';</code> опять же будет хранить символ <code>'f'</code>.</p>
</div>
<div class="paragraph">
<p>Символьные переменные не стоит путать со строковыми, <code>'a'</code> не идентично <code>"a"</code>. Строковые переменные представляют объект <code>String</code>, который в отличие от <code>char</code> или <code>int</code> не является примитивным типом в Java:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String hello = "Hellow...";
System.out.println(hello);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_константы">Константы</h3>
<div class="paragraph">
<p>Кроме переменных, в Java для хранения данных можно использовать константы. В отличие от переменных константам можно присвоить значение только один раз. Константа объявляется так же, как и переменная, только вначале идет ключевое слово <code>final</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">final int LIMIT = 5;
System.out.println(LIMIT); // 5
// LIMIT=57; // так мы уже не можем написать, так как LIMIT - константа</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как правило, константы имеют имена в <strong>ВЕРХНЕМ_РЕГИСТРЕ</strong>.</p>
</div>
<div class="paragraph">
<p>Константы позволяют задать такие переменные, которые не должны больше изменяться. Например, если у нас есть переменная для хранения числа <code>pi</code>, то мы можем объявить ее константой, так как ее значение постоянно.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_консольный_ввод_и_вывод">Консольный ввод и вывод</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для получения данных, введенных пользователем, а также для вывода сообщений нам необходим ряд классов, через которые мы сможем взаимодействовать с консолью.  Для взаимодействия с консолью нам необходим класс <code>System</code>. Этот класс располагается в пакете <code>java.lang</code>, который автоматически подключается в программу, поэтому нам не надо дополнительно импортировать данный пакет и класс.</p>
</div>
<div class="sect2">
<h3 id="_консольный_вывод">Консольный вывод</h3>
<div class="paragraph">
<p>Для создания потока вывода в класс <code>System</code> определен объект <code>out</code>. В этом объекте определен метод <code>println</code>, который позволяет вывести на консоль некоторое значение с последующим переводом консоли на следующую строку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">System.out.println("Hello world");</code></pre>
</div>
</div>
<div class="paragraph">
<p>В метод <code>println</code> передается любое значение, как правило, строка, которое надо вывести на консоль. При необходимости можно и не переводить курсор на следующую строку. В этом случае можно использовать метод <code>System.out.print()</code>, который аналогичен <code>println</code> за тем исключением, что не осуществляет перевода на следующую строку.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">System.out.print("Hello world");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Но с помощью метода <code>System.out.print</code> также можно осуществить перевод каретки на следующую строку. Для этого надо использовать <code>escape</code>-последовательность <code>\n</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">System.out.print("Hello world \n");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если у нас есть два числа, и мы хотим вывести их значения на экран, то мы можем, например, написать так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int x = 5;
int y = 6;
System.out.println("x=" + x + "; y=" + y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Но в <strong>Java</strong> есть также функция для форматированного вывода, унаследованная от языка <strong>С</strong>: <code>System.out.printf()</code>. С ее помощью мы можем переписать предыдущий пример следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int x = 5;
int y = 6;
System.out.printf("x=%d; y=%d \n", x, y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае символы <code>%d</code> обозначают спецификатор, вместо которого подставляет один из аргументов. Спецификаторов и соответствующих им аргументов может быть множество. В данном случае у нас только два аргумента, поэтому вместо первого <code>%d</code> подставляет значение переменной <code>x</code>, а вместо второго - значение переменной <code>y</code>. Сама буква <code>d</code> означает, что данный спецификатор будет использоваться для вывода целочисленных значений типа <code>int</code>.</p>
</div>
<div class="paragraph">
<p>Кроме спецификатора <code>%d</code> мы можем использовать еще ряд спецификаторов для других типов данных:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>%x</code>: для вывода шестнадцатеричных чисел</p>
</li>
<li>
<p><code>%f</code>: для вывода чисел с плавающей точкой</p>
</li>
<li>
<p><code>%e</code>: для вывода чисел в экспоненциальной форме, например, <code>1.3e+01</code></p>
</li>
<li>
<p><code>%c</code>: для вывода одиночного символа</p>
</li>
<li>
<p><code>%s</code>: для вывода строковых значений</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String name = "Иван";
int age = 30;
float height = 1.7f;
System.out.printf("Имя: %s   Возраст: %d лет   Рост: %.2f метров \n", name, age, height);</code></pre>
</div>
</div>
<div class="paragraph">
<p>При выводе чисел с плавающей точкой мы можем указать количество знаков после запятой, для этого используем спецификатор на <code>%.2f</code>, где <code>.2</code> указывает, что после запятой будет два знака. В итоге мы получим следующий вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-output" data-lang="output">Имя: Иван   Возраст: 30 лет   Рост: 1,70 метров</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_консольный_ввод">Консольный ввод</h3>
<div class="paragraph">
<p>Для получения консольного ввода в классе <code>System</code> определен объект <code>in</code>. Однако непосредственно через объект <code>System.in</code> не очень удобно работать, поэтому, как правило, используют класс <code>Scanner</code>, который, в свою очередь использует <code>System.in</code>. Например, создадим маленькую программу, которая осуществляет ввод чисел:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.Scanner;

public class FirstApp {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int[] nums = new int[5];
        for (int i = 0; i &lt; nums.length; i++) {
            nums[i] = in.nextInt();
        }

        for (int i = 0; i &lt; nums.length; i++) {
            System.out.print(nums[i]);
        }
        System.out.println();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так как класс <code>Scanner</code> находится в пакете <code>java.util</code>, то мы вначале его импортируем. Для создания самого объекта <code>Scanner</code> в его конструктор передается объект <code>System.in</code>. После этого мы можем получать вводимые значения. Например, чтобы получить введенное число, используется метод <code>in.nextInt();</code>, который возвращает введенное с клавиатуры целочисленное значение.</p>
</div>
<div class="paragraph">
<p>В данном случае в цикле вводятся все элементы массива, а с помощью другого цикла все ранее введенные элементы массива выводятся в строчку.</p>
</div>
<div class="paragraph">
<p>Класс <code>Scanner</code> имеет еще ряд методов, которые позволяют получить введенные пользователем значения:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>next()</code>: считывает введенную строку до первого пробела</p>
</li>
<li>
<p><code>nextLine()</code>: считывает всю введенную строку</p>
</li>
<li>
<p><code>nextInt()</code>: считывает введенное число <code>int</code></p>
</li>
<li>
<p><code>nextDouble()</code>: считывает введенное число <code>double</code></p>
</li>
<li>
<p><code>hasNext()</code>: проверяет, было ли введено слово</p>
</li>
<li>
<p><code>hasNextInt()</code>: проверяет, было ли введено число <code>int</code></p>
</li>
<li>
<p><code>hasNextDouble()</code>: проверяет, было ли введено <code>double</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Кроме того, класс <code>Scanner</code> имеет еще ряд методов <code>nextByte()</code>/<code>nextShort()</code>/<code>nextFloat()</code>/<code>nextBoolean()</code>, которые по аналогии с <code>nextInt()</code> считывают данные определенного типа данных.</p>
</div>
<div class="paragraph">
<p>Создадим следующую программу для ввода информации о человеке:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.Scanner;

public class FirstApp {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print("Введите имя: ");
        String name = in.nextLine();
        System.out.print("Введите возраст: ");
        int age = in.nextInt();
        System.out.println("Ваше имя: " + name + "   Ваш возраст: " + age);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например, если бы мы запускали проект в <strong>IntelliJ IDEA</strong>, то это выглядело бы так:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/img/java/core/language/console-output.png" alt="Console Output">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_проблема_с_кириллическими_символами">Проблема с кириллическими символами</h3>
<div class="paragraph">
<p>Нередко при вводе кириллических символов отображаются некорректные символы. В прицнипе проблема касается не только кириллических символов, но символов ряда других кодировок, отличающихся от латиницы. В этом случае надо настроить кодировку. Для этого можно пойти двумя путями.</p>
</div>
<div class="paragraph">
<p>Первый способ заключается в выборе кодировке в самой IDE. Для этого перейдем в меню <strong>File &#8594; Setting</strong> или hotkey <code>Ctrl+Alt+S</code>.</p>
</div>
<div class="paragraph">
<p>Нам откроется окно настроек проекта, где в самом низу нам надо выбрать вместо кодировки по умолчанию <code>UTF-8</code> кодировку <code>windows-1251</code>:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/img/java/core/language/problem-encoding.png" alt="Problem encoding">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_преобразование_базовых_типов_данных">Преобразование базовых типов данных</h2>
<div class="sectionbody">
<div class="paragraph">
<p>При рассмотрении типов данных указывалось, какие значения может иметь тот или иной тип и сколько байт памяти он может занимать. И мы можем написать, например, так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">byte x = 5;
byte y = x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Но важно понимать, что это запись не эквивалентна следующей (хотя результат будет тот же):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">byte x = 5;
int y = x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>В обоих случаях создается переменная типа <code>byte</code>, которая затем приравнивается другой переменной. Однако если в первом случае это простое приравнивание, а переменная <code>y</code> просто получает значение переменной <code>x</code>, то во втором примере происходит преобразование типов: данные типа <code>byte</code> преобразуются к типу <code>int</code>. Данный тип преобразований называется расширяющим, так как значение типа <code>byte</code> расширяет свой размер до размера типа <code>int</code>. Расширяющие преобразования проходят автоматически и обычно с этим никаких проблем не возникает.</p>
</div>
<div class="paragraph">
<p>Подобным образом происходит преобразование от типа <code>float</code> к типу <code>double</code> или от типа <code>int</code> к типу <code>long</code>.</p>
</div>
<div class="paragraph">
<p>Кроме расширяющих преобразований есть еще и сужающие. Сужающие преобразования позволяют привести данные к типу с меньшей разрядностью, например, от типа <code>int</code>, который занимает <code>4 байта</code> в памяти, к типу <code>byte</code>, который занимает только <code>1 байт</code> в памяти:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 4;
byte b = a; // ! Error</code></pre>
</div>
</div>
<div class="paragraph">
<p>Несмотря на то, что значение переменной <code>a</code> - число <code>4</code> укладывается в диапазон типа <code>byte</code>, мы все равно получим ошибку. И чтобы безошибочно провести преобразование из одного типа к другому, нам надо применить операцию приведения типов. Суть этой операции состоит в том, что в скобках указывается тип, к которому надо привести данное значение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 4;
byte b = (byte) a;</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_потеря_данных_при_преобразовании">Потеря данных при преобразовании</h3>
<div class="paragraph">
<p>В предыдущей ситуации число <code>4</code> вполне укладывалось в диапазон значений типа <code>byte</code>. Но что будет в следующем случае:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 200;
byte b = (byte) a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Результатом будет число <code>-56</code>. В данном случае число <code>200</code> вне диапазона для типа <code>byte</code> (от <code>-128</code> до <code>127</code>), поэтому произойдет усечение значения.</p>
</div>
</div>
<div class="sect2">
<h3 id="_усечение_рациональных_чисел_до_целых">Усечение рациональных чисел до целых</h3>
<div class="paragraph">
<p>При преобразовании значений с плавающей точкой к целочисленным значениям, происходит усечение дробной части:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">double
a = 56.9898;
int b = (int) a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь значение числа <code>b</code> будет равно <code>56</code>, несмотря на то, что число <code>57</code> было бы ближе к <code>56.9898</code>. Чтобы избежать подобных казусов, надо применять функцию округления, которая есть в математической библиотеке Java:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">double a = 56.9898;
int b = (int) Math.round(a);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_преобразования_при_операциях">Преобразования при операциях</h3>
<div class="paragraph">
<p>Нередки ситуации, когда приходится применять различные операции, например, сложение и произведение, над значениями разных типов. Здесь также действуют некоторые правила:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>если один из операндов операции относится к типу <code>double</code>, то и второй операнд преобразуется к типу <code>double</code></p>
</li>
<li>
<p>если предыдущее условие не соблюдено, а один из операндов операции относится к типу <code>float</code>, то и второй операнд преобразуется к типу <code>float</code></p>
</li>
<li>
<p>если предыдущие условия не соблюдены, один из операндов операции относится к типу <code>long</code>, то и второй операнд преобразуется к типу <code>long</code></p>
</li>
<li>
<p>иначе все операнды операции преобразуются к типу <code>int</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Примеры преобразований:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 3;
double b = 4.6;
double c = a + b;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так как в операции участвует значение типа <code>double</code>, то и другое значение приводится к типу <code>double</code> и сумма двух значений <code>a + b</code> будет представлять тип <code>double</code>.</p>
</div>
<div class="paragraph">
<p>Другой пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">byte a = 3;
short b = 4;
byte c = (byte) (a + b);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Две переменных типа <code>byte</code> и <code>short</code> (не <code>double</code>, <code>float</code> или <code>long</code>), поэтому при сложении они преобразуются к типу <code>int</code>, и их сумма <code>a + b</code> представляет значение типа <code>int</code>. Поэтому если затем мы присваиваем эту сумму переменной типа <code>byte</code>, то нам опять надо сделать преобразование типов к <code>byte</code>.</p>
</div>
<div class="paragraph">
<p>Если в операциях участвуют данные типа <code>char</code>, то они преобразуются в <code>int</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int d = 'a' + 5;
System.out.println(d); // 102</code></pre>
</div>
</div>
<div class="paragraph">
<p>Стоит отметить, что несмотря на то, что преобразования из <code>int &#8594; float</code>, <code>long &#8594; float</code> и <code>long &#8594; double</code> произволятся без ошибок, но при преобразовании мы можем столкнутьс с потерей информации. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">float b = 123456789;
System.out.println(b); // 1.23456792E8</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_методы">Методы</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_использование_методов_в_программе">Использование методов в программе</h3>
<div class="paragraph">
<p>Если <strong>переменные</strong> и <strong>константы</strong> хранят некоторые значения, то <strong>методы</strong> содержат собой набор операторов, которые выполняют определенные действия.</p>
</div>
<div class="paragraph">
<p>Общее определение методов выглядит следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">[модификаторы] тип_возвращаемого_значения название_метода([параметры]) {
    // тело метода
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Модификаторы и параметры необязательны.</p>
</div>
<div class="paragraph">
<p>По умолчанию главный класс любой программы на <strong>Java</strong> содержит метод <code>main</code>, который <strong>служит точкой входа в программу</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    System.out.println("привет мир!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ключевые слова <code>public</code> и <code>static</code> являются <strong>модификаторами</strong>. Далее идет <strong>тип возвращаемого значения</strong>. Ключевое слово <code>void</code> указывает на то, что метод ничего не возвращает.</p>
</div>
<div class="paragraph">
<p>Затем идут <strong>название метода</strong> - <code>main</code> и в скобках <strong>параметры метода</strong> - <code>String[] args</code>. И в фигурные скобки заключено <strong>тело метода</strong> - все действия, которые он выполняет.</p>
</div>
<div class="paragraph">
<p>Создадим еще несколько методов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String args[]) {

    }

    void hello() {
        System.out.println("Hello");
    }

    void welcome() {
        System.out.println("Welcome to Java 10");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь определены два дополнительных метода: <code>hello()</code> и <code>welcome()</code>, каждый из которых выводит некоторую строку на консоль. Методы определяются внутри класса - в данном случае внутри класса <code>Program</code>, в котором определен метод <code>main</code>.</p>
</div>
<div class="paragraph">
<p>Но если мы скомпилируем и запустим данную программу, то мы ничего не увидим на консоли. В примере выше мы определили два метода, но мы их нигде не вызываем. По умолчанию в программе <strong>Java</strong> выполняется только метод <code>main()</code> и все его содержимое. Поэтому, если мы хотим, чтобы другие методы тоже выполнялись, их надо вызвать в методе <code>main()</code>.</p>
</div>
<div class="paragraph">
<p>Вызов метода осуществляется в форме:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">имя_метода(аргументы);</code></pre>
</div>
</div>
<div class="paragraph">
<p>После <strong>имени метода</strong> указываются скобки, в которых перечисляются <strong>аргументы</strong> - значения для параметров метода.</p>
</div>
<div class="paragraph">
<p>Например, определим и выполним несколько методов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String args[]) {
         hello();
         welcome();
         welcome();
    }

    static void hello() {
        System.out.println("Hello");
    }

    static void welcome() {
        System.out.println("Welcome to Java!");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В методе <code>main()</code> вызывается один раз метод <code>hello()</code> и два раза метод <code>welcome()</code>. В этом и заключается одно из преимуществ методов: мы можем вынести некоторые общие действия в отдельный метод и затем вызывать многократно их в различных местах программы. Поскольку оба метода не имеют никаких параметров, то после их названия при вызове ставятся пустые скобки.</p>
</div>
<div class="paragraph">
<p>Также следует отметить, что чтобы вызвать в методе <code>main()</code> другие методы, которые определены в одном классе с методом <code>main()</code>, они должны иметь <strong>модификатор</strong> <code>static</code>.</p>
</div>
<div class="paragraph">
<p>В итоге после компиляции и выполнения программы мы увидим на консоли:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-output" data-lang="output">Hello
Welcome to Java!
Welcome to Java!</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_передача_параметров_в_методы">Передача параметров в методы</h3>
<div class="paragraph">
<p>С помощью параметров мы можем передать в методы различные данные, которые будут использоваться для вычислений. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">static void sum(int x, int y) {
    int z = x + y;
    System.out.println(z);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Данная функция принимает два параметра - два числа, складывает их и выводит их сумму на консоль.</p>
</div>
<div class="paragraph">
<p>А при вызове этого метода в программе нам необходимо передать на место параметров значения, которые соответствуют типу параметра:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String args[]) {
        int a = 6;
        int b = 8;
        sum(a, b); // 14
        sum(3, a); // 9
        sum(5, 23); // 28
    }

    static void sum(int x, int y) {
        int z = x + y;
        System.out.println(z);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Поскольку метод <code>sum</code> принимает два значения типа <code>int</code>, то на место параметров надо передать два значения типа <code>int</code>. Это могут быть и числовые литералы, и переменные типов данных, которые представляют тип <code>int</code> или могут быть автоматически преобразованы в тип <code>int</code>. Значения, которые передаются на место параметров, еще называются аргументами. Значения передаются параметрам по позиции, то есть первый аргумент первому параметру, второй аргумент - второму параметру и так далее.</p>
</div>
<div class="paragraph">
<p>Рассмотрим другой пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String args[]) {
        display("Tom", 34);
        display("Bob", 28);
        display("Sam", 23);
    }

    static void display(String name, int age) {
        System.out.println(name);
        System.out.println(age);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>display()</code> принимает два параметра. Первый параметр представляет тип <code>String</code>, а второй - тип <code>int</code>. Поэтому при вызове метода вначале в него надо передать строку, а затем число.</p>
</div>
</div>
<div class="sect2">
<h3 id="_параметры_переменной_длины">Параметры переменной длины</h3>
<div class="paragraph">
<p>Метод может принимать параметры переменной длины одного типа. Например, нам надо передать в метод набор числел и ычислить их сумму, но мы точно не знаем, сколько именно чисел будет передано - 3, 4, 5 или больше. Параметры переменной длины позволяют решить эту задачу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String args[]) {
        sum(1, 2, 3); // 6
        sum(1, 2, 3, 4, 5); // 15
        sum(); // 0
    }

    static void sum(int ...nums) {
        int result = 0;
        for (int n : nums) {
            result += n;
        }
        System.out.println(result);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Троеточие перед названием параметра <code>int &#8230;&#8203;nums</code> указывает на то, что он будет необязательным и будет представлять массив. Мы можем передать в метод <code>sum()</code> одно число, несколько чисел, а можем вообще не передавать никаких параметров. Причем, если мы хотим передать несколько параметров, то необязательный параметр должен указываться в конце:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    sum("Welcome!", 20, 10);
    sum("Hello World!");
}

static void sum(String message, int ...nums) {
    System.out.println(message);
    int result = 0;
    for (int x: nums) {
        result += x;
    }
    System.out.println(result);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_оператор_return">Оператор <code>return</code></h3>
<div class="paragraph">
<p>Методы могут возвращать некоторое значение. Для этого применяется оператор <code>return</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">return возвращаемое_значение;</code></pre>
</div>
</div>
<div class="paragraph">
<p>После оператора <code>return</code> указывается возвращаемое значение, которое является результатом метода. Это может быть литеральное значение, значение переменной или какого-то сложного выражения.</p>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String args[]) {
        int x = sum(1, 2, 3);
        int y = sum(1, 4, 9);
        System.out.println(x); // 6
        System.out.println(y); // 14
    }

    static int sum(int a, int b, int c) {
        return a + b + c;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В методе в качестве типа возвращаемого значения вместо <code>void</code> используется любой другой тип. В данном случае метод sum возвращает значение типа <code>int</code>, поэтому этот тип указывается перед названием метода. Причем если в качестве возвращаемого типа для метода определен любой другой, отличный от <code>void</code>, то метод обязательно должен использовать оператор <code>return</code> для возвращения значения.</p>
</div>
<div class="paragraph">
<p>При этом возвращаемое значение всегда должно иметь тот же тип, что значится в определении функции. И если функция возвращает значение типа <code>int</code>, то после оператора <code>return</code> стоит целочисленное значение, которое является объектом типа <code>int</code>. Как в данном случае это сумма значений параметров метода.</p>
</div>
<div class="paragraph">
<p>Метод может использовать несколько вызовов оператора <code>return</code> для возваращения разных значений в зависимости от некоторых условий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String args[]) {
        System.out.println(daytime(7)); // Good morning
        System.out.println(daytime(13)); // Good after noon
        System.out.println(daytime(18)); // Good evening
        System.out.println(daytime(2)); // Good night
    }

    static String daytime(int hour) {
        if (hour &gt;24 || hour &lt; 0) {
            return "Invalid data";
        } else if(hour &gt; 21 || hour &lt; 6) {
            return "Good night";
        } else if(hour &gt;= 15) {
            return "Good evening";
        } else if(hour &gt;= 11) {
            return "Good after noon";
        } else {
            return "Good morning";
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь метод <code>daytime()</code> возвращает значение типа <code>String</code>, то есть строку, и в зависимости от значения параметра <code>hour</code> возвращаемая строка будет различаться.</p>
</div>
<div class="sect3">
<h4 id="_выход_из_метода">Выход из метода</h4>
<div class="paragraph">
<p>Оператор <code>return</code> применяется для возвращаения значения из метода, но и для выхода из метода. В подобном качестве оператор <code>return</code> применяется в методах, которые ничего не возвращают, то есть имеют тип <code>void</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String args[]) {
        daytime(7); // Good morning
        daytime(13); // Good after noon
        daytime(32); //
        daytime(56); //
        daytime(2); // Good night
    }

    static void daytime(int hour) {
        if (hour &gt;24 || hour &lt; 0) {
            return;
        } else if(hour &gt; 21 || hour &lt; 6) {
            System.out.println("Good night");
        } else if(hour &gt;= 15) {
            System.out.println("Good evening");
        } else if(hour &gt;= 11) {
            System.out.println("Good after noon");
        } else {
            System.out.println("Good morning");
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если переданное в метод <code>datetime()</code> значение больше <code>24</code> или меньше <code>0</code>, то просто выходим из метода. Возвращаемое значение после <code>return</code> указывать в этом случае не нужно.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_операторы">Операторы</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_арифметические_операторы">Арифметические операторы</h3>
<div class="paragraph">
<p>Большинство операций в Java аналогичны тем, которые применяются в других <strong>C</strong>-подобных языках. Для выполнения операции используются <strong>оператор</strong> (<strong>operator</strong>), т.е. символ, который используется для этой операции (например: <code>+</code>, <code>-</code> и т.д.).</p>
</div>
<div class="paragraph">
<p>Есть следующие операторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>унарные</strong> - выполняются над одним операндом</p>
</li>
<li>
<p><strong>бинарные</strong> - выполняются над двумя операндами</p>
</li>
<li>
<p><strong>тернарные</strong> - выполняются над тремя операндами</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Операндом</strong> является <strong>переменная</strong> или <strong>литерал</strong> (например, литерал типа <code>int</code>), участвующее в операции. Рассмотрим все виды операторов.</p>
</div>
<div class="paragraph">
<p>В арифметических операциях участвуют числа. Для этих операций в Java есть бинарные и унарные арифметические операторы</p>
</div>
<div class="sect3">
<h4 id="_бинарные">Бинарные</h4>
<div class="paragraph">
<p>К бинарным операторам относят следующие:</p>
</div>
<div class="sect4">
<h5 id=""><code>+</code></h5>
<div class="paragraph">
<p>оператор сложения двух чисел:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 10;
int b = 7;
int c = a + b; // 17
int d = 4 + b; // 11</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_2"><code>-</code></h5>
<div class="paragraph">
<p>оператор вычитания двух чисел:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 10;
int b = 7;
int c = a - b; // 3
int d = 4 - a; // -6</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_3"><code>*</code></h5>
<div class="paragraph">
<p>оператор умножения двух чисел</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 10;
int b = 7;
int c = a * b; // 70
int d = b * 5; // 35</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_4"><code>/</code></h5>
<div class="paragraph">
<p>оператор деления двух чисел:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 20;
int b = 5;
int c = a / b; // 4
double d = 22.5 / 4.5; // 5.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>При делении стоит учитывать, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной <code>float</code> или <code>double</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">double k = 10 / 4; // 2
System.out.println(k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы результат представлял число с плавающей точкой, один из операндов также должен представлять число с плавающей точкой:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">double k = 10.0 / 4; // 2.5
System.out.println(k);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_5"><code>%</code></h5>
<div class="paragraph">
<p>получение остатка от деления двух чисел:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 33;
int b = 5;
int c = a % b; // 3
int d = 22 % 4; // 22 - 4 * 5 = 2</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_унарные">Унарные</h4>
<div class="paragraph">
<p>В Java есть два унарных арифметических оператора, которые применяются к одному числу:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>++</code> <strong>инкремент</strong></p>
</li>
<li>
<p><code>--</code> <strong>декремент</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Каждый из операторов имеет две разновидности:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>префиксный</p>
</li>
<li>
<p>постфиксный</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_префиксный_инкремент"><code>++</code> (префиксный инкремент)</h5>
<div class="paragraph">
<p>Увеличение переменной на единицу, например, <code>z = ++y</code> (вначале значение переменной <code>y</code> увеличивается на <code>1</code>, а затем ее значение присваивается переменной <code>z</code>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 8;
int b = ++a;
System.out.println(a); // 9
System.out.println(b); // 9</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_постфиксный_инкремент"><code>++</code> (постфиксный инкремент)</h5>
<div class="paragraph">
<p>Увеличение переменной на единицу, например, <code>z = y++</code> (вначале значение переменной y присваивается переменной <code>z</code>, а потом значение переменной <code>y</code> увеличивается на <code>1</code>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 8;
int b = a++;
System.out.println(a); // 9
System.out.println(b); // 8</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_префиксный_декремент"><code>--</code> (префиксный декремент)</h5>
<div class="paragraph">
<p>Уменьшение переменной на единицу, например, <code>z = --y</code> (вначале значение переменной <code>y</code> уменьшается на <code>1</code>, а потом ее значение присваивается переменной <code>z</code>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 8;
int b = --a;
System.out.println(a); // 7
System.out.println(b); // 7</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_постфиксный_декремент"><code>--</code> (постфиксный декремент)</h5>
<div class="paragraph">
<p>Уменьшение переменной на единицу, например, <code>z = y--</code> (сначала значение переменной <code>y</code> присваивается переменной <code>z</code>, а затем значение переменной <code>y</code> уменьшается на <code>1</code>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 8;
int b = a--;
System.out.println(a); // 7
System.out.println(b); // 8</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_операторы_сравнения">Операторы сравнения</h3>
<div class="paragraph">
<p>Условные выражения представляют собой некоторое условие и возвращают значение типа <code>boolean</code>, то есть значение <code>true</code> (если условие истинно), или значение <code>false</code> (если условие ложно). К условным выражениям относятся выражения, которыя содержат операторы сравнения и логические операторы.</p>
</div>
<div class="paragraph">
<p>C операторами сравнения в выражении используются два операнда, и возвращается значение типа <code>boolean</code> - <code>true</code>, если выражение верно, и <code>false</code>, если выражение неверно.</p>
</div>
<div class="sect3">
<h4 id="_6"><code>==</code></h4>
<div class="paragraph">
<p>сравнивает два операнда на равенство и возвращает <code>true</code> (если операнды равны) и <code>false</code> (если операнды не равны)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 10;
int b = 4;
boolean c = a == b; // false
boolean d = a == 10; // true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_7"><code>!=</code></h4>
<div class="paragraph">
<p>сравнивает два операнда и возвращает <code>true</code>, если операнды НЕ равны, и <code>false</code>, если операнды равны</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 10;
int b = 4;
boolean c = a != b; // true
boolean d = a != 10; // false</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_меньше_чем"><code>&lt;</code> (меньше чем)</h4>
<div class="paragraph">
<p>Возвращает <code>true</code>, если первый операнд меньше второго, иначе возвращает <code>false</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 10;
int b = 4;
boolean c = a &lt; b; // false</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_больше_чем"><code>&gt;</code> (больше чем)</h4>
<div class="paragraph">
<p>Возвращает <code>true</code>, если первый операнд больше второго, иначе возвращает <code>false</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 10;
int b = 4;
boolean c = a &gt; b; // true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_больше_или_равно"><code>&gt;=</code> (больше или равно)</h4>
<div class="paragraph">
<p>Возвращает <code>true</code>, если первый операнд больше второго или равен второму, иначе возвращает <code>false</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">boolean c = 10 &gt;= 10; // true
boolean b = 10 &gt;= 4; // true
boolean d = 10 &gt;= 20; // false</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_меньше_или_равно"><code>&#8656;</code> (меньше или равно)</h4>
<div class="paragraph">
<p>Возвращает <code>true</code>, если первый операнд меньше второго или равен второму, иначе возвращает <code>false</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">boolean c = 10 &lt;= 10; // true
boolean b = 10 &lt;= 4; // false
boolean d = 10 &lt;= 20; // true</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_логические_операторы">Логические операторы</h3>
<div class="paragraph">
<p>Также в Java есть логические операторы, которые используются в условиях и возвращают <code>true</code> или <code>false</code> и обычно объединяют несколько операторов сравнения. К логическим операторам относят следующие:</p>
</div>
<div class="sect3">
<h4 id="_8"><code>|</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">boolean c = a | b;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>c</code> равно <code>true</code>, если либо <code>a</code>, либо <code>b</code> (либо и <code>a</code>, и <code>b</code>) равны <code>true</code>, иначе c будет равно <code>false</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_9"><code>&amp;</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">boolean c = a &amp; b;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>c</code> равно <code>true</code>, если и <code>a</code>, и <code>b</code> равны <code>true</code>, иначе <code>c</code> будет равно <code>false</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_10"><code>!</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">boolean c = !b;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>c</code> равно <code>true</code>, если <code>b</code> равно <code>false</code>, иначе <code>c</code> будет равно <code>false</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_11"><code>^</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">boolean c = a ^ b;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>c</code> равно <code>true</code>, если либо <code>a</code>, либо <code>b</code> (но не одновременно) равны <code>true</code>, иначе <code>c</code> будет равно <code>false</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_12"><code>||</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">boolean c = a || b;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>c</code> равно <code>true</code>, если либо <code>a</code>, либо <code>b</code> (либо и <code>a</code>, и <code>b</code>) равны <code>true</code>, иначе c будет равно <code>false</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_13"><code>&amp;&amp;</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">boolean c = a &amp;&amp; b;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>c</code> равно <code>true</code>, если и <code>a</code>, и <code>b</code> равны <code>true</code>, иначе c будет равно <code>false</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_разница_между_и_и">Разница между <code>|</code> и <code>||</code>, <code>&amp;</code> и <code>&amp;&amp;</code></h4>
<div class="paragraph">
<p>Здесь две пары операторов <code>|</code> и <code>||</code> (а также <code>&amp;</code> и <code>&amp;&amp;</code>) возвращают похожие результаты, однако же они не равнозначны.</p>
</div>
<div class="paragraph">
<p>Выражение <code>c = a | b;</code> будет вычислять сначала оба значения - <code>a</code> и <code>b</code> и на их основе выводить результат.</p>
</div>
<div class="paragraph">
<p>В выражении же <code>c = a || b;</code> вначале будет вычисляться значение <code>a</code>, и если оно равно <code>true</code>, то вычисление значения <code>b</code> уже смысла не имеет, так как у нас в любом случае уже <code>c</code> будет равно <code>true</code>. Значение <code>b</code> будет вычисляться только в том случае, если <code>a</code> равно <code>false</code></p>
</div>
<div class="paragraph">
<p>То же самое касается пары операций <code>&amp;</code>/<code>&amp;&amp;</code>. В выражении <code>c = a &amp; b;</code> будут вычисляться оба значения - <code>a</code> и <code>b</code>.</p>
</div>
<div class="paragraph">
<p>В выражении же <code>c = a &amp;&amp; b;</code> сначала будет вычисляться значение <code>a</code>, и если оно равно <code>false</code>, то вычисление значения <code>b</code> уже не имеет смысла, так как значение <code>c</code> в любом случае равно <code>false</code>. Значение <code>b</code> будет вычисляться только в том случае, если a равно <code>true</code></p>
</div>
<div class="paragraph">
<p>Таким образом, операторы <code>||</code> и <code>&amp;&amp;</code> более удобны в вычислениях, позволяя сократить время на вычисление значения выражения и тем самым повышая производительность. А операторы <code>|</code> и <code>&amp;</code> больше подходят для выполнения поразрядных операций над числами.</p>
</div>
</div>
<div class="sect3">
<h4 id="_примеры">Примеры:</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">boolean a1 = (5 &gt; 6) || (4 &lt; 6); // 5 &gt; 6 - false, 4 &lt; 6 - true, поэтому возвращается true
boolean a2 = (5 &gt; 6) || (4 &gt; 6); // 5 &gt; 6 - false, 4 &gt; 6 - false, поэтому возвращается false
boolean a3 = (5 &gt; 6) &amp;&amp; (4 &lt; 6); // 5 &gt; 6 - false, 4 &lt; 6 - true, поэтому возвращается false
boolean a4 = (50 &gt; 6) &amp;&amp; (4 / 2 &lt; 3); // 50 &gt; 6 - true, 4/2 &lt; 3 - true, поэтому возвращается true
boolean a5 = (5 &gt; 6) ^ (4 &lt; 6); // 5 &gt; 6 - false, 4 &lt; 6 - true, поэтому возвращается true
boolean a6 = (50 &gt; 6) ^ (4 / 2 &lt; 3); // 50 &gt; 6 - true, 4/2 &lt; 3 - true, поэтому возвращается false</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_операторы_присваивания">Операторы присваивания</h3>
<div class="paragraph">
<p>Операторы присваивания в основном представляют комбинацию простого присваивания с другими операторами:</p>
</div>
<div class="sect3">
<h4 id="_14"><code>=</code></h4>
<div class="paragraph">
<p><code>c = b;</code> (переменной <code>c</code> приравнивает значение переменной <code>b</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="_15"><code>+=</code></h4>
<div class="paragraph">
<p><code>c += b;</code> (переменной <code>c</code> присваивается результат сложения <code>c</code> и <code>b</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="_16"><code>-=</code></h4>
<div class="paragraph">
<p><code>c -= b;</code> (переменной <code>c</code> присваивается результат вычитания <code>b</code> из <code>c</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="_17"><code>*=</code></h4>
<div class="paragraph">
<p><code>c *= b;</code> (переменной <code>c</code> присваивается результат произведения <code>c `и `b</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="_18"><code>/=</code></h4>
<div class="paragraph">
<p><code>c /= b;</code> (переменной <code>c</code> присваивается результат деления <code>c</code> на <code>b</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="_19"><code>%=</code></h4>
<div class="paragraph">
<p><code>c %= b;</code> (переменной <code>c</code> присваивается остаток от деления <code>c</code> на <code>b</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="_20"><code>&amp;=</code></h4>
<div class="paragraph">
<p><code>c &amp;= b;</code> (переменной <code>c</code> присваивается значение <code>c &amp; b</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="_21"><code>|=</code></h4>
<div class="paragraph">
<p><code>c |= b;</code> (переменной <code>c</code> присваивается значение <code>c | b</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="_22"><code>^=</code></h4>
<div class="paragraph">
<p><code>c ^= b;</code> (переменной <code>c</code> присваивается значение <code>c ^ b</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="_23"><code>&lt;&#8656;</code></h4>
<div class="paragraph">
<p><code>c &lt;&#8656; b;</code> (переменной <code>c</code> присваивается значение <code>c &lt;&lt; b</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="_24"><code>&gt;&gt;=</code></h4>
<div class="paragraph">
<p><code>c &gt;&gt;= b;</code> (переменной <code>c</code> присваивается значение <code>c &gt;&gt; b</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="_25"><code>&gt;&gt;&gt;=</code></h4>
<div class="paragraph">
<p><code>c &gt;&gt;&gt;= b;</code> (переменной <code>c</code> присваивается значение <code>c &gt;&gt;&gt; b</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="_примеры_операций">Примеры операций:</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 5;
a += 10; // 15
a -= 3; // 12
a *= 2; // 24
a /= 6; // 4
a &lt;&lt;= 4; // 64
a &gt;&gt;= 2; // 16
System.out.println(a);  // 16</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_побитовые_операторы">Побитовые операторы</h3>
<div class="paragraph">
<p>Побитовые операторы применяются к отдельным разрядам или битами чисел. Данные опараторы применяются с операндами, которые являются только целыми числами.</p>
</div>
<div class="sect3">
<h4 id="_логические_побитовые_операторы">Логические побитовые операторы</h4>
<div class="paragraph">
<p>Логические побитовые операторы для чисeл представляют собой поразрядные операторы. В данном случае числа рассматриваются в двоичном представлении, например, <code>2</code> в двоичной системе равно <code>10</code> и имеет два разряда, число <code>7</code> - <code>111</code> и имеет три разряда.</p>
</div>
<div class="sect4">
<h5 id="_логическое_умножение"><code>&amp;</code> (логическое умножение)</h5>
<div class="paragraph">
<p>Умножение производится поразрядно, и если у обоих операндов значения разрядов равно <code>1</code>, то после применения оператора возвращается <code>1</code>, иначе возвращается число <code>0</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a1 = 2; //010
int b1 = 5; //101
System.out.println(a1 &amp; b1); // результат 0

int a2 = 4; //100
int b2 = 5; //101
System.out.println(a2 &amp; b2); // результат 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>В первом случае у нас два числа <code>2</code> и <code>5</code>. <code>2</code> в двоичном виде представляет число <code>010</code>, а <code>5</code> - <code>101</code>. Поразрядное умножение чисел <code>(0*1, 1*0, 0*1)</code> дает результат <code>000</code>.</p>
</div>
<div class="paragraph">
<p>Во втором случае у нас вместо <code>2</code> число <code>4</code>, у которого в первом разряде <code>1</code>, так же как и у числа <code>5</code>, поэтому здесь результатом применения оператора <code>(1*1, 0*0, 0 *1) = 100</code> будет число <code>4</code> в десятичном формате.</p>
</div>
</div>
<div class="sect4">
<h5 id="_логическое_сложение"><code>|</code> (логическое сложение)</h5>
<div class="paragraph">
<p>Данный оператор также применяется к двоичным разрядам, но теперь возвращается единица, если хотя бы у одного числа в данном разряде имеется единица (оператор <strong>логическое ИЛИ</strong>). Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a1 = 2; //010
int b1 = 5; //101
System.out.println(a1 | b1); // результат 7 - 111

int a2 = 4; //100
int b2 = 5; //101
System.out.println(a2 | b2); // результат 5 - 101</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_логическое_исключающее_или"><code>^</code> (логическое исключающее <strong>ИЛИ</strong>)</h5>
<div class="paragraph">
<p>Иногда этот оператор называют <code>XOR</code>, нередко его применяют для простого шифрования:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int number = 45; // 1001 Значение, которое надо зашифровать - в двоичной форме 101101
int key = 102; // Ключ шифрования - в двоичной системе 1100110
int encrypt = number ^ key; // Результатом будет число 1001011 или 75
System.out.println("Зашифрованное число: " +encrypt);

int decrypt = encrypt ^ key; // Результатом будет исходное число 45
System.out.println("Расшифрованное число: " + decrypt);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь также производятся поразрядное применение оператора. Если значения текущего разряда у обоих чисел разные, то возвращается <code>1</code>, иначе возвращается <code>0</code>. Например, результатом выражения <code>9 ^ 5</code> будет число <code>12</code>. А чтобы расшифровать число, мы применяем обратный оператор к результату.</p>
</div>
</div>
<div class="sect4">
<h5 id="_логическое_отрицание"><code>~</code> (логическое отрицание)</h5>
<div class="paragraph">
<p>Поразрядный оператор, инвертирующий все разряды числа: если значение разряда равно <code>1</code>, то оно становится равным <code>0</code>, и наоборот.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int a = 56;
System.out.println(~a);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_побитовые_операторы_сдвига">Побитовые операторы сдвига</h4>
<div class="paragraph">
<p>Операторы сдвига также производятся над разрядами чисел. Сдвиг может происходить вправо и влево.</p>
</div>
<div class="sect4">
<h5 id="_26"><code>&lt;&lt;</code></h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">a &lt;&lt; b</code></pre>
</div>
</div>
<div class="paragraph">
<p>сдвигает число <code>a</code> влево на <code>b</code> разрядов. Например, выражение <code>4 &lt;&lt; 1</code> сдвигает число <code>4</code> (которое в двоичном представлении <code>100</code>) на один разряд влево, в результате получается число <code>1000</code> или число <code>8</code> в десятичном представлении.</p>
</div>
</div>
<div class="sect4">
<h5 id="_27"><code>&gt;&gt;</code></h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">a &gt;&gt; b</code></pre>
</div>
</div>
<div class="paragraph">
<p>смещает число <code>a</code> вправо на <code>b</code> разрядов. Например, <code>16 &gt;&gt; 1</code> сдвигает число 16 (которое в двоичной системе <code>10000</code>) на один разряд вправо, то есть в итоге получается <code>1000</code> или число <code>8</code> в десятичном представлении.</p>
</div>
</div>
<div class="sect4">
<h5 id="_28"><code>&gt;&gt;&gt;</code></h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">a &gt;&gt;&gt; b</code></pre>
</div>
</div>
<div class="paragraph">
<p>в отличие от предыдущих типов сдвигов данный оператор представляет беззнаковый сдвиг - сдвигает число <code>a</code> вправо на <code>b</code> разрядов. Например, выражение <code>-8 &gt;&gt;&gt; 2</code> будет равно <code>1073741822</code>.</p>
</div>
<div class="paragraph">
<p>Таким образом, если исходное число, которое надо сдвинуть в ту или другую строну, делится на два, то фактически получается умножение или деление на два. Поэтому подобный оператор можно использовать вместо непосредственного умножения или деления на два, так как оператор сдвига на аппаратном уровне менее дорогостоящая оператор в отличие от операторов деления или умножения.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_приоритет_операций">Приоритет операций</h3>
<div class="paragraph">
<p>При работе с операторами важно понимать их приоритет, который можно описать следующей схемой (по убыванию приоритета):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">i++ i--

++i --i +i -i ~ !

* / %

+ -

&lt;&lt; &gt;&gt; &gt;&gt;&gt;

&lt; &gt; &lt;= &gt;= instanceof

== !=

&amp;

^

|

&amp;&amp;

||

? : (тернарный оператор)

= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= (операторы присваивания)</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Cкобки повышают приоритет операторы, используемой в выражении.</p>
</div>
</blockquote>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_условные_конструкции">Условные конструкции</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Одним из фундаментальных элементов многих языков программирования являются условные конструкции. Данные конструкции позволяют направить работу программы по одному из путей в зависимости от определенных условий.</p>
</div>
<div class="paragraph">
<p>В языке <strong>Java</strong> используются следующие условные конструкции: <code>if..else</code> и <code>switch..case</code></p>
</div>
<div class="sect2">
<h3 id="_конструкция_ifelse">Конструкция <code>if/else</code></h3>
<div class="paragraph">
<p>Выражение if/else проверяет истинность некоторого условия и в зависимости от результатов проверки выполняет определенный код:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int num1 = 6;
int num2 = 4;
if (num1 &gt; num2) {
    System.out.println("Первое число больше второго");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>После ключевого слова <code>if</code> ставится условие. И если это условие выполняется, то срабатывает код, который помещен в далее в блоке <code>if</code> после фигурных скобок. В качестве условий выступает операция сравнения двух чисел.</p>
</div>
<div class="paragraph">
<p>Так как, в данном случае первое число больше второго, то выражение <code>num1 &gt; num2</code> истинно и возвращает значение <code>true</code>. Следовательно, управление переходит в блок кода после фигурных скобок и начинает выполнять содержащиеся там инструкции, а конкретно метод <code>System.out.println("Первое число больше второго");</code>. Если бы первое число оказалось бы меньше второго или равно ему, то инструкции в блоке <code>if</code> не выполнялись бы.</p>
</div>
<div class="paragraph">
<p>Но что, если мы захотим, чтобы при несоблюдении условия также выполнялись какие-либо действия? В этом случае мы можем добавить блок <code>else</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int num1 = 6;
int num2 = 4;
if (num1 &gt; num2) {
    System.out.println("Первое число больше второго");
} else {
    System.out.println("Первое число меньше второго");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Но при сравнении чисел мы можем насчитать три состояния:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>первое число больше второго</p>
</li>
<li>
<p>первое число меньше второго</p>
</li>
<li>
<p>числа равны</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>С помощью выражения <code>else if</code>, мы можем обрабатывать дополнительные условия:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int num1 = 6;
int num2 = 8;
if (num1 &gt; num2) {
    System.out.println("Первое число больше второго");
} else if (num1 &lt; num2) {
    System.out.println("Первое число меньше второго");
} else {
    System.out.println("Числа равны");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Также мы можем соединить сразу несколько условий, используя логические операторы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int num1 = 8;
int num2 = 6;
if (num1 &gt; num2 &amp;&amp; num1 &gt; 7) {
    System.out.println("Первое число больше второго и больше 7");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь блок <code>if</code> будет выполняться, если <code>num1 &gt; num2</code> равно <code>true</code> и одновременно <code>num1 &gt; 7</code> равно <code>true</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_конструкция_switch">Конструкция <code>switch</code></h3>
<div class="paragraph">
<p>Конструкция <code>switch/case</code> аналогична конструкции <code>if/else</code>, так как позволяет обработать сразу несколько условий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int num = 8;
switch(num) {
    case 1:
        System.out.println("число равно 1");
        break;
    case 8:
        System.out.println("число равно 8");
        num++;
        break;
    case 9:
        System.out.println("число равно 9");
        break;
    default:
        System.out.println("число не равно 1, 8, 9");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>После ключевого слова <code>switch</code> в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями, помещенными после оператора <code>сase</code>. И если совпадение будет найдено, то будет выполняться определенный блок <code>сase</code>.</p>
</div>
<div class="paragraph">
<p>В конце блока <code>сase</code> ставится оператор <code>break</code>, чтобы избежать выполнения других блоков. Например, если бы убрали бы оператор <code>break</code> в следующем случае:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">case 8:
    System.out.println("число равно 8");
    num++;
case 9:
    System.out.println("число равно 9");
    break;</code></pre>
</div>
</div>
<div class="paragraph">
<p>то так как у нас переменная <code>num</code> равно <code>8</code>, то выполнился бы блок <code>case 8</code>, но так как в этом блоке переменная <code>num</code> увеличивается на единицу, оператор <code>break</code> отсутствует, то начал бы выполняться блок <code>case 9</code>.</p>
</div>
<div class="paragraph">
<p>Если мы хотим также обработать ситуацию, когда совпадения не будет найдено, то можно добавить блок <code>default</code>, как в примере выше. Хотя блок <code>default</code> необязателен.</p>
</div>
<div class="paragraph">
<p>Начиная с <strong>JDK 7</strong> в выражении <code>switch..case</code> кроме примитивных типов можно также использовать строки:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package firstapp;

import java.util.Scanner;

public class FirstApp {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println("Введите Y или N: ");
        String input = in.nextLine();
        switch(input) {
            case "Y":
                System.out.println("Вы нажали букву Y");
                break;
            case "N":
                System.out.println("Вы нажали букву N");
                break;
            default:
                System.out.println("Вы нажали неизвестную букву");
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_тернарная_операция">Тернарная операция</h3>
<div class="paragraph">
<p>Тернарная операция имеет следующий синтаксис:</p>
</div>
<div class="paragraph">
<p><code>[первый операнд - условие] ? [второй операнд] : [третий операнд]</code></p>
</div>
<div class="paragraph">
<p>Таким образом, в этой операции участвуют сразу три операнда. В зависимости от условия тернарная операция возвращает второй или третий операнд:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">если условие равно true,
    то возвращается второй операнд;
если условие равно false,
    то третий.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int x=3;
int y=2;
int z = x &lt; y ? (x + y) : (x - y);
System.out.println(z);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь результатом тернарной операции является переменная <code>z</code>. Сначала проверяется условие <code>x &lt; y</code>. И если оно соблюдается, то <code>z</code> будет равно второму операнду - <code>(x + y)</code>, иначе <code>z</code> будет равно третьему операнду.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_циклы">Циклы</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Еще одним видом управляющих конструкций являются циклы. Циклы позволяют в зависимости от определенных условий выполнять определенное действие множество раз. В языке <strong>Java</strong> есть следующие виды циклов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>for</code></p>
</li>
<li>
<p><code>while</code></p>
</li>
<li>
<p><code>do&#8230;&#8203;while</code></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_цикл_for">Цикл <code>for</code></h3>
<div class="paragraph">
<p>Цикл for имеет следующее формальное определение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">for ([инициализация счетчика]; [условие]; [изменение счетчика])
{
    // действия
}
Рассмотрим стандартный цикл for:</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">for (int i = 1; i &lt; 9; i++) {
    System.out.printf("Квадрат числа %d равен %d \n", i, i * i);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>объявления цикла</strong> - <code>int i = 1</code> создает и инициализирует <strong>счетчик</strong> <code>i</code>. <strong>Счетчик</strong> необязательно должен представлять тип <code>int</code>. Это может быть и любой другой числовой тип, например, <code>float</code>. Перед выполнением цикла значение <strong>счетчика</strong> будет равно <code>1</code>. В данном случае это то же самое, что и объявление переменной</p>
</li>
<li>
<p><strong>условие</strong>, при котором будет выполняться цикл. В данном случае цикл будет выполняться, пока <code>i</code> не достигнет <code>9</code></p>
</li>
<li>
<p><strong>приращение счетчика</strong> на единицу. Опять же нам необязательно увеличивать на единицу. Можно уменьшать: <code>i--</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В итоге блок цикла сработает 8 раз, пока значение <code>i</code> не станет равным <code>9</code>. И каждый раз это значение будет увеличиваться на <code>1</code>.</p>
</div>
<div class="paragraph">
<p>Нам необязательно указывать все условия при объявлении цикла. Например, мы можем написать так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int i = 1;
for ( ; ; ) {
    System.out.printf("Квадрат числа %d равен %d \n", i, i * i);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Определение цикла осталось тем же, только теперь блоки в определении у нас пустые: <code>for (; ;)</code>. Теперь нет инициализированной <strong>переменной-счетчика</strong>, нет <strong>условия</strong>, поэтому цикл будет работать вечно - <strong>бесконечный цикл</strong>.</p>
</div>
<div class="paragraph">
<p>Либо можно опустить ряд блоков:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int i = 1;
for ( ; i &lt; 9; ) {
    System.out.printf("Квадрат числа %d равен %d \n", i, i * i);
    i++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот пример эквивалентен первому примеру: у нас также есть <strong>счетчик</strong>, только создан он вне цикла. У нас есть <strong>условие выполнения цикла</strong>. И есть <strong>приращение счетчика</strong> уже в самом блоке <code>for</code>.</p>
</div>
<div class="paragraph">
<p>Цикл for может определять сразу несколько переменных и управлять ими:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int n = 10;
for (int i = 0, j = n - 1; i &lt; j; i++, j--) {
    System.out.println(i * j);
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_цикл_foreach">Цикл <code>foreach</code></h4>
<div class="paragraph">
<p>Специальная версия цикла <code>for</code> предназначена для перебора элементов в наборах элементов, например, в <strong>массивах</strong> и <strong>коллекциях</strong>. Она аналогична действию цикла <code>foreach</code> , который имеется в других языках программирования. Формальное ее объявление:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">for (тип_данных название_переменной : контейнер){
    // действия
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int[] array = new int[] { 1, 2, 3, 4, 5 };
for (int i : array) {
    System.out.println(i);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В качестве контейнера в данном случае выступает массив данных типа <code>int</code>. Затем объявляется переменная с типом <code>int</code></p>
</div>
<div class="paragraph">
<p>То же самое можно было бы сделать и с помощью обычной версии <code>for</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int[] array = new int[] { 1, 2, 3, 4, 5 };
for (int i = 0; i &lt; array.length; i++) {
    System.out.println(array[i]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В то же время эта версия цикла <code>for</code> более гибкая по сравнению <code>for (int i : array)</code>. В частности, в этой версии мы можем изменять элементы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int[] array = new int[] { 1, 2, 3, 4, 5 };
for (int i = 0; i &lt; array.length; i++) {
    array[i] = array[i] * 2;
    System.out.println(array[i]);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_перебор_многомерных_массивов_в_цикле">Перебор многомерных массивов в цикле</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int[][] nums = new int[][]
{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
for (int i = 0; i &lt; nums.length; i++) {
    for (int j = 0; j &lt; nums[i].length; j++) {
        System.out.printf("%d ", nums[i][j]);
    }
    System.out.println();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сначала создается цикл для перебора по строкам, а затем внутри первого цикла создается внутренний цикл для перебора по столбцам конкретной строки. Подобным образом можно перебрать и трехмерные массивы и наборы с большим количеством размерностей.</p>
</div>
</div>
<div class="sect2">
<h3 id="_цикл_do">Цикл <code>do</code></h3>
<div class="paragraph">
<p>Цикл <code>do</code> сначала выполняет <strong>код цикла</strong>, а потом проверяет <strong>условие</strong> в инструкции <code>while</code>. И пока это условие истинно, цикл повторяется. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int j = 7;
do {
    System.out.println(j);
    j--;
}
while (j &gt; 0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае код цикла сработает 7 раз, пока <code>j</code> не окажется равным нулю. Важно отметить, что цикл <code>do</code> <strong>гарантирует хотя бы однократное выполнение действий</strong>, даже если условие в инструкции <code>while</code> не будет истинно. Так, мы можем написать:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int j = -1;
do {
    System.out.println(j);
    j--;
}
while (j &gt; 0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Хотя переменная <code>j</code> изначально меньше <code>0</code>, цикл все равно один раз выполнится.</p>
</div>
</div>
<div class="sect2">
<h3 id="_цикл_while">Цикл <code>while</code></h3>
<div class="paragraph">
<p>Цикл <code>while</code> сразу проверяет истинность некоторого условия, и если условие истинно, то код цикла выполняется:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int j = 6;
while (j &gt; 0) {
    System.out.println(j);
    j--;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_операторы_continue_и_break">Операторы <code>continue</code> и <code>break</code></h3>
<div class="paragraph">
<p>Иногда требуется выйти из цикла, не дожидаясь его завершения. В этом случае мы можем воспользоваться оператором <code>break</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int[] nums = new int[] { 1, 2, 3, 4, 12, 9 };
for (int i = 0; i &lt; nums.length; i++) {
    if (nums[i] &gt; 10)
        break;
    System.out.println(nums[i]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так как в цикле идет проверка, больше ли элемент массива <code>10</code>, то мы не увидим на консоли последние два элемента, так как когда <code>nums[i]</code> окажется больше <code>10</code> (то есть равно <code>12</code>), сработает оператор <code>break</code>, и цикл завершится.</p>
</div>
<div class="paragraph">
<p>Правда, мы также не увидим и последнего элемента, который меньше <code>10</code>. Теперь сделаем так, чтобы если число больше <code>10</code>, цикл не завершался, а просто переходил к следующему элементу. Для этого используем оператор <code>continue</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int[] nums = new int[] { 1, 2, 3, 4, 12, 9 };
for (int i = 0; i &lt; nums.length; i++) {
    if (nums[i] &gt; 10)
        continue;
    System.out.println(nums[i]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом случае, когда выполнение цикла дойдет до числа <code>12</code>, которое не удовлетворяет условию проверки, то программа просто пропустит это число и перейдет к следующему элементу массива.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_массивы">Массивы</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_одномерные_массивы">Одномерные массивы</h3>
<div class="paragraph">
<p>Если переменные предназначены для хранения одиночного значения, то массив представляет набор однотипных значений. Объявление массива похоже на объявление переменной, причем есть два способа объявления массива:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">тип_данных[] название_массива;
// либо
тип_данных []название_массива;
// либо
тип_данных название_массива[];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например, определим массив чисел:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int[] nums3; // best practice
int []nums2;
int nums[];</code></pre>
</div>
</div>
<div class="paragraph">
<p>После объявления массива мы можем инициализовать его:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int nums[]; // объявили
nums = new int[4]; // инициализировали (массив из 4 чисел)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Создание массива производится с помощью следующей конструкции: <code>new тип_данных[количество_элементов]</code>, где <code>new</code> - ключевое слово, выделяющее память для указанного в скобках количества элементов. Например, <code>nums = new int[4];</code> - в этом выражении создается массив из четырех элементов <code>int</code> и каждый элемент по умолчанию равен <code>0</code>.</p>
</div>
<div class="paragraph">
<p>Также можно сразу при объявлении массива инициализировать его:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int nums[] = new int[4]; // массив из 4 чисел
int[] nums2 = new int[5]; // массив из 5 чисел</code></pre>
</div>
</div>
<div class="paragraph">
<p>При подобной инициализации все элементы массива имеют значение по умолчанию. Для числовых типов (в том числе для типа <code>char</code>) это число <code>0</code>, для типа <code>boolean</code> это значение <code>false</code>, а для остальных объектов это значение <code>null</code>. Например, для типа <code>int</code> значением по умолчанию является число <code>0</code>, поэтому выше определенный массив <code>nums</code> будет состоять из четырех нулей.</p>
</div>
<div class="paragraph">
<p>Однако также можно задать конкретные значения для элементов массива при его создании:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// эти два способа равноценны
int[] nums = new int[] {1, 2, 3, 5};
int[] nums2 = {1, 2, 3, 5};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Стоит отметить, что в этом случае в квадратных скобках не указывается размер массива, так как он вычисляется по количеству элементов в фигурных скобках.</p>
</div>
<div class="paragraph">
<p>После создания массива мы можем обратиться к любому его элементу и изменить его:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int[] nums = new int[4];
nums[0] = 1;
nums[1] = 2;
nums[2] = 4;
nums[3] = 100;
System.out.println(nums[2]); // 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Отсчет элементов массива начинается с <code>0</code>, поэтому в данном случае, чтобы обратиться к четвертому элементу в массиве, нам надо использовать выражение <code>nums[3]</code>.</p>
</div>
<div class="paragraph">
<p>И так как у нас массив определен только для 4 элементов, то мы не можем обратиться, например, к шестому элементу: <code>nums[5] = 5;</code>. Если мы так попытаемся сделать, то мы получим ошибку.</p>
</div>
</div>
<div class="sect2">
<h3 id="_многомерные_массивы">Многомерные массивы</h3>
<div class="paragraph">
<p>Ранее мы рассматривали одномерные массивы, которые можно представить как цепочку или строку однотипных значений. Но кроме одномерных массивов также бывают и многомерными. Наиболее известный многомерный массив - таблица, представляющая двухмерный массив:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int[] nums1 = new int[] {0, 1, 2, 3, 4, 5};
int[][] nums2 = {
  {0, 1, 2},
  {3, 4, 5}
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Визуально оба массива можно представить следующим образом:</p>
</div>
<div class="sect3">
<h4 id="_одномерный_массив_nums1">Одномерный массив <code>nums1</code></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_двухмерный_массив_nums2">Двухмерный массив <code>nums2</code></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Поскольку массив <code>nums2</code> двухмерный, он представляет собой простую таблицу. Его также можно было создать следующим образом: <code>int[][] nums2 = new int[3][3];</code>. Количество квадратных скобок указывает на размерность массива. А числа в скобках - на количество строк и столбцов. И также, используя индексы, мы можем использовать элементы массива в программе:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// установим элемент первого столбца второй строки
nums2[1][0] = 44;
System.out.println(nums2[1][0]);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Объявление трехмерного массива могло бы выглядеть так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int[][][] nums3 = new int[2][3][4];</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_массив_массивов">Массив массивов</h3>
<div class="paragraph">
<p>Многомерные массивы могут быть также представлены как "зубчатые массивы". В вышеприведенном примере двухмерный массив имел 3 строчки и три столбца, поэтому у нас получалась ровная таблица. Но мы можем каждому элементу в двухмерном массиве присвоить отдельный массив с различным количеством элементов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int[][] nums = new int[3][];
nums[0] = new int[2];
nums[1] = new int[3];
nums[2] = new int[5];
...</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_работа_с_массивами">Работа с массивами</h3>
<div class="paragraph">
<p>Важнейшее свойство, которым обладают массивы, является свойство <code>length</code>, возвращающее длину массива, то есть количество его элементов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int length = nums.length;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Нередко бывает неизвестная последний индекс, и чтобы получить последний элемент массива, мы можем использовать это свойство:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int last = nums[nums.length - 1];</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_класс_arrays">Класс <code>Arrays</code></h3>
<div class="paragraph">
<p>Класс <code>java.util.Arrays</code> предназначен для работы с массивами. Он содержит удобные методы для работы с целыми массивами:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String toString(T[])</code> − позволяет получить все элементы в виде одной строки</p>
</li>
<li>
<p><code>T[] copyOf(T[], int)</code> − предназначен для копирования массива</p>
</li>
<li>
<p><code>T[] copyOfRange(T[], int, int)</code> − копирует часть массива</p>
</li>
<li>
<p><code>void sort(T[])</code> — сортирует массив методом <code>quick sort</code></p>
</li>
<li>
<p><code>void sort(T[], int, int)</code> — сортирует массив методом <code>quick sort</code></p>
</li>
<li>
<p><code>int binarySearch(T[], T)</code> − ищет элемент методом бинарного поиска</p>
</li>
<li>
<p><code>int binarySearch(T[], int, int, T)</code> − ищет элемент методом бинарного поиска</p>
</li>
<li>
<p><code>void fill(T[], T)</code> − заполняет массив переданным значением (удобно использовать, если нам необходимо значение по умолчанию для массива)</p>
</li>
<li>
<p><code>void fill(T[], int, int, T)</code> − заполняет массив переданным значением (удобно использовать, если нам необходимо значение по умолчанию для массива)</p>
</li>
<li>
<p><code>boolean equals(T[], T[])</code> − проверяет на идентичность массивы</p>
</li>
<li>
<p><code>boolean equals(T[], int, int, T[], int, int)</code> − проверяет на идентичность массивы</p>
</li>
<li>
<p><code>int compare(T[], T[])</code> − сравнивает массивы</p>
</li>
<li>
<p><code>int compare(T[], int, int, T[], int, int)</code> − сравнивает массивы</p>
</li>
<li>
<p><code>boolean deepEquals(Object[], Object[])</code> − проверяет на идентичность массивы массивов</p>
</li>
<li>
<p><code>List&lt;T&gt; asList(T&#8230;&#8203;)</code> − возвращает массив как коллекцию</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_строки">Строки</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Строка представляет собой последовательность символов. Для работы со строками в Java определен класс <code>String</code>, который предоставляет ряд методов для манипуляции строками. Физически объект <code>String</code> представляет собой ссылку на область в памяти, в которой размещены символы.</p>
</div>
<div class="paragraph">
<p>Для создания новой строки мы можем использовать один из конструкторов класса <code>String</code>, либо напрямую присвоить строку в двойных кавычках:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    String str1 = "Java";
    String str2 = new String(); // пустая строка
    String str3 = new String(new char[] {'h', 'e', 'l', 'l', 'o'});
    String str4 = new String(new char[] {'w', 'e', 'l', 'c', 'o', 'm', 'e'}, 3, 4); // 3 -начальный индекс, 4 -количество символов

    System.out.println(str1); // Java
    System.out.println(str2); //
    System.out.println(str3); // hello
    System.out.println(str4); // come
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>При работе со строками важно понимать, что объект <code>String</code> является неизменяемым (<strong>immutable</strong>). То есть при любых операциях над строкой, которые изменяют эту строку, фактически будет создаваться новая строка.</p>
</div>
<div class="sect2">
<h3 id="_конкатенация_строк">Конкатенация строк</h3>
<div class="paragraph">
<p>Для соединения строк можно использовать операцию сложения <code>+</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str1 = "Java";
String str2 = "Hello";
String str3 = str2 + " " + str1;

System.out.println(str3); // Hello Java</code></pre>
</div>
</div>
<div class="paragraph">
<p>При этом если в операции сложения строк используется не строковый объект, например, число, то этот объект преобразуется к строке:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str3 = "Год " + 2015;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Фактически же при сложении строк с не строковыми объектами будет вызываться метод <code>valueOf()</code> класса <code>String</code>. Данный метод имеет множество перегрузок и преобразует практически все типы данных к строке. Для преобразования объектов различных классов метод <code>valueOf()</code> вызывает метод <code>toString()</code> этих классов.</p>
</div>
</div>
<div class="sect2">
<h3 id="_основные_методы_класса_string">Основные методы класса String</h3>
<div class="sect3">
<h4 id="_length"><code>length()</code></h4>
<div class="paragraph">
<p>Поскольку строка рассматривается как набор символов, то мы можем применить метод <code>length()</code> для нахождения длины строки или длины набора символов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str1 = "Java";
System.out.println(str1.length()); // 4</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tochararray"><code>toCharArray()</code></h4>
<div class="paragraph">
<p>С помощью метода <code>toCharArray()</code> можно обратно преобразовать строку в массив символов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str1 = new String(new char[] {'h', 'e', 'l', 'l', 'o'});
char[] helloArray = str1.toCharArray();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Строка может быть пустой. Для этого ей можно присвоить пустые кавычки или удалить из строки все символы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String s = ""; // строка не указывает на объект
if (s.length() == 0) {
    System.out.println("String is empty");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом случае длина строки, возвращаемая методом <code>length()</code>, равна <code>0</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_isempty"><code>isEmpty()</code></h4>
<div class="paragraph">
<p>Класс <code>String</code> имеет специальный метод, который позволяет проверить строку на пустоту - <code>isEmpty()</code>. Если строка пуста, он возвращает <code>true</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String s = ""; // строка не указывает на объект
if (s.length() == 0) {
    System.out.println("String is empty");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Переменная <code>String</code> может не указывать на какой-либо объект и иметь значение <code>null</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String s = null; // строка не указывает на объект
if (s == null) {
    System.out.println("String is null");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Значение <code>null</code> не эквивалентно пустой строке. Например, в следующем случае мы столкнемся с ошибкой выполнения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String s = null; // строка не указывает на объект
if (s.length() == 0) { // NullPointerException
    System.out.println("String is empty");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так как переменная не указывает ни на какой объект <code>String</code>, то соответственно мы не можем обращаться к методам объекта <code>String</code>. Чтобы избежать подобных ошибок, можно предварительно проверять строку на <code>null</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String s = null; // строка не указывает на объект
if (s != null &amp;&amp; s.length() == 0) {
    System.out.println("String is empty");
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_concat"><code>concat()</code></h4>
<div class="paragraph">
<p>Для объединения строк используют метод <code>concat()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str1 = "Java";
String str2 = "Hello";
str2 = str2.concat(str1); // HelloJava</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>concat()</code> принимает строку, с которой надо объединить вызывающую строку, и возвращает соединенную строку.</p>
</div>
</div>
<div class="sect3">
<h4 id="_join"><code>join()</code></h4>
<div class="paragraph">
<p>Для объединения строк используют метод <code>join()</code>, который позволяет объединить строки с учетом разделителя. Например, выше две строки сливались в одно слово <code>HelloJava</code>, но в идеале мы бы хотели, чтобы две подстроки были разделены пробелом. И для этого используем метод <code>join()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str1 = "Java";
String str2 = "Hello";
String str3 = String.join(" ", str2, str1); // Hello Java</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>join()</code> является статическим. Первым параметром идет разделитель, которым будут разделяться подстроки в общей строке, а все последующие параметры передают через запятую произвольный набор объединяемых подстрок - в данном случае две строки, хотя их может быть и больше.</p>
</div>
</div>
<div class="sect3">
<h4 id="_charat"><code>charAt()</code></h4>
<div class="paragraph">
<p>Для извлечения символов по индексу в классе <code>String</code> определен метод <code>charAt()</code>. Он принимает индекс, по которому надо получить символов, и возвращает извлеченный символ:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str = "Java";
char c = str.charAt(2);
System.out.println(c); // v</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как и в массивах индексация начинается с нуля.</p>
</div>
</div>
<div class="sect3">
<h4 id="_getchars"><code>getChars()</code></h4>
<div class="paragraph">
<p>Для извлечения группы символов или подстроку, то можно использовать метод <code>getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</code>. Он принимает следующие параметры:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>srcBegin</code> индекс в строке, с которого начинается извлечение символов</p>
</li>
<li>
<p><code>srcEnd</code> индекс в строке, до которого идет извлечение символов</p>
</li>
<li>
<p><code>dst</code> массив символов, в который будут извлекаться символы</p>
</li>
<li>
<p><code>dstBegin</code> индекс в массиве <code>dst</code>, с которого надо добавлять извлеченные из строки символы</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str = "Hello world!";
int start = 6;
int end = 11;
char[] dst=new char[end - start];
str.getChars(start, end, dst, 0);
System.out.println(dst); // world</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_equals_и_equalsignorecase"><code>equals()</code> и <code>equalsIgnoreCase()</code></h4>
<div class="paragraph">
<p>Для сравнения строк используются методы <code>equals()</code> (с учетом регистра) и <code>equalsIgnoreCase()</code> (без учета регистра). Оба метода в качестве параметра принимают строку, с которой надо сравнить:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str1 = "Hello";
String str2 = "hello";

System.out.println(str1.equals(str2)); // false
System.out.println(str1.equalsIgnoreCase(str2)); // true</code></pre>
</div>
</div>
<div class="paragraph">
<p>В отличие от сравнения числовых и других данных примитивных типов для строк не применяется знак равенства <code>==.</code> Вместо него надо использовать метод <code>equals()</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_regionmatches"><code>regionMatches()</code></h4>
<div class="paragraph">
<p>Еще один специальный метод <code>regionMatches()</code> сравнивает отдельные подстроки в рамках двух строк. Он имеет следующие формы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">boolean regionMatches(int toffset, String other, int oofset, int len)
boolean regionMatches(boolean ignoreCase, int toffset, String other, int oofset, int len)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод принимает следующие параметры:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ignoreCase</code> надо ли игнорировать регистр символов при сравнении. Если значение <code>true</code>, регистр игнорируется</p>
</li>
<li>
<p><code>toffset</code> начальный индекс в вызывающей строке, с которого начнется сравнение</p>
</li>
<li>
<p><code>other</code> строка, с которой сравнивается вызывающая</p>
</li>
<li>
<p><code>oofset</code> начальный индекс в сравниваемой строке, с которого начнется сравнение</p>
</li>
<li>
<p><code>len</code> количество сравниваемых символов в обеих строках</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Используем метод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str1 = "Hello world";
String str2 = "I work";
boolean result = str1.regionMatches(6, str2, 2, 3);
System.out.println(result); // true</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае метод сравнивает 3 символа с 6-го индекса первой строки (<code>"wor"</code>) и 3 символа со 2-го индекса второй строки (<code>"wor"</code>). Так как эти подстроки одинаковы, то возвращается <code>true</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_compareto_и_comparetoignorecase"><code>compareTo()</code> и <code>compareToIgnoreCase()</code></h4>
<div class="paragraph">
<p>Методы <code>compareTo()</code> и <code>compareToIgnoreCase()</code> позволяют сравнить две строки, но при этом они также позволяют узнать больше ли одна строка, чем другая или нет. Если возвращаемое значение больше <code>0</code>, то первая строка больше второй, если меньше нуля, то, наоборот, вторая больше первой. Если строки равны, то возвращается <code>0</code>.</p>
</div>
<div class="paragraph">
<p>Для определения больше или меньше одна строка, чем другая, используется лексикографический порядок. То есть, например, строка <code>"A"</code> меньше, чем строка <code>"B"</code>, так как символ <code>'A'</code> в алфавите стоит перед символом <code>'B'</code>. Если первые символы строк равны, то в расчет берутся следующие символы. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str1 = "hello";
String str2 = "world";
String str3 = "hell";

System.out.println(str1.compareTo(str2)); // -15 -&gt; str1 меньше чем strt2
System.out.println(str1.compareTo(str3)); // 1 -&gt; str1 больше чем str3</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_indexof_и_lastindexof"><code>indexOf()</code> и <code>lastIndexOf()</code></h4>
<div class="paragraph">
<p>Метод <code>indexOf()</code> находит индекс первого вхождения подстроки в строку, а метод <code>lastIndexOf()</code> - индекс последнего вхождения. Если подстрока не будет найдена, то оба метода возвращают <code>-1</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str = "Hello world";
int index1 = str.indexOf('l'); // 2
int index2 = str.indexOf("wo"); // 6
int index3 = str.lastIndexOf('l'); // 9</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_startswith_и_endswith"><code>startsWith()</code> и <code>endsWith()</code></h4>
<div class="paragraph">
<p>Метод <code>startsWith()</code> позволяют определить начинается ли строка с определенной подстроки, а метод <code>endsWith()</code> позволяет определить заканчивается строка на определенную подстроку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str = "myfile.exe";
boolean start = str.startsWith("my"); // true
boolean end = str.endsWith("exe"); // true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_replace"><code>replace()</code></h4>
<div class="paragraph">
<p>Метод <code>replace()</code> позволяет заменить в строке одну последовательность символов на другую:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str = "Hello world";
String replStr1 = str.replace('l', 'd'); // Heddo world
String replStr2 = str.replace("Hello", "Bye"); // Bye world</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_trim"><code>trim()</code></h4>
<div class="paragraph">
<p>Метод <code>trim()</code> позволяет удалить начальные и конечные пробелы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str = "  hello world  ";
str = str.trim(); // "hello world"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_substring"><code>substring()</code></h4>
<div class="paragraph">
<p>Метод <code>substring()</code> возвращает подстроку, начиная с определенного индекса до конца или до определенного индекса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str = "Hello world";
String substr1 = str.substring(6); // "world"
String substr2 = str.substring(3,5); // "lo"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tolowercase_и_touppercase"><code>toLowerCase()</code> и <code>toUpperCase()</code></h4>
<div class="paragraph">
<p>Метод <code>toLowerCase()</code> переводит все символы строки в нижний регистр, а метод <code>toUpperCase()</code> - в верхний</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str = "Hello World";
System.out.println(str.toLowerCase()); // hello world
System.out.println(str.toUpperCase()); // HELLO WORLD</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_split"><code>split()</code></h4>
<div class="paragraph">
<p>Метод <code>split()</code> позволяет разбить строку на подстроки по определенному разделителю. Разделитель - какой-нибудь символ или набор символов передается в качестве параметра в метод. Например, разобьем текст на отдельные слова:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String text = "FIFA will never regret it";
String[] words = text.split(" ");
for (String word : words) {
    System.out.println(word);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае строка будет разделяться по пробелу. Консольный вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-output" data-lang="output">FIFA
will
never
regret
it</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_регулярные_выражения">Регулярные выражения</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Регулярные выражения представляют мощный инструмент для обработки строк. Регулярные выражения позволяют задать шаблон, которому должна соответствовать строка или подстрока.</p>
</div>
<div class="paragraph">
<p>Большая часть функциональности по работе с регулярными выражениями в <strong>Java</strong> сосредоточена в пакете <code>java.util.regex</code>.</p>
</div>
<div class="paragraph">
<p>Само регулярное выражение представляет шаблон для поиска совпадений в строке. Для задания подобного шаблона и поиска подстрок в строке, которые удовлетворяют данному шаблону, в <strong>Java</strong> определены классы <code>Pattern</code> и <code>Matcher</code>.</p>
</div>
<div class="sect2">
<h3 id="_pattern"><code>Pattern</code></h3>
<div class="sect3">
<h4 id="_matches"><code>matches()</code></h4>
<div class="paragraph">
<p>Для простого поиска соответствий в классе <code>Pattern</code> определен статический метод <code>matches(String pattern, CharSequence input)</code>. Данный метод возвращает <code>true</code>, если последовательность символов <code>input</code> полностью соответствует шаблону строки <code>pattern</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.regex.Pattern;

public class StringsApp {
    public static void main(String[] args) {
        String input = "Hello";
        boolean found = Pattern.matches("Hello", input);
        if(found) {
            System.out.println("Найдено");
        } else {
            System.out.println("Не найдено");
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_split_2"><code>split()</code></h4>
<div class="paragraph">
<p>С помощью метода <code>split()</code> класса <code>Pattern</code> можно разделить строку на массив подстрок по определенному разделителю. Например, мы хотим выделить из строки отдельные слова:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.regex.Pattern;

public class StringsApp {
    public static void main(String[] args) {
        String input = "Hello Java! Hello JavaScript! JavaSE.";
        Pattern pattern = Pattern.compile("[ ,.!?]");
        String[] words = pattern.split(input);
        for (String word : words) {
            System.out.println(word);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>И консоль выведет набор слов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-out" data-lang="out">Hello
Java

Hello
JavaScript

JavaSE</code></pre>
</div>
</div>
<div class="paragraph">
<p>При этом все символы-разделители удаляются. Однако, данный способ разбивки не идеален: у нас остаются некоторые пробелы, которые расцениваются как лексемы, а не как разделители. Для более точной и изощренной разбивки нам следует применять элементы регулярных выражений. Так, заменим шаблон на следующий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Pattern pattern = Pattern.compile("\\s*(\\s|,|!|\\.)\\s*");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь у нас останутся только слова:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-out" data-lang="out">Hello
Java
Hello
JavaScript
JavaSE
8</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_matcher"><code>Matcher</code></h3>
<div class="paragraph">
<p>Но, как правило, для поиска соответствий применяется другой способ - использование класса <code>Matcher</code>.</p>
</div>
<div class="paragraph">
<p>Используем класс <code>Matcher</code>. Для этого вначале надо создать объект <code>Pattern</code> с помощью статического метода <code>compile()</code>, который позволяет установить шаблон:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Pattern pattern = Pattern.compile("Hello");</code></pre>
</div>
</div>
<div class="paragraph">
<p>В качестве шаблона выступает строка <code>"Hello"</code>. Метод <code>compile()</code> возвращает объект <code>Pattern</code>, который мы затем можем использовать в программе.</p>
</div>
<div class="paragraph">
<p>В классе <code>Pattern</code> также определен метод <code>matcher()</code>, который в качестве параметра принимает строку, где надо проводить поиск, и возвращает объект <code>Matcher</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String input = "Hello world! Hello Java!";
Pattern pattern = Pattern.compile("hello");
Matcher matcher = pattern.matcher(input);</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_matches_2"><code>matches()</code></h4>
<div class="paragraph">
<p>Затем у объекта <code>Matcher</code> вызывается метод <code>matches()</code> для поиска соответствий шаблону в тексте:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class StringsApp {
    public static void main(String[] args) {
        String input = "Hello";
        Pattern pattern = Pattern.compile("Hello");
        Matcher matcher = pattern.matcher(input);
        boolean found = matcher.matches();
        if (found) {
            System.out.println("Найдено");
        } else {
            System.out.println("Не найдено");
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_find_и_group"><code>find()</code> и <code>group()</code></h4>
<div class="paragraph">
<p>Рассмотрим более функциональный пример с нахождением не полного соответствия, а отдельных совпадений в строке:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class StringsApp {
    public static void main(String[] args) {
        String input = "Hello Java! Hello JavaScript! JavaSE.";
        Pattern pattern = Pattern.compile("Java(\\w*)");
        Matcher matcher = pattern.matcher(input);
        while (matcher.find()) {
            System.out.println(matcher.group());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Допустим, мы хотим найти в строке все вхождения слова <code>Java</code>. В исходной строке это три слова: <code>"Java"</code>, <code>"JavaScript"</code> и <code>"JavaSE"</code>. Для этого применим шаблон <code>"Java(\\w*)"</code>. Данный шаблон использует синтаксис регулярных выражений. Слово <code>"Java"</code> в начале говорит о том, что все совпадения в строке должны начинаться на <code>Java</code>. Выражение <code>(\\w*)</code> означает, что после <code>"Java"</code> в совпадении может находиться любое количество алфавитно-цифровых символов. Выражение <code>\w</code> означает алфавитно-цифровой символ, а звездочка после выражения указывает на неопределенное их количество - их может быть один, два, три или вообще не быть. И чтобы java не рассматривала <code>\w</code> как эскейп-последовательность, как <code>\n</code>, то выражение экранируется еще одним слешем.</p>
</div>
<div class="paragraph">
<p>Далее применяется метод <code>find()</code> класса <code>Matcher</code>, который позволяет переходить к следующему совпадению в строке. То есть первый вызов этого метода найдет первое совпадение в строке, второй вызов найдет второе совпадение и т.д. То есть с помощью цикла <code>while(matcher.find())</code> мы можем пройтись по всем совпадениям. Каждое совпадение мы можем получить с помощью метода <code>matcher.group()</code>. В итоге программа выдаст следующий результат:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-out" data-lang="out">Java
JavaScript
JavaSE</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_replaceall"><code>replaceAll()</code></h4>
<div class="paragraph">
<p>Можно сделать замену всех совпадений с помощью метода <code>replaceAll()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String input = "Hello Java! Hello JavaScript! JavaSE.";
Pattern pattern = Pattern.compile("Java(\\w*)");
Matcher matcher = pattern.matcher(input);
String newStr = matcher.replaceAll("HTML");
System.out.println(newStr); // Hello HTML! Hello HTML! HTML.</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_string"><code>String</code></h3>
<div class="paragraph">
<p>Некоторые методы класса <code>String</code> принимают регулярные выражения и используют их для выполнения операций над строками.</p>
</div>
<div class="sect3">
<h4 id="_split_3"><code>split()</code></h4>
<div class="paragraph">
<p>Для разделения строки на подстроки применяется метод <code>split()</code>. В качестве параметра он может принимать регулярное выражение, которое представляет критерий разделения строки.</p>
</div>
<div class="paragraph">
<p>Например, разделим предложение на слова:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String text = "FIFA will never regret it";
String[] words = text.split("\\s*(\\s|,|!|\\.)\\s*");
for (String word : words) {
    System.out.println(word);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для разделения применяется регулярное выражение <code>"\\s*(\\s|,|!|\\.)\\s*"</code>. Подвыражние <code>"\\s"</code> по сути представляет пробел. Звездочка указывает, что символ может присутствовать от 0 до бесконечного количества раз. То есть добавляем звездочку и мы получаем неопределенное количество идущих подряд пробелов - <code>"\\s*"</code> (то есть неважно, сколько пробелов между словами). Причем пробелы может вообще не быть. В скобках указывает группа выражений, которая может идти после неопределенного количества пробелов. Группа позволяет нам определить набо значений через вертикальную черту, и подстрока должна соответствовать одному из этих значений. То есть в группе <code>"\\s|,|!|\\."</code> подстрока может соответствовать пробелу, запятой, восклицательному знаку или точке. Причем поскольку точка представляет специальную последовательность, то, чтобы указать, что мы имеем в виду имеено знак точки, а не специальную последовательность, перед точкой ставим слеши.</p>
</div>
</div>
<div class="sect3">
<h4 id="_matches_3"><code>matches()</code></h4>
<div class="paragraph">
<p>Еще один метод класса <code>String</code> - <code>matches()</code> принимает регулярное выражение и возвращает <code>true</code>, если строка соответствует этому выражению. Иначе возвращает <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Например, проверим, соответствует ли строка номеру телефона:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String input = "+12343454556";
boolean result = input.matches("(\\+*)\\d{11}");
if (result == true) {
    System.out.println("It is a phone number");
} else {
    System.out.println("It is not a phone number!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае в регулярном выражение сначала определяется группа <code>"(\\+*)"</code>. То есть вначале может идти знак плюса, но также он может отсутствовать. Далее смотрим, соответствуют ли последующие 11 символов цифрам. Выражение <code>"\\d"</code> представляет цифровой символ, а число в фигурных скобках - <code>{11}</code> - сколько раз данный тип символов должен повторяться. То есть мы ищем строку, где вначале может идти знак плюс (или он может отсутствовать), а потом идет 11 цифровых символов.</p>
</div>
</div>
<div class="sect3">
<h4 id="_replaceall_2"><code>replaceAll()</code></h4>
<div class="paragraph">
<p>Также надо отметить, что в классе <code>String</code> также имеется метод <code>replaceAll()</code> с заменой всех выражений, удовлетворяющих регулярному выражению:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String input = "Hello Java! Hello JavaScript! JavaSE.";
String myStr =input.replaceAll("Java(\\w*)", "HTML");
System.out.println(myStr); // Hello HTML! Hello HTML! HTML.</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-06-03 03:53:52 UTC
</div>
</div>
</body>
</html>