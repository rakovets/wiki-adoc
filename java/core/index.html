<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<meta name="author" content="Dmitry Rakovets">
<title>Core Java</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Core Java</h1>
<div class="details">
<span id="author" class="author">Dmitry Rakovets</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_введение_в_java">1. Введение в Java</a>
<ul class="sectlevel2">
<li><a href="#_особенности_java">1.1. Особенности Java</a></li>
<li><a href="#_установка_java">1.2. Установка Java</a></li>
</ul>
</li>
<li><a href="#_первая_программа_на_java">2. Первая программа на Java</a>
<ul class="sectlevel2">
<li><a href="#_структура_программы">2.1. Структура программы</a></li>
<li><a href="#_первая_программа">2.2. Первая программа</a></li>
</ul>
</li>
<li><a href="#_java_language">3. Java Language</a>
<ul class="sectlevel2">
<li><a href="#_типы_данных_и_переменные">3.1. Типы данных и переменные</a></li>
<li><a href="#_консольный_ввод_и_вывод">3.2. Консольный ввод и вывод</a></li>
<li><a href="#_преобразование_базовых_типов_данных">3.3. Преобразование базовых типов данных</a></li>
<li><a href="#_методы">3.4. Методы</a></li>
<li><a href="#_операторы">3.5. Операторы</a></li>
<li><a href="#_условные_конструкции">3.6. Условные конструкции</a></li>
<li><a href="#_циклы">3.7. Циклы</a></li>
<li><a href="#_массивы">3.8. Массивы</a></li>
<li><a href="#_строки">3.9. Строки</a></li>
<li><a href="#_регулярные_выражения">3.10. Регулярные выражения</a></li>
</ul>
</li>
<li><a href="#_java_object_oriented_programming">4. Java Object-Oriented Programming</a>
<ul class="sectlevel2">
<li><a href="#_концепции_ооп">4.1. Концепции ООП</a></li>
<li><a href="#_классы_и_объекты">4.2. Классы и объекты</a></li>
<li><a href="#_объекты_как_параметры_методов">4.3. Объекты как параметры методов</a></li>
<li><a href="#_пакеты">4.4. Пакеты</a></li>
<li><a href="#_модификаторы_доступа">4.5. Модификаторы доступа</a></li>
<li><a href="#_инкапсуляция">4.6. Инкапсуляция</a></li>
<li><a href="#_наследование">4.7. Наследование</a></li>
<li><a href="#_иерархия_наследования_и_преобразование_типов">4.8. Иерархия наследования и преобразование типов</a></li>
<li><a href="#_перегрузка_методов">4.9. Перегрузка методов</a></li>
<li><a href="#_абстрактные_классы">4.10. Абстрактные классы</a></li>
<li><a href="#_интерфейсы">4.11. Интерфейсы</a></li>
<li><a href="#_статические_члены_и_модификатор_static">4.12. Статические члены и модификатор <code>static</code></a></li>
<li><a href="#_вложенные_классы">4.13. Вложенные классы</a></li>
</ul>
</li>
<li><a href="#_java_misc">5. Java Misc</a>
<ul class="sectlevel2">
<li><a href="#_stringbuffer_и_stringbuilder">5.1. <code>StringBuffer</code> и <code>StringBuilder</code></a></li>
<li><a href="#_форматирование_строк">5.2. Форматирование строк</a></li>
<li><a href="#_перечисления">5.3. Перечисления</a></li>
<li><a href="#_класс_object">5.4. Класс <code>Object</code></a></li>
<li><a href="#_ссылочные_типы_и_клонирование_объектов">5.5. Ссылочные типы и клонирование объектов</a></li>
<li><a href="#_wrapper_classes">5.6. Wrapper Classes</a></li>
<li><a href="#_введение_в_лямбда_выражения">5.7. Введение в лямбда-выражения</a></li>
<li><a href="#_лямбды_как_параметры_и_результаты_методов">5.8. Лямбды как параметры и результаты методов</a></li>
<li><a href="#_аннотации">5.9. Аннотации</a></li>
<li><a href="#_reflection">5.10. Reflection</a></li>
<li><a href="#_properties">5.11. Properties</a></li>
<li><a href="#_javadoc">5.12. Javadoc</a></li>
<li><a href="#_java_nio">5.13. Java NIO</a></li>
<li><a href="#_java_memory_management">5.14. Java Memory Management</a></li>
<li><a href="#_модульность_since_java_9">5.15. Модульность (@since Java 9)</a></li>
</ul>
</li>
<li><a href="#_обработка_исключений">6. Обработка исключений</a>
<ul class="sectlevel2">
<li><a href="#_обработка_исключений_2">6.1. Обработка исключений</a></li>
<li><a href="#_обработка_нескольких_исключений">6.2. Обработка нескольких исключений</a></li>
<li><a href="#_оператор_throw">6.3. Оператор <code>throw</code></a></li>
<li><a href="#_оператор_throws">6.4. Оператор <code>throws</code></a></li>
<li><a href="#_классы_исключений">6.5. Классы исключений</a></li>
<li><a href="#_создание_своих_классов_исключений">6.6. Создание своих классов исключений</a></li>
</ul>
</li>
<li><a href="#_generics_jsr_14">7. Generics (JSR-14)</a>
<ul class="sectlevel2">
<li><a href="#_обобщения_generics">7.1. Обобщения (Generics)</a></li>
<li><a href="#_ограничения_обобщений">7.2. Ограничения обобщений</a></li>
<li><a href="#_наследование_и_обобщения">7.3. Наследование и обобщения</a></li>
</ul>
</li>
<li><a href="#_java_collection_framework">8. Java Collection Framework</a>
<ul class="sectlevel2">
<li><a href="#_типы_коллекций">8.1. Типы коллекций</a></li>
<li><a href="#_interface_iterator">8.2. Interface <code>Iterator</code></a></li>
<li><a href="#_interface_list">8.3. Interface <code>List</code></a></li>
<li><a href="#_interface_listiterator">8.4. Interface <code>ListIterator</code></a></li>
<li><a href="#_interface_comparable">8.5. Interface <code>Comparable</code></a></li>
<li><a href="#_interface_queue">8.6. Interface <code>Queue</code></a></li>
<li><a href="#_linkedlist">8.7. LinkedList</a></li>
<li><a href="#_interface_set">8.8. Interface <code>Set</code></a></li>
<li><a href="#_interface_sortedset">8.9. Interface <code>SortedSet</code></a></li>
<li><a href="#_interface_map">8.10. Interface <code>Map</code></a></li>
<li><a href="#_interface_sortedmap">8.11. Interface <code>SortedMap</code></a></li>
</ul>
</li>
<li><a href="#_java_functional_programming_jsr_335">9. Java Functional Programming (JSR 335)</a>
<ul class="sectlevel2">
<li><a href="#_введение_stream_api">9.1. Введение Stream API</a></li>
<li><a href="#_создание_потока_данных">9.2. Создание потока данных</a></li>
<li><a href="#_фильтрация_перебор_элементов_и_отображение">9.3. Фильтрация, перебор элементов и отображение</a></li>
<li><a href="#_sorted">9.4. <code>sorted()</code></a></li>
<li><a href="#_получение_подпотока_и_объединение_потоков">9.5. Получение подпотока и объединение потоков</a></li>
<li><a href="#_skip_и_limit">9.6. <code>skip()</code> и <code>limit()</code></a></li>
<li><a href="#_операции_сведения">9.7. Операции сведения</a></li>
<li><a href="#_reduce">9.8. <code>reduce()</code></a></li>
<li><a href="#_класс_collectors">9.9. Класс <code>Collectors</code></a></li>
<li><a href="#_параллельные_операции_над_массивами">9.10. Параллельные операции над массивами</a></li>
</ul>
</li>
<li><a href="#_date_and_time_api">10. Date and Time API</a>
<ul class="sectlevel2">
<li><a href="#_дата_и_время_since_version_8">10.1. Дата и время (since version 8)</a></li>
<li><a href="#_класс_localdate">10.2. Класс <code>LocalDate</code></a></li>
<li><a href="#_класс_localtime">10.3. Класс <code>LocalTime</code></a></li>
<li><a href="#_класс_localdatetime">10.4. Класс <code>LocalDateTime</code></a></li>
<li><a href="#_класс_instant">10.5. Класс <code>Instant</code></a></li>
<li><a href="#_класс_zoneddatetime">10.6. Класс <code>ZonedDateTime</code></a></li>
<li><a href="#_класс_period">10.7. Класс <code>Period</code></a></li>
<li><a href="#_класс_duration">10.8. Класс <code>Duration</code></a></li>
<li><a href="#_класс_datetimeformatter">10.9. Класс <code>DateTimeFormatter</code></a></li>
</ul>
</li>
<li><a href="#_java_inputoutput">11. Java Input/Output</a>
<ul class="sectlevel2">
<li><a href="#_java_io">11.1. Java IO</a></li>
<li><a href="#_интерфейс_closeable">11.2. Интерфейс <code>Closeable</code></a></li>
<li><a href="#_класс_file">11.3. Класс <code>File</code></a></li>
<li><a href="#_классы_fileoutputstream_и_fileinputstream">11.4. Классы <code>FileOutputStream</code> и <code>FileInputStream</code></a></li>
<li><a href="#_классы_bytearrayinputstream_и_bytearrayoutputstream">11.5. Классы <code>ByteArrayInputStream</code> и <code>ByteArrayOutputStream</code></a></li>
<li><a href="#_классы_bufferedinputstream_and_bufferedoutputstream">11.6. Классы <code>BufferedInputStream</code> and <code>BufferedOutputStream</code></a></li>
<li><a href="#_классы_dataoutputstream_и_datainputstream">11.7. Классы <code>DataOutputStream</code> и <code>DataInputStream</code></a></li>
<li><a href="#_классы_printstream_и_printwriter">11.8. Классы <code>PrintStream</code> и <code>PrintWriter</code></a></li>
<li><a href="#_класс_filewriter_и_filereader">11.9. Класс <code>FileWriter</code> и <code>FileReader</code></a></li>
<li><a href="#_классы_bufferedwriter_and_bufferedreader">11.10. Классы <code>BufferedWriter</code> and <code>BufferedReader</code></a></li>
<li><a href="#_сериализация">11.11. Сериализация</a></li>
<li><a href="#_классы_zipoutputstream_и_zipinputstream">11.12. Классы <code>ZipOutputStream</code> и <code>ZipInputStream</code></a></li>
<li><a href="#_класс_console">11.13. Класс <code>Console</code></a></li>
</ul>
</li>
<li><a href="#_java_concurrency">12. Java Concurrency</a>
<ul class="sectlevel2">
<li><a href="#_многопоточное_программирование">12.1. Многопоточное программирование</a></li>
<li><a href="#_создание_и_выполнение_потоков">12.2. Создание и выполнение потоков</a></li>
<li><a href="#_завершение_и_прерывание_потока">12.3. Завершение и прерывание потока</a></li>
<li><a href="#_оператор_synchronized">12.4. Оператор <code>synchronized</code></a></li>
<li><a href="#_методы_wait_и_notify">12.5. Методы <code>wait()</code> и <code>notify()</code></a></li>
</ul>
</li>
<li><a href="#_java_concurrency_utilities_jsr_166">13. Java Concurrency Utilities (JSR-166)</a>
<ul class="sectlevel2">
<li><a href="#_семафоры">13.1. Семафоры</a></li>
<li><a href="#_класс_exchanger">13.2. Класс <code>Exchanger</code></a></li>
<li><a href="#_класс_phaser">13.3. Класс <code>Phaser</code></a></li>
<li><a href="#_блокировки_reentrantlock">13.4. Блокировки. <code>ReentrantLock</code></a></li>
<li><a href="#_interface_condition">13.5. Interface <code>Condition</code></a></li>
</ul>
</li>
<li><a href="#_java_network">14. Java Network</a>
<ul class="sectlevel2">
<li><a href="#_cтандартизированный_http_client_api_since_11">14.1. Cтандартизированный HTTP-client API (@since 11)</a></li>
<li><a href="#_inetaddress">14.2. InetAddress</a></li>
<li><a href="#_tcp_networking">14.3. TCP networking</a></li>
<li><a href="#_udp_networking">14.4. UDP networking</a></li>
</ul>
</li>
<li><a href="#_javadoc_2">15. Javadoc</a>
<ul class="sectlevel2">
<li><a href="#_введение_2">15.1. Введение</a></li>
<li><a href="#_тэги_javadoc">15.2. Тэги <strong>Javadoc</strong></a></li>
<li><a href="#_изучение_вывода_javadoc">15.3. Изучение вывода <strong>Javadoc</strong></a></li>
<li><a href="#_редактирование_тэгов_javadoc">15.4. Редактирование тэгов <strong>Javadoc</strong></a></li>
</ul>
</li>
<li><a href="#_localization_and_internationalization">16. Localization and Internationalization</a>
<ul class="sectlevel2">
<li><a href="#_региональные_стандарты_locale">16.1. Региональные стандарты Locale</a></li>
<li><a href="#_форматирование_числовых_значений_numberformat">16.2. Форматирование числовых значений NumberFormat</a></li>
<li><a href="#_денежные_суммы">16.3. Денежные суммы</a></li>
<li><a href="#_форматирование_даты_и_времени_dateformat">16.4. Форматирование даты и времени DateFormat</a></li>
<li><a href="#_пакеты_ресурсов_resources">16.5. Пакеты ресурсов resources</a></li>
<li><a href="#_определение_файла_ресурсов_resourcebundle">16.6. Определение файла ресурсов <code>ResourceBundle</code></a></li>
<li><a href="#_файлы_свойств_properties">16.7. Файлы свойств <code>properties</code></a></li>
<li><a href="#_классы_реализующие_пакеты_ресурсов">16.8. Классы, реализующие пакеты ресурсов</a></li>
<li><a href="#_форматирование_сообщений_messageformat">16.9. Форматирование сообщений <code>MessageFormat</code></a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Wiki for course "Core Java".</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_введение_в_java">1. Введение в Java</h2>
<div class="sectionbody">
<div class="paragraph">
<p>На сегодняшний момент язык <strong>Java</strong> является одним из самых распространенных и популярных языков программирования.</p>
</div>
<div class="paragraph">
<p>Первая версия языка появилась еще в 1996 году в недрах компании <strong>Sun Microsystems</strong>, впоследствии поглощенной компанией <strong>Oracle</strong>. <strong>Java</strong> задумывался как универсальный язык программирования, который можно применять для различного рода задач. И к настоящему времени язык <strong>Java</strong> проделал большой путь, было издано множество различных версий.</p>
</div>
<div class="paragraph">
<p>Текущей версией является <strong>Java 14</strong>, которая вышла 15 сентября 2020 года. А <strong>Java</strong> превратилась из просто универсального языка в целую платформу и экосистему, которая объединяет различные технологии, используемые в целого ряда задач: от создания десктопных приложений до написания крупных веб-порталов и сервисов. Кроме того, язык <strong>Java</strong> активно применяется для создания программного обеспечения для целого ряда устройств: обычных ПК, планшетов, смартфонов и мобильных телефонов и даже бытовой техники. Достаточно вспомнить популярность мобильной ОС <strong>Android</strong>, большинство программ для которой пишутся именно на <strong>Java</strong>.</p>
</div>
<div class="sect2">
<h3 id="_особенности_java">1.1. Особенности Java</h3>
<div class="paragraph">
<p>Ключевой особенностью языка <strong>Java</strong> является то, что его код сначала транслируется в специальный <strong>байт-код</strong>, независимый от платформы. А затем этот <strong>байт-код</strong> выполняется виртуальной машиной <strong>JVM</strong> (<strong>Java Virtual Machine</strong>). В этом плане <strong>Java</strong> отличается от стандартных интерпретируемых языков как <strong>PHP</strong> или <strong>Perl</strong>, код которых сразу же выполняется интерпретатором. В то же время <strong>Java</strong> не является и чисто компилируемым языком, как <strong>С</strong> или <strong>С++</strong>.</p>
</div>
<div class="paragraph">
<p>Подобная архитектура обеспечивает кроссплатформенность и аппаратную переносимость программ на <strong>Java</strong>, благодаря чему подобные программы без перекомпиляции могут выполняться на различных платформах - <strong>Linux</strong>, <strong>Mac OS</strong>, <strong>Windows</strong> и т.д. Для каждой из платформ может быть своя реализация виртуальной машины <strong>JVM</strong>, но каждая из них может выполнять один и тот же код.</p>
</div>
<div class="paragraph">
<p><strong>Java</strong> является языком с <strong>Си-подобным</strong> синтаксисом и близок в этом отношении к <strong>C/C++</strong> и <strong>C#</strong>. Поэтому, если вы знакомы с одним из этих языков, то овладеть <strong>Java</strong> будет легче.</p>
</div>
<div class="paragraph">
<p>Еще одной ключевой особенностью <strong>Java</strong> является то, что она поддерживает автоматическую сборку мусора. А это значит, что вам не надо освобождать вручную память от ранее использовавшихся объектов, как в <strong>С++</strong>, так как сборщик мусора это сделает автоматически за вас.</p>
</div>
<div class="paragraph">
<p><strong>Java</strong> является <strong>объектно-ориентированным языком</strong>. Он поддерживает полиморфизм, наследование, статическую типизацию. Объектно-ориентированный подход позволяет решить задачи по построению крупных, но в тоже время гибких, масштабируемых и расширяемых приложений.</p>
</div>
</div>
<div class="sect2">
<h3 id="_установка_java">1.2. Установка Java</h3>
<div class="paragraph">
<p>Для работы программ на языке <strong>Java</strong> на целевой машине должна быть установлена <strong>JRE</strong> (<strong>Java Runtime Environment</strong>). <strong>JRE</strong> представляет минимальную реализацию виртуальной машины, а также библиотеку классов. Поэтому, если мы хотим запускать программы, то нам надо установить <strong>JRE</strong>. Для каждой конкретной платформы имеется своя версия <strong>JRE</strong>.</p>
</div>
<div class="paragraph">
<p>Если необходимо нетолько запускать программы, но и разрабатывать их, то потребуется специальный комплект для разработки <strong>JDK</strong> (<strong>Java Development Kit</strong>). <strong>JDK</strong> уже содержит <strong>JRE</strong>, а также включает ряд дополнительных программ и утилит, в частности компилятор <strong>Java</strong>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/img/java/core/java-platform.png" alt="Java Platform">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_первая_программа_на_java">2. Первая программа на Java</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_структура_программы">2.1. Структура программы</h3>
<div class="paragraph">
<p>Для того, чтобы создать простое приложение на Java необходим текстовый редактор для набора кода программы, например:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Vi</code>/<code>Vim</code>/<code>Nano</code> (for <code>UNIX-like OS</code>)</p>
</li>
<li>
<p><code>Notepad</code> (for <code>Windows</code>)</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Microsoft Word - это не текстовый редактор, а текстовый процессор</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Рассмотрим пример простой программы на <code>Java</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.Console; // подключение используемых в программе внешних пакетов

public class Program { // объявление нового класса
    public static void main (String args[]) { // объявление нового метода
        String name; // переменная для имени
        Console con = System.console(); // получаем объект консоли для считывания с консоли
        name = con.readLine("Введите свое имя: "); // считываем введенное значение
        System.out.println("Добро пожаловать, " + name); // ввыводим данную запись поток вывода
    } // конец объявления нового метода
} // конец объявления нового класса</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_область_подключения_внешних_пакетов">2.1.1. Область подключения внешних пакетов</h4>
<div class="paragraph">
<p>В начале файла идет секция с подключенными внешними пакетами с помощью директивы <code>import</code>, после которой идут названия подключаемых пакетов и классов. Пакеты представляют собой организацию классов и интерфейсов в общие группы или блоки.</p>
</div>
</div>
<div class="sect3">
<h4 id="_область_написания_кода">2.1.2. Область написания кода</h4>
<div class="paragraph">
<p>И так как язык <code>Java</code> имеет <code>С</code>-подобный синтаксис:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Каждая строка завершается точкой с запятой, а каждый блок кода помещается в фигурные скобки.</p>
</li>
<li>
<p>Далее идет определение класса программа. Классы объявляются следующим способом:</p>
<div class="ulist">
<ul>
<li>
<p>идет модификатор доступа <code>public</code>, который указывает, что данный класс будет доступен всем, то есть его можно запустить из командной строки.</p>
</li>
<li>
<p>далее идет ключевое слово <code>class</code></p>
</li>
<li>
<p>название класса</p>
</li>
<li>
<p>блок самого класса в фигурных скобках.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Классы являются теми кирпичиками, из которых состоит программа на <code>Java</code>. Особо следует остановиться на именах классов. <strong>Имена классов</strong>, а также <strong>их методов и переменных</strong>, еще <strong>называют идентификаторами</strong>. <strong>Идентификаторы</strong> представляют произвольную последовательность алфавитных и цифровых символов, а также символа подчеркивания, однако при этом:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>названия не должны начинаться с цифры</strong>.</p>
</li>
<li>
<p><strong>не должны представлять зарезервированные ключевые слова</strong>, например, такие как <code>class</code> или <code>int</code> и т.д.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Класс может содержать различные переменные и методы. В данном случае у нас объявлен один метод <code>main</code>. Как и в многих других <code>C</code>-подобных языках в программе на <code>Java</code> метод <code>main</code> является <strong>входной точкой программы</strong>, с него начинается все управление. Он обязательно должен присутствовать в программе.</p>
</div>
<div class="paragraph">
<p>Метод <code>main</code> также имеет модификатор <code>public</code>. Слово <code>static</code> указывает, что метод <code>main</code> — <strong>статический</strong>, а слово <code>void</code> — что он не возвращает никакого значения.</p>
</div>
<div class="paragraph">
<p>Далее в скобках идут параметры метода — <code>String args[]</code> — это массив <code>args</code>, который хранит значения типа <code>String</code>, то есть строки. В данном случае они пока не нужны, но в реальной программе это те строковые параметры, которые передаются при запуске программы из командной строки.</p>
</div>
<div class="paragraph">
<p>Блок метода <code>main</code> содержит код программы. Вначале объявляется переменная <code>name</code>, которая будет хранить строку, то есть объект типа <code>String</code>: <code>String name</code>. <strong>Java</strong>, как и другие <strong>С</strong>-подобные языки, является <strong>регистрозависимым</strong>, поэтому следующие два объявления целочисленных переменных <code>String name</code> и <code>String Name</code> будут обозначать две разных переменных.</p>
</div>
<div class="paragraph">
<p>Далее идет создание переменной консоли, которая позволит взаимодействовать с консолью: <code>Console con = System.console();</code>. Так как класс <code>Console</code> находится в библиотеке классов в пакете <code>java.io</code>, то в начале файла подключается этот класс директивой импорта <code>import java.io.Console</code></p>
</div>
<div class="paragraph">
<p>Затем с помощью метода <code>con.readLine</code> выводится приглашение к вводу имени и ожидается, пока пользователь не введет имя. Так как данный метод возвращает введенное пользователем значение, то его можно присвоить переменной <code>name</code>.</p>
</div>
<div class="paragraph">
<p>И в конце введенное имя выводится на экран с помощью класса <code>System</code> и метода <code>println</code>. Хотя <code>System</code>, как и <code>Scanner</code>, является классом, размещенном в одном из пакетов, но его не нужно подключать с помощью директивы импорта. Так как <code>System</code> находится в пакете <code>java.lang</code>, все классы которого автоматически подключаются в программу.</p>
</div>
<div class="paragraph">
<p>Кроме собственно кода программы здесь использованы пояснения к коду или комментарии. Для создания однострочного комментария используется двойной слеш <code>//</code>. При компиляции программы все комментарии игнорируются и служат лишь для пояснения действий программисту.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_первая_программа">2.2. Первая программа</h3>
<div class="paragraph">
<p>Процесс создания программы можно разделить на три этапа:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>написание</p>
</li>
<li>
<p>компиляция</p>
</li>
<li>
<p>запуск</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_написание">2.2.1. Написание</h4>
<div class="paragraph">
<p>Для написания используется текстовый редактор или <strong>IDE</strong> (<strong>integrated development environment</strong>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class HellToWorld {
    public static void main (String args[]) {
        System.out.println("Hell to World!");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сохранить программу в файл под названием <code>HellToWorld.java</code>, где <code>java</code> — расширение файла, так как файл, содержащий <code>public class</code> должен называться так же, как и сам класс — в нашем случае <code>HellToWorld</code>.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Следующие шаги в <code>OS Windows</code> не сработают, так как нужно <a href="https://www.java.com/ru/download/help/path.xml">добавить путь к <strong>JDK</strong> в переменную <strong>PATH</strong> в переменных среды</a></p>
</div>
</blockquote>
</div>
</div>
<div class="sect3">
<h4 id="_компиляция">2.2.2. Компиляция</h4>
<div class="paragraph">
<p>После написания нужно скомпилировать программу, т.е. преобразовать <code>Java</code>-код в <code>byte</code>-код, с которым может работать <code>JVM</code>. Откроем <code>terminal</code> в <code>Linux</code>/<code>MacOS</code> (или командную строку в <code>Windows</code>) и с ее помощью сделаем следующие шаги:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>перейти в <code>directory</code>, где лежит наш файл с программой с помощью команды <code>cd путь_к_файлу</code></p>
</li>
<li>
<p>скомпилировать программу, с помощью команды <code>javac HellToWorld.java</code></p>
</li>
<li>
<p>проверить наличие скомпилированной программы в <code>directory</code>, с помощью команды <code>dir</code> можно убедиться в наличии <code>HellToWorld.class</code> - скомпилированная программа</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_запуск">2.2.3. Запуск</h4>
<div class="paragraph">
<p>После компиляции программа запускается с помощью команды <code>java HellToWorld</code>. После запуска в <code>terminal</code> отобразится текст, который выводится в данной программею.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_java_language">3. Java Language</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_типы_данных_и_переменные">3.1. Типы данных и переменные</h3>
<div class="paragraph">
<p>Одной из основных особенностей <strong>Java</strong> является то, что данный язык является <strong>строго типизированным</strong>. А это значит, что каждая переменная и константа представляет определенный тип и данный тип строго определен. Тип данных определяет диапазон значений, которые может хранить переменная или константа.</p>
</div>
<div class="sect3">
<h4 id="_базовые_типы">3.1.1. Базовые типы</h4>
<div class="paragraph">
<p>Итак, рассмотрим систему встроенных базовых типов данных, которая используется для создания переменных в Java. А она представлена следующими типами.</p>
</div>
<div class="paragraph">
<p><code>boolean</code>: хранит значение <code>true</code> или <code>false</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">boolean isActive = false;
boolean isAlive = true;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>byte</code>: хранит целое число от <code>-128</code> до <code>127</code> и занимает <code>1 байт</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">byte a = 3;
byte b = 8;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>short</code>: хранит целое число от <code>-32768</code> до <code>32767</code> и занимает <code>2 байта</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">short a = 3;
short b = 8;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>int</code>: хранит целое число от <code>-2147483648</code> до <code>2147483647</code> и занимает <code>4 байта</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 4;
int b = 9;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>long</code>: хранит целое число от <code>-9 223 372 036 854 775 808</code> до <code>9 223 372 036 854 775 807</code> и занимает <code>8 байт</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">long a = 5;
long b = 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>double</code>: хранит число с плавающей точкой от <code>±4.9*10-324</code> до <code>±1.8*10308</code> и занимает <code>8 байт</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">double x = 8.5;
double y = 2.7;</code></pre>
</div>
</div>
<div class="paragraph">
<p>В качестве разделителя целой и дробной части в дробных литералах используется <strong>ТОЧКА</strong>.</p>
</div>
<div class="paragraph">
<p><code>float</code>: хранит число с плавающей точкой от <code>-3.4*1038</code> до <code>3.4*1038</code> и занимает <code>4 байта</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">float x = 8.5F;
float y = 2.7F;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>char</code>: хранит одиночный символ в кодировке <strong>Unicode</strong> и занимает <code>2 байта</code>, поэтому диапазон хранимых значений от <code>0</code> до <code>65536</code></p>
</div>
<div class="paragraph">
<p>При этом переменная может принимать только те значения, которые соответствуют ее типу. Если переменная предствляет целочисленный тип, то она не может хранить дробные числа.</p>
</div>
<div class="sect4">
<h5 id="_целые_числа">Целые числа</h5>
<div class="paragraph">
<p>Все целочисленные литералы, например, <code>10</code>, <code>4</code>, <code>-5</code>, воспринимаются как значения типа <code>int</code>, однако мы можем присваивать целочисленные литералы другим целочисленным типам: <code>byte</code>, <code>long</code>, <code>short</code>. В этом случае Java автоматически осуществляет соответствующие преобразования:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">byte a = 1;
short b = 2;
long c = 2121;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как правило, значения для целочисленных переменных задаются в десятичной системе счисления, однако мы можем применять и другие системы исчисления. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int num111 = 0x6F; // 16-тиричная система, число 111
int num8 = 010; // 8-ричная система, число 8
int num13 = 0b1101; // 2-ичная система, число 13</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для задания шестнадцатеричного значения после символов <code>0x</code> указывается число в шестнадцатеричном формате. Таким же образом восьмеричное значение указывается после символа <code>0</code>, а двоичное значение - после символов <code>0b</code>.</p>
</div>
<div class="paragraph">
<p>Также целые числа поддерживают разделение разрядов числа с помощью знака подчеркивания:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int x = 123_456;
int y = 234_567__789;
System.out.println(x); // 123456
System.out.println(y); // 234567789</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_числа_с_плавающей_точкой">Числа с плавающей точкой</h5>
<div class="paragraph">
<p>При присвоении переменной типа <code>float</code> дробного литерала с плавающей точкой, например, <code>3.1</code>, <code>4.5</code> и т.д., Java автоматически рассматривает этот литерал как значение типа <code>double</code>. И чтобы указать, что данное значение должно рассматриваться как <code>float</code>, нам надо использовать суффикс <code>f</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">float fl = 30.6f;
double db = 30.6;</code></pre>
</div>
</div>
<div class="paragraph">
<p>И хотя в данном случае обе переменных имеют практически одно значения, но эти значения будут по-разному рассматриваться и будут занимать разное место в памяти.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ссылочные_типы">3.1.2. Ссылочные типы</h4>
<div class="paragraph">
<p>Все остальные за исключением примитивных. Если быть точным, то любой <code>Object</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_переменные">3.1.3. Переменные</h4>
<div class="paragraph">
<p>Для хранения данных в программе предназначены переменные. Переменная представляет именнованную область памяти, которая хранит значение определенного типа. Каждая переменная имеет тип, имя и значение. Тип определяет, какую информацию может хранить переменная или диапазон допустимых значений.</p>
</div>
<div class="paragraph">
<p>Переменные объявляются следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">тип_данных имя_переменной;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например, определим переменную, которая будет называться <code>x</code> и будет иметь тип <code>int</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом выражении мы объявляем переменную <code>x</code> типа <code>int</code>. То есть <code>x</code> будет хранить некоторое число не больше <code>4 байт</code>.</p>
</div>
<div class="paragraph">
<p>В качестве имени переменной может выступать любое произвольное название, которое удовлетворяет следующим требованиям:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>имя может содержать любые алфавитно-цифровые символы, а также знак подчеркивания, при этом первый символ в имени не должен быть цифрой</p>
</li>
<li>
<p>в имени не должно быть знаков пунктуации и пробелов</p>
</li>
<li>
<p>имя не может быть ключевым словом языка Java</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Кроме того, при объявлении и последующем использовании надо учитывать, что <strong>Java - регистрозависимый язык</strong>, поэтому следующие объявления <code>int num;</code> и <code>int NUM;</code> будут представлять две разных переменных.</p>
</div>
<div class="paragraph">
<p>Объявив переменную, мы можем присвоить ей значений:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int x; // объявление переменной
x = 10; // присвоения значения
System.out.println(x); // 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Также можно привоить значение переменной при ее объявлении. Этот процесс называется инициализацией:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int x = 10; // объявление и инициализация переменной
System.out.println(x); // 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если мы не присвоим переменной значение до ее использования, то мы можем получить ошибку, например, в следующем случае:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int x;
System.out.println(x);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Через запятую можно объявить сразу несколько переменных одного типа:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int x, y;
x = 10;
y = 25;
System.out.println(x); // 10
System.out.println(y); // 25</code></pre>
</div>
</div>
<div class="paragraph">
<p>Также можно их сразу инициализировать:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int x = 8, y = 15;
System.out.println(x); // 8
System.out.println(y); // 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>Отличительной особенностью переменных является то, что мы можем в процессе работы программы изменять их значение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int x = 10;
System.out.println(x); // 10
x = 25;
System.out.println(x); // 25</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_ключевое_слово_var">Ключевое слово var</h5>
<div class="paragraph">
<p>Начиная с Java 10 в язык было добавлено ключевое слово <code>var</code>, которое также позволяет определять переменную:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">var x = 10;
System.out.println(x); // 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Слово <code>var</code> ставится вместо типа данных, а сам тип переменной выводится из того значения, которое ей присваивается. Например, переменой <code>x</code> приваивается число <code>10</code>, значит, переменная будет представлять тип <code>int</code>.</p>
</div>
<div class="paragraph">
<p>Но если переменная объявляется с помощью <code>var</code>, то мы обязательно должны инициализировать ее, то есть предоставить ей начальное значение, иначе мы получим ошибку, как, например, в следующм случае:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">var x; // ! Ошибка, переменная не инициализирована
x = 10;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_использование_суффиксов">3.1.4. Использование суффиксов</h4>
<div class="paragraph">
<p>Как правило, значения для целочисленных переменных задаются в десятичной системе счисления, однако мы можем применять и другие системы исчисления. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int num111 = 0x6F; // 16-тиричная система, число 111
int num8 = 010; // 8-ричная система, число 8
int num13 = 0b1101; // 2-ичная система, число 13</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для задания шестнадцатеричного значения после символов <code>0x</code> указывается число в шестнадцатеричном формате. Таким же образом восьмеричное значение указывается после символа <code>0</code>, а двоичное значение — после символов <code>0b</code>.</p>
</div>
<div class="paragraph">
<p>При присвоении переменной типа <code>float</code> значения с плавающей точкой Java автоматически рассматривает это значение как объкт типа <code>double</code>. И чтобы указать, что данное значение должно рассматриваться как <code>float</code>, нам надо использовать суффикс <code>f</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">float fl = 30.6f;
double db = 30.6;</code></pre>
</div>
</div>
<div class="paragraph">
<p>И хотя в данном случае обе переменных имеют практически одно значения, но эти значения будут по-разному рассматриваться и будут занимать разное место в памяти.</p>
</div>
</div>
<div class="sect3">
<h4 id="_символы_и_строки">3.1.5. Символы и строки</h4>
<div class="paragraph">
<p>В качестве значения переменная символьного типа получает одиночный символ, заключенный в ординарные кавычки: <code>char ch='e';</code>. Кроме того, переменной символьного типа также можно присвоить целочисленное значение от <code>0</code> до <code>65536</code>. В этом случае переменная опять же будет хранить символ, а целочисленное значение будет указывать на номер символа в таблице символов <code>Unicode</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">char ch=102; // символ 'f'
System.out.println(ch);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Еще одной формой задания символьных переменных является шестнадцатеричная форма: переменная получает значение в шестнадцатеричной форме, которое следует после символов <code>"\u"</code>. Например, <code>char ch='\u0066';</code> опять же будет хранить символ <code>'f'</code>.</p>
</div>
<div class="paragraph">
<p>Символьные переменные не стоит путать со строковыми, <code>'a'</code> не идентично <code>"a"</code>. Строковые переменные представляют объект <code>String</code>, который в отличие от char или int не является примитивным типов в Java:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String hello = "Hellow...";
System.out.println(hello);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_константы">3.1.6. Константы</h4>
<div class="paragraph">
<p>Кроме переменных, в Java для хранения данных можно использовать константы. В отличие от переменных константам можно присвоить значение только один раз. Константа объявляется также, как и переменная, только вначале идет ключевое слово <code>final</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">final int LIMIT = 5;
System.out.println(LIMIT); // 5
// LIMIT=57; // так мы уже не можем написать, так как LIMIT - константа</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как правило, константы имеют имена в <strong>ВЕРХНЕМ_РЕГИСТРЕ</strong>.</p>
</div>
<div class="paragraph">
<p>Константы позволяют задать такие переменные, которые не должны больше изменяться. Например, если у нас есть переменная для хранения числа <code>pi</code>, то мы можем объявить ее константой, так как ее значение постоянно.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_консольный_ввод_и_вывод">3.2. Консольный ввод и вывод</h3>
<div class="paragraph">
<p>Для получения данных, введенных пользователем, а также для вывода сообщений нам необходим ряд классов, через которые мы сможем взаимодействовать с консолью.  Для взаимодействия с консолью нам необходим класс <code>System</code>. Этот класс располагается в пакете <code>java.lang</code>, который автоматически подключается в программу, поэтому нам не надо дополнительно импортировать данный пакет и класс.</p>
</div>
<div class="sect3">
<h4 id="_консольный_вывод">3.2.1. Консольный вывод</h4>
<div class="paragraph">
<p>Для создания потока вывода в класс <code>System</code> определен объект <code>out</code>. В этом объекте определен метод <code>println</code>, который позволяет вывести на консоль некоторое значение с последующим переводом консоли на следующую строку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">System.out.println("Hello world");</code></pre>
</div>
</div>
<div class="paragraph">
<p>В метод <code>println</code> передается любое значение, как правило, строка, которое надо вывести на консоль. При необходимости можно и не переводить курсор на следующую строку. В этом случае можно использовать метод <code>System.out.print()</code>, который аналогичен <code>println</code> за тем исключением, что не осуществляет перевода на следующую строку.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">System.out.print("Hello world");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Но с помощью метода <code>System.out.print</code> также можно осуществить перевод каретки на следующую строку. Для этого надо использовать <code>escape</code>-последовательность <code>\n</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">System.out.print("Hello world \n");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если у нас есть два числа, и мы хотим вывести их значения на экран, то мы можем, например, написать так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int x = 5;
int y = 6;
System.out.println("x=" + x + "; y=" + y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Но в <strong>Java</strong> есть также функция для форматированного вывода, унаследованная от языка <strong>С</strong>: <code>System.out.printf()</code>. С ее помощью мы можем переписать предыдущий пример следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int x = 5;
int y = 6;
System.out.printf("x=%d; y=%d \n", x, y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае символы <code>%d</code> обозначают спецификатор, вместо которого подставляет один из аргументов. Спецификаторов и соответствующих им аргументов может быть множество. В данном случае у нас только два аргумента, поэтому вместо первого <code>%d</code> подставляет значение переменной <code>x</code>, а вместо второго - значение переменной <code>y</code>. Сама буква <code>d</code> означает, что данный спецификатор будет использоваться для вывода целочисленных значений типа <code>int</code>.</p>
</div>
<div class="paragraph">
<p>Кроме спецификатора <code>%d</code> мы можем использовать еще ряд спецификаторов для других типов данных:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>%x</code>: для вывода шестнадцатеричных чисел</p>
</li>
<li>
<p><code>%f</code>: для вывода чисел с плавающей точкой</p>
</li>
<li>
<p><code>%e</code>: для вывода чисел в экспоненциальной форме, например, <code>1.3e+01</code></p>
</li>
<li>
<p><code>%c</code>: для вывода одиночного символа</p>
</li>
<li>
<p><code>%s</code>: для вывода строковых значений</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String name = "Иван";
int age = 30;
float height = 1.7f;
System.out.printf("Имя: %s   Возраст: %d лет   Рост: %.2f метров \n", name, age, height);</code></pre>
</div>
</div>
<div class="paragraph">
<p>При выводе чисел с плавающей точкой мы можем указать количество знаков после запятой, для этого используем спецификатор на <code>%.2f</code>, где <code>.2</code> указывает, что после запятой будет два знака. В итоге мы получим следующий вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="output">Имя: Иван   Возраст: 30 лет   Рост: 1,70 метров</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_консольный_ввод">3.2.2. Консольный ввод</h4>
<div class="paragraph">
<p>Для получения консольного ввода в классе <code>System</code> определен объект <code>in</code>. Однако непосредственно через объект <code>System.in</code> не очень удобно работать, поэтому, как правило, используют класс <code>Scanner</code>, который, в свою очередь использует <code>System.in</code>. Например, создадим маленькую программу, которая осуществляет ввод чисел:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.Scanner;

public class FirstApp {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int[] nums = new int[5];
        for (int i = 0; i &lt; nums.length; i++) {
            nums[i] = in.nextInt();
        }

        for (int i = 0; i &lt; nums.length; i++) {
            System.out.print(nums[i]);
        }
        System.out.println();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так как класс <code>Scanner</code> находится в пакете <code>java.util</code>, то мы вначале его импортируем. Для создания самого объекта <code>Scanner</code> в его конструктор передается объект <code>System.in</code>. После этого мы можем получать вводимые значения. Например, чтобы получить введенное число, используется метод <code>in.nextInt();</code>, который возвращает введенное с клавиатуры целочисленное значение.</p>
</div>
<div class="paragraph">
<p>В данном случае в цикле вводятся все элементы массива, а с помощью другого цикла все ранее введенные элементы массива выводятся в строчку.</p>
</div>
<div class="paragraph">
<p>Класс <code>Scanner</code> имеет еще ряд методов, которые позволяют получить введенные пользователем значения:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>next()</code>: считывает введенную строку до первого пробела</p>
</li>
<li>
<p><code>nextLine()</code>: считывает всю введенную строку</p>
</li>
<li>
<p><code>nextInt()</code>: считывает введенное число <code>int</code></p>
</li>
<li>
<p><code>nextDouble()</code>: считывает введенное число <code>double</code></p>
</li>
<li>
<p><code>hasNext()</code>: проверяет, было ли введено слово</p>
</li>
<li>
<p><code>hasNextInt()</code>: проверяет, было ли введено число <code>int</code></p>
</li>
<li>
<p><code>hasNextDouble()</code>: проверяет, было ли введено <code>double</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Кроме того, класс <code>Scanner</code> имеет еще ряд методов <code>nextByte()</code>/<code>nextShort()</code>/<code>nextFloat()</code>/<code>nextBoolean()</code>, которые по аналогии с <code>nextInt()</code> считывают данные определенного типа данных.</p>
</div>
<div class="paragraph">
<p>Создадим следующую программу для ввода информации о человеке:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.Scanner;

public class FirstApp {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print("Введите имя: ");
        String name = in.nextLine();
        System.out.print("Введите возраст: ");
        int age = in.nextInt();
        System.out.println("Ваше имя: " + name + "   Ваш возраст: " + age);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например, если бы мы запускали проект в <strong>IntelliJ IDEA</strong>, то это выглядело бы так:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/img/java/core/language/console-output.png" alt="Console Output">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_проблема_с_кириллическими_символами">3.2.3. Проблема с кириллическими символами</h4>
<div class="paragraph">
<p>Нередко при вводе кириллических символов отображаются некорректные символы. В прицнипе проблема касается не только кириллических символов, но символов ряда других кодировок, отличающихся от латиницы. В этом случае надо настроить кодировку. Для этого можно пойти двумя путями.</p>
</div>
<div class="paragraph">
<p>Первый способ заключается в выборе кодировке в самой IDE. Для этого перейдем в меню <strong>File &#8594; Setting</strong> или hotkey <code>Ctrl+Alt+S</code>.</p>
</div>
<div class="paragraph">
<p>Нам откроется окно настроек проекта, где в самом низу нам надо выбрать вместо кодировки по умолчанию <code>UTF-8</code> кодировку <code>windows-1251</code>:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/img/java/core/language/problem-encoding.png" alt="Problem encoding">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_преобразование_базовых_типов_данных">3.3. Преобразование базовых типов данных</h3>
<div class="paragraph">
<p>При рассмотрении типов данных указывалось, какие значения может иметь тот или иной тип и сколько байт памяти он может занимать. И мы можем написать, например, так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">byte x = 5;
byte y = x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Но важно понимать, что это запись не эквивалентна следующей (хотя результат будет тот же):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">byte x = 5;
int y = x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>В обоих случаях создается переменная типа <code>byte</code>, которая затем приравнивается другой переменной. Однако если в первом случае это простое приравнивание, а переменная <code>y</code> просто получает значение переменной <code>x</code>, то во втором примере происходит преобразование типов: данные типа <code>byte</code> преобразуются к типу <code>int</code>. Данный тип преобразований называется расширяющим, так как значение типа <code>byte</code> расширяет свой размер до размера типа <code>int</code>. Расширяющие преобразования проходят автоматически и обычно с этим никаких проблем не возникает.</p>
</div>
<div class="paragraph">
<p>Подобным образом происходит преобразование от типа <code>float</code> к типу <code>double</code> или от типа <code>int</code> к типу <code>long</code>.</p>
</div>
<div class="paragraph">
<p>Кроме расширяющих преобразований есть еще и сужающие. Сужающие преобразования позволяют привести данные к типу с меньшей разрядностью, например, от типа <code>int</code>, который занимает <code>4 байта</code> в памяти, к типу <code>byte</code>, который занимает только <code>1 байт</code> в памяти:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 4;
byte b = a; // ! Error</code></pre>
</div>
</div>
<div class="paragraph">
<p>Несмотря на то, что значение переменной <code>a</code> - число <code>4</code> укладывается в диапазон типа <code>byte</code>, мы все равно получим ошибку. И чтобы безошибочно провести преобразование из одного типа к другому, нам надо применить операцию приведения типов. Суть этой операции состоит в том, что в скобках указывается тип, к которому надо привести данное значение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 4;
byte b = (byte) a;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_потеря_данных_при_преобразовании">3.3.1. Потеря данных при преобразовании</h4>
<div class="paragraph">
<p>В предыдущей ситуации число <code>4</code> вполне укладывалось в диапазон значений типа <code>byte</code>. Но что будет в следующем случае:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 200;
byte b = (byte) a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Результатом будет число <code>-56</code>. В данном случае число <code>200</code> вне диапазона для типа <code>byte</code> (от <code>-128</code> до <code>127</code>), поэтому произойдет усечение значения.</p>
</div>
</div>
<div class="sect3">
<h4 id="_усечение_рациональных_чисел_до_целых">3.3.2. Усечение рациональных чисел до целых</h4>
<div class="paragraph">
<p>При преобразовании значений с плавающей точкой к целочисленным значениям, происходит усечение дробной части:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">double
a = 56.9898;
int b = (int) a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь значение числа <code>b</code> будет равно <code>56</code>, несмотря на то, что число <code>57</code> было бы ближе к <code>56.9898</code>. Чтобы избежать подобных казусов, надо применять функцию округления, которая есть в математической библиотеке Java:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">double a = 56.9898;
int b = (int) Math.round(a);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_преобразования_при_операциях">3.3.3. Преобразования при операциях</h4>
<div class="paragraph">
<p>Нередки ситуации, когда приходится применять различные операции, например, сложение и произведение, над значениями разных типов. Здесь также действуют некоторые правила:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>если один из операндов операции относится к типу <code>double</code>, то и второй операнд преобразуется к типу <code>double</code></p>
</li>
<li>
<p>если предыдущее условие не соблюдено, а один из операндов операции относится к типу <code>float</code>, то и второй операнд преобразуется к типу <code>float</code></p>
</li>
<li>
<p>если предыдущие условия не соблюдены, один из операндов операции относится к типу <code>long</code>, то и второй операнд преобразуется к типу <code>long</code></p>
</li>
<li>
<p>иначе все операнды операции преобразуются к типу <code>int</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Примеры преобразований:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 3;
double b = 4.6;
double c = a + b;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так как в операции участвует значение типа <code>double</code>, то и другое значение приводится к типу <code>double</code> и сумма двух значений <code>a + b</code> будет представлять тип <code>double</code>.</p>
</div>
<div class="paragraph">
<p>Другой пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">byte a = 3;
short b = 4;
byte c = (byte) (a + b);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Две переменных типа <code>byte</code> и <code>short</code> (не <code>double</code>, <code>float</code> или <code>long</code>), поэтому при сложении они преобразуются к типу <code>int</code>, и их сумма <code>a + b</code> представляет значение типа <code>int</code>. Поэтому если затем мы присваиваем эту сумму переменной типа <code>byte</code>, то нам опять надо сделать преобразование типов к <code>byte</code>.</p>
</div>
<div class="paragraph">
<p>Если в операциях участвуют данные типа <code>char</code>, то они преобразуются в <code>int</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int d = 'a' + 5;
System.out.println(d); // 102</code></pre>
</div>
</div>
<div class="paragraph">
<p>Стоит отметить, что несмотря на то, что преобразования из <code>int &#8594; float</code>, <code>long &#8594; float</code> и <code>long &#8594; double</code> произволятся без ошибок, но при преобразовании мы можем столкнутьс с потерей информации. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">float b = 123456789;
System.out.println(b); // 1.23456792E8</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_методы">3.4. Методы</h3>
<div class="sect3">
<h4 id="_использование_методов_в_программе">3.4.1. Использование методов в программе</h4>
<div class="paragraph">
<p>Если <strong>переменные</strong> и <strong>константы</strong> хранят некоторые значения, то <strong>методы</strong> содержат собой набор операторов, которые выполняют определенные действия.</p>
</div>
<div class="paragraph">
<p>Общее определение методов выглядит следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">[модификаторы] тип_возвращаемого_значения название_метода([параметры]) {
    // тело метода
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Модификаторы и параметры необязательны.</p>
</div>
<div class="paragraph">
<p>По умолчанию главный класс любой программы на <strong>Java</strong> содержит метод <code>main</code>, который <strong>служит точкой входа в программу</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static void main(String[] args) {
    System.out.println("привет мир!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ключевые слова <code>public</code> и <code>static</code> являются <strong>модификаторами</strong>. Далее идет <strong>тип возвращаемого значения</strong>. Ключевое слово <code>void</code> указывает на то, что метод ничего не возвращает.</p>
</div>
<div class="paragraph">
<p>Затем идут <strong>название метода</strong> - <code>main</code> и в скобках <strong>параметры метода</strong> - <code>String[] args</code>. И в фигурные скобки заключено <strong>тело метода</strong> - все действия, которые он выполняет.</p>
</div>
<div class="paragraph">
<p>Создадим еще несколько методов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String args[]) {

    }

    void hello() {
        System.out.println("Hello");
    }

    void welcome() {
        System.out.println("Welcome to Java 10");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь определены два дополнительных метода: <code>hello()</code> и <code>welcome()</code>, каждый из которых выводит некоторую строку на консоль. Методы определяются внутри класса - в данном случае внутри класса <code>Program</code>, в котором определен метод <code>main</code>.</p>
</div>
<div class="paragraph">
<p>Но если мы скомпилируем и запустим данную программу, то мы ничего не увидим на консоли. В примере выше мы определили два метода, но мы их нигде не вызываем. По умолчанию в программе <strong>Java</strong> выполняется только метод <code>main()</code> и все его содержимое. Поэтому, если мы хотим, чтобы другие методы тоже выполнялись, их надо вызвать в методе <code>main()</code>.</p>
</div>
<div class="paragraph">
<p>Вызов метода осуществляется в форме:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">имя_метода(аргументы);</code></pre>
</div>
</div>
<div class="paragraph">
<p>После <strong>имени метода</strong> указываются скобки, в которых перечисляются <strong>аргументы</strong> - значения для параметров метода.</p>
</div>
<div class="paragraph">
<p>Например, определим и выполним несколько методов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String args[]) {
         hello();
         welcome();
         welcome();
    }

    static void hello() {
        System.out.println("Hello");
    }

    static void welcome() {
        System.out.println("Welcome to Java!");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В методе <code>main()</code> вызывается один раз метод <code>hello()</code> и два раза метод <code>welcome()</code>. В этом и заключается одно из преимуществ методов: мы можем вынести некоторые общие действия в отдельный метод и затем вызывать многократно их в различных местах программы. Поскольку оба метода не имеют никаких параметров, то после их названия при вызове ставятся пустые скобки.</p>
</div>
<div class="paragraph">
<p>Также следует отметить, что чтобы вызвать в методе <code>main()</code> другие методы, которые определены в одном классе с методом <code>main()</code>, они должны иметь <strong>модификатор</strong> <code>static</code>.</p>
</div>
<div class="paragraph">
<p>В итоге после компиляции и выполнения программы мы увидим на консоли:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="output">Hello
Welcome to Java!
Welcome to Java!</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_передача_параметров_в_методы">3.4.2. Передача параметров в методы</h4>
<div class="paragraph">
<p>С помощью параметров мы можем передать в методы различные данные, которые будут использоваться для вычислений. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">static void sum(int x, int y) {
    int z = x + y;
    System.out.println(z);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Данная функция принимает два параметра - два числа, складывает их и выводит их сумму на консоль.</p>
</div>
<div class="paragraph">
<p>А при вызове этого метода в программе нам необходимо передать на место параметров значения, которые соответствуют типу параметра:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String args[]) {
        int a = 6;
        int b = 8;
        sum(a, b); // 14
        sum(3, a); // 9
        sum(5, 23); // 28
    }

    static void sum(int x, int y) {
        int z = x + y;
        System.out.println(z);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Поскольку метод <code>sum</code> принимает два значения типа <code>int</code>, то на место параметров надо передать два значения типа <code>int</code>. Это могут быть и числовые литералы, и переменные типов данных, которые представляют тип <code>int</code> или могут быть автоматически преобразованы в тип <code>int</code>. Значения, которые передаются на место параметров, еще называются аргументами. Значения передаются параметрам по позиции, то есть первый аргумент первому параметру, второй аргумент - второму параметру и так далее.</p>
</div>
<div class="paragraph">
<p>Рассмотрим другой пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String args[]) {
        display("Tom", 34);
        display("Bob", 28);
        display("Sam", 23);
    }

    static void display(String name, int age) {
        System.out.println(name);
        System.out.println(age);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>display()</code> принимает два параметра. Первый параметр представляет тип <code>String</code>, а второй - тип <code>int</code>. Поэтому при вызове метода вначале в него надо передать строку, а затем число.</p>
</div>
</div>
<div class="sect3">
<h4 id="_параметры_переменной_длины">3.4.3. Параметры переменной длины</h4>
<div class="paragraph">
<p>Метод может принимать параметры переменной длины одного типа. Например, нам надо передать в метод набор числел и ычислить их сумму, но мы точно не знаем, сколько именно чисел будет передано - 3, 4, 5 или больше. Параметры переменной длины позволяют решить эту задачу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String args[]) {
        sum(1, 2, 3); // 6
        sum(1, 2, 3, 4, 5); // 15
        sum(); // 0
    }

    static void sum(int ...nums) {
        int result = 0;
        for (int n : nums) {
            result += n;
        }
        System.out.println(result);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Троеточие перед названием параметра <code>int &#8230;&#8203;nums</code> указывает на то, что он будет необязательным и будет представлять массив. Мы можем передать в метод <code>sum()</code> одно число, несколько чисел, а можем вообще не передавать никаких параметров. Причем, если мы хотим передать несколько параметров, то необязательный параметр должен указываться в конце:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static void main(String[] args) {
    sum("Welcome!", 20, 10);
    sum("Hello World!");
}

static void sum(String message, int ...nums) {
    System.out.println(message);
    int result = 0;
    for (int x: nums) {
        result += x;
    }
    System.out.println(result);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_оператор_return">3.4.4. Оператор <code>return</code></h4>
<div class="paragraph">
<p>Методы могут возвращать некоторое значение. Для этого применяется оператор <code>return</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">return возвращаемое_значение;</code></pre>
</div>
</div>
<div class="paragraph">
<p>После оператора <code>return</code> указывается возвращаемое значение, которое является результатом метода. Это может быть литеральное значение, значение переменной или какого-то сложного выражения.</p>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String args[]) {
        int x = sum(1, 2, 3);
        int y = sum(1, 4, 9);
        System.out.println(x); // 6
        System.out.println(y); // 14
    }

    static int sum(int a, int b, int c) {
        return a + b + c;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В методе в качестве типа возвращаемого значения вместо <code>void</code> используется любой другой тип. В данном случае метод sum возвращает значение типа <code>int</code>, поэтому этот тип указывается перед названием метода. Причем если в качестве возвращаемого типа для метода определен любой другой, отличный от <code>void</code>, то метод обязательно должен использовать оператор <code>return</code> для возвращения значения.</p>
</div>
<div class="paragraph">
<p>При этом возвращаемое значение всегда должно иметь тот же тип, что значится в определении функции. И если функция возвращает значение типа <code>int</code>, то после оператора <code>return</code> стоит целочисленное значение, которое является объектом типа <code>int</code>. Как в данном случае это сумма значений параметров метода.</p>
</div>
<div class="paragraph">
<p>Метод может использовать несколько вызовов оператора <code>return</code> для возваращения разных значений в зависимости от некоторых условий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String args[]) {
        System.out.println(daytime(7)); // Good morning
        System.out.println(daytime(13)); // Good after noon
        System.out.println(daytime(18)); // Good evening
        System.out.println(daytime(2)); // Good night
    }

    static String daytime(int hour) {
        if (hour &gt;24 || hour &lt; 0) {
            return "Invalid data";
        } else if(hour &gt; 21 || hour &lt; 6) {
            return "Good night";
        } else if(hour &gt;= 15) {
            return "Good evening";
        } else if(hour &gt;= 11) {
            return "Good after noon";
        } else {
            return "Good morning";
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь метод <code>daytime()</code> возвращает значение типа <code>String</code>, то есть строку, и в зависимости от значения параметра <code>hour</code> возвращаемая строка будет различаться.</p>
</div>
<div class="sect4">
<h5 id="_выход_из_метода">Выход из метода</h5>
<div class="paragraph">
<p>Оператор <code>return</code> применяется для возвращаения значения из метода, но и для выхода из метода. В подобном качестве оператор <code>return</code> применяется в методах, которые ничего не возвращают, то есть имеют тип <code>void</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String args[]) {
        daytime(7); // Good morning
        daytime(13); // Good after noon
        daytime(32); //
        daytime(56); //
        daytime(2); // Good night
    }

    static void daytime(int hour) {
        if (hour &gt;24 || hour &lt; 0) {
            return;
        } else if(hour &gt; 21 || hour &lt; 6) {
            System.out.println("Good night");
        } else if(hour &gt;= 15) {
            System.out.println("Good evening");
        } else if(hour &gt;= 11) {
            System.out.println("Good after noon");
        } else {
            System.out.println("Good morning");
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если переданное в метод <code>datetime()</code> значение больше <code>24</code> или меньше <code>0</code>, то просто выходим из метода. Возвращаемое значение после <code>return</code> указывать в этом случае не нужно.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_операторы">3.5. Операторы</h3>
<div class="sect3">
<h4 id="_арифметические_операторы">3.5.1. Арифметические операторы</h4>
<div class="paragraph">
<p>Большинство операций в Java аналогичны тем, которые применяются в других <strong>C</strong>-подобных языках. Для выполнения операции используются <strong>оператор</strong> (<strong>operator</strong>), т.е. символ, который используется для этой операции (например: <code>+</code>, <code>-</code> и т.д.).</p>
</div>
<div class="paragraph">
<p>Есть следующие операторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>унарные</strong> - выполняются над одним операндом</p>
</li>
<li>
<p><strong>бинарные</strong> - выполняются над двумя операндами</p>
</li>
<li>
<p><strong>тернарные</strong> - выполняются над тремя операндами</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Операндом</strong> является <strong>переменная</strong> или <strong>литерал</strong> (например, литерал типа <code>int</code>), участвующее в операции. Рассмотрим все виды операторов.</p>
</div>
<div class="paragraph">
<p>В арифметических операциях участвуют числа. Для этих операций в Java есть бинарные и унарные арифметические операторы</p>
</div>
<div class="sect4">
<h5 id="_бинарные">Бинарные</h5>
<div class="paragraph">
<p>К бинарным операторам относят следующие:</p>
</div>
<div class="sect5">
<h6 id=""><code>+</code></h6>
<div class="paragraph">
<p>оператор сложения двух чисел:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 10;
int b = 7;
int c = a + b; // 17
int d = 4 + b; // 11</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_2"><code>-</code></h6>
<div class="paragraph">
<p>оператор вычитания двух чисел:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 10;
int b = 7;
int c = a - b; // 3
int d = 4 - a; // -6</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_3"><code>*</code></h6>
<div class="paragraph">
<p>оператор умножения двух чисел</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 10;
int b = 7;
int c = a * b; // 70
int d = b * 5; // 35</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_4"><code>/</code></h6>
<div class="paragraph">
<p>оператор деления двух чисел:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 20;
int b = 5;
int c = a / b; // 4
double d = 22.5 / 4.5; // 5.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>При делении стоит учитывать, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной <code>float</code> или <code>double</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">double k = 10 / 4; // 2
System.out.println(k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы результат представлял число с плавающей точкой, один из операндов также должен представлять число с плавающей точкой:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">double k = 10.0 / 4; // 2.5
System.out.println(k);</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_5"><code>%</code></h6>
<div class="paragraph">
<p>получение остатка от деления двух чисел:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 33;
int b = 5;
int c = a % b; // 3
int d = 22 % 4; // 22 - 4 * 5 = 2</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_унарные">Унарные</h5>
<div class="paragraph">
<p>В Java есть два унарных арифметических оператора, которые применяются к одному числу:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>++</code> <strong>инкремент</strong></p>
</li>
<li>
<p><code>--</code> <strong>декремент</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Каждый из операторов имеет две разновидности:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>префиксный</p>
</li>
<li>
<p>постфиксный</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_префиксный_инкремент"><code>++</code> (префиксный инкремент)</h6>
<div class="paragraph">
<p>Увеличение переменной на единицу, например, <code>z = ++y</code> (вначале значение переменной <code>y</code> увеличивается на <code>1</code>, а затем ее значение присваивается переменной <code>z</code>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 8;
int b = ++a;
System.out.println(a); // 9
System.out.println(b); // 9</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_постфиксный_инкремент"><code>++</code> (постфиксный инкремент)</h6>
<div class="paragraph">
<p>Увеличение переменной на единицу, например, <code>z = y++</code> (вначале значение переменной y присваивается переменной <code>z</code>, а потом значение переменной <code>y</code> увеличивается на <code>1</code>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 8;
int b = a++;
System.out.println(a); // 9
System.out.println(b); // 8</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_префиксный_декремент"><code>--</code> (префиксный декремент)</h6>
<div class="paragraph">
<p>Уменьшение переменной на единицу, например, <code>z = --y</code> (вначале значение переменной <code>y</code> уменьшается на <code>1</code>, а потом ее значение присваивается переменной <code>z</code>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 8;
int b = --a;
System.out.println(a); // 7
System.out.println(b); // 7</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_постфиксный_декремент"><code>--</code> (постфиксный декремент)</h6>
<div class="paragraph">
<p>Уменьшение переменной на единицу, например, <code>z = y--</code> (сначала значение переменной <code>y</code> присваивается переменной <code>z</code>, а затем значение переменной <code>y</code> уменьшается на <code>1</code>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 8;
int b = a--;
System.out.println(a); // 7
System.out.println(b); // 8</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_операторы_сравнения">3.5.2. Операторы сравнения</h4>
<div class="paragraph">
<p>Условные выражения представляют собой некоторое условие и возвращают значение типа <code>boolean</code>, то есть значение <code>true</code> (если условие истинно), или значение <code>false</code> (если условие ложно). К условным выражениям относятся выражения, которыя содержат операторы сравнения и логические операторы.</p>
</div>
<div class="paragraph">
<p>C операторами сравнения в выражении используются два операнда, и возвращается значение типа <code>boolean</code> - <code>true</code>, если выражение верно, и <code>false</code>, если выражение неверно.</p>
</div>
<div class="sect4">
<h5 id="_6"><code>==</code></h5>
<div class="paragraph">
<p>сравнивает два операнда на равенство и возвращает <code>true</code> (если операнды равны) и <code>false</code> (если операнды не равны)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 10;
int b = 4;
boolean c = a == b; // false
boolean d = a == 10; // true</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_7"><code>!=</code></h5>
<div class="paragraph">
<p>сравнивает два операнда и возвращает <code>true</code>, если операнды НЕ равны, и <code>false</code>, если операнды равны</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 10;
int b = 4;
boolean c = a != b; // true
boolean d = a != 10; // false</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_меньше_чем"><code>&lt;</code> (меньше чем)</h5>
<div class="paragraph">
<p>Возвращает <code>true</code>, если первый операнд меньше второго, иначе возвращает <code>false</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 10;
int b = 4;
boolean c = a &lt; b; // false</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_больше_чем"><code>&gt;</code> (больше чем)</h5>
<div class="paragraph">
<p>Возвращает <code>true</code>, если первый операнд больше второго, иначе возвращает <code>false</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 10;
int b = 4;
boolean c = a &gt; b; // true</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_больше_или_равно"><code>&gt;=</code> (больше или равно)</h5>
<div class="paragraph">
<p>Возвращает <code>true</code>, если первый операнд больше второго или равен второму, иначе возвращает <code>false</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">boolean c = 10 &gt;= 10; // true
boolean b = 10 &gt;= 4; // true
boolean d = 10 &gt;= 20; // false</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_меньше_или_равно"><code>&#8656;</code> (меньше или равно)</h5>
<div class="paragraph">
<p>Возвращает <code>true</code>, если первый операнд меньше второго или равен второму, иначе возвращает <code>false</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">boolean c = 10 &lt;= 10; // true
boolean b = 10 &lt;= 4; // false
boolean d = 10 &lt;= 20; // true</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_логические_операторы">3.5.3. Логические операторы</h4>
<div class="paragraph">
<p>Также в Java есть логические операторы, которые используются в условиях и возвращают <code>true</code> или <code>false</code> и обычно объединяют несколько операторов сравнения. К логическим операторам относят следующие:</p>
</div>
<div class="sect4">
<h5 id="_8"><code>|</code></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">boolean c = a | b;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>c</code> равно <code>true</code>, если либо <code>a</code>, либо <code>b</code> (либо и <code>a</code>, и <code>b</code>) равны <code>true</code>, иначе c будет равно <code>false</code></p>
</div>
</div>
<div class="sect4">
<h5 id="_9"><code>&amp;</code></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">boolean c = a &amp; b;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>c</code> равно <code>true</code>, если и <code>a</code>, и <code>b</code> равны <code>true</code>, иначе <code>c</code> будет равно <code>false</code></p>
</div>
</div>
<div class="sect4">
<h5 id="_10"><code>!</code></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">boolean c = !b;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>c</code> равно <code>true</code>, если <code>b</code> равно <code>false</code>, иначе <code>c</code> будет равно <code>false</code></p>
</div>
</div>
<div class="sect4">
<h5 id="_11"><code>^</code></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">boolean c = a ^ b;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>c</code> равно <code>true</code>, если либо <code>a</code>, либо <code>b</code> (но не одновременно) равны <code>true</code>, иначе <code>c</code> будет равно <code>false</code></p>
</div>
</div>
<div class="sect4">
<h5 id="_12"><code>||</code></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">boolean c = a || b;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>c</code> равно <code>true</code>, если либо <code>a</code>, либо <code>b</code> (либо и <code>a</code>, и <code>b</code>) равны <code>true</code>, иначе c будет равно <code>false</code></p>
</div>
</div>
<div class="sect4">
<h5 id="_13"><code>&amp;&amp;</code></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">boolean c = a &amp;&amp; b;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>c</code> равно <code>true</code>, если и <code>a</code>, и <code>b</code> равны <code>true</code>, иначе c будет равно <code>false</code></p>
</div>
</div>
<div class="sect4">
<h5 id="_разница_между_и_и">Разница между <code>|</code> и <code>||</code>, <code>&amp;</code> и <code>&amp;&amp;</code></h5>
<div class="paragraph">
<p>Здесь две пары операторов <code>|</code> и <code>||</code> (а также <code>&amp;</code> и <code>&amp;&amp;</code>) возвращают похожие результаты, однако же они не равнозначны.</p>
</div>
<div class="paragraph">
<p>Выражение <code>c = a | b;</code> будет вычислять сначала оба значения - <code>a</code> и <code>b</code> и на их основе выводить результат.</p>
</div>
<div class="paragraph">
<p>В выражении же <code>c = a || b;</code> вначале будет вычисляться значение <code>a</code>, и если оно равно <code>true</code>, то вычисление значения <code>b</code> уже смысла не имеет, так как у нас в любом случае уже <code>c</code> будет равно <code>true</code>. Значение <code>b</code> будет вычисляться только в том случае, если <code>a</code> равно <code>false</code></p>
</div>
<div class="paragraph">
<p>То же самое касается пары операций <code>&amp;</code>/<code>&amp;&amp;</code>. В выражении <code>c = a &amp; b;</code> будут вычисляться оба значения - <code>a</code> и <code>b</code>.</p>
</div>
<div class="paragraph">
<p>В выражении же <code>c = a &amp;&amp; b;</code> сначала будет вычисляться значение <code>a</code>, и если оно равно <code>false</code>, то вычисление значения <code>b</code> уже не имеет смысла, так как значение <code>c</code> в любом случае равно <code>false</code>. Значение <code>b</code> будет вычисляться только в том случае, если a равно <code>true</code></p>
</div>
<div class="paragraph">
<p>Таким образом, операторы <code>||</code> и <code>&amp;&amp;</code> более удобны в вычислениях, позволяя сократить время на вычисление значения выражения и тем самым повышая производительность. А операторы <code>|</code> и <code>&amp;</code> больше подходят для выполнения поразрядных операций над числами.</p>
</div>
</div>
<div class="sect4">
<h5 id="_примеры">Примеры:</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">boolean a1 = (5 &gt; 6) || (4 &lt; 6); // 5 &gt; 6 - false, 4 &lt; 6 - true, поэтому возвращается true
boolean a2 = (5 &gt; 6) || (4 &gt; 6); // 5 &gt; 6 - false, 4 &gt; 6 - false, поэтому возвращается false
boolean a3 = (5 &gt; 6) &amp;&amp; (4 &lt; 6); // 5 &gt; 6 - false, 4 &lt; 6 - true, поэтому возвращается false
boolean a4 = (50 &gt; 6) &amp;&amp; (4 / 2 &lt; 3); // 50 &gt; 6 - true, 4/2 &lt; 3 - true, поэтому возвращается true
boolean a5 = (5 &gt; 6) ^ (4 &lt; 6); // 5 &gt; 6 - false, 4 &lt; 6 - true, поэтому возвращается true
boolean a6 = (50 &gt; 6) ^ (4 / 2 &lt; 3); // 50 &gt; 6 - true, 4/2 &lt; 3 - true, поэтому возвращается false</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_операторы_присваивания">3.5.4. Операторы присваивания</h4>
<div class="paragraph">
<p>Операторы присваивания в основном представляют комбинацию простого присваивания с другими операторами:</p>
</div>
<div class="sect4">
<h5 id="_14"><code>=</code></h5>
<div class="paragraph">
<p><code>c = b;</code> (переменной <code>c</code> приравнивает значение переменной <code>b</code>)</p>
</div>
</div>
<div class="sect4">
<h5 id="_15"><code>+=</code></h5>
<div class="paragraph">
<p><code>c += b;</code> (переменной <code>c</code> присваивается результат сложения <code>c</code> и <code>b</code>)</p>
</div>
</div>
<div class="sect4">
<h5 id="_16"><code>-=</code></h5>
<div class="paragraph">
<p><code>c -= b;</code> (переменной <code>c</code> присваивается результат вычитания <code>b</code> из <code>c</code>)</p>
</div>
</div>
<div class="sect4">
<h5 id="_17"><code>*=</code></h5>
<div class="paragraph">
<p><code>c *= b;</code> (переменной <code>c</code> присваивается результат произведения <code>c `и `b</code>)</p>
</div>
</div>
<div class="sect4">
<h5 id="_18"><code>/=</code></h5>
<div class="paragraph">
<p><code>c /= b;</code> (переменной <code>c</code> присваивается результат деления <code>c</code> на <code>b</code>)</p>
</div>
</div>
<div class="sect4">
<h5 id="_19"><code>%=</code></h5>
<div class="paragraph">
<p><code>c %= b;</code> (переменной <code>c</code> присваивается остаток от деления <code>c</code> на <code>b</code>)</p>
</div>
</div>
<div class="sect4">
<h5 id="_20"><code>&amp;=</code></h5>
<div class="paragraph">
<p><code>c &amp;= b;</code> (переменной <code>c</code> присваивается значение <code>c &amp; b</code>)</p>
</div>
</div>
<div class="sect4">
<h5 id="_21"><code>|=</code></h5>
<div class="paragraph">
<p><code>c |= b;</code> (переменной <code>c</code> присваивается значение <code>c | b</code>)</p>
</div>
</div>
<div class="sect4">
<h5 id="_22"><code>^=</code></h5>
<div class="paragraph">
<p><code>c ^= b;</code> (переменной <code>c</code> присваивается значение <code>c ^ b</code>)</p>
</div>
</div>
<div class="sect4">
<h5 id="_23"><code>&lt;&#8656;</code></h5>
<div class="paragraph">
<p><code>c &lt;&#8656; b;</code> (переменной <code>c</code> присваивается значение <code>c &lt;&lt; b</code>)</p>
</div>
</div>
<div class="sect4">
<h5 id="_24"><code>&gt;&gt;=</code></h5>
<div class="paragraph">
<p><code>c &gt;&gt;= b;</code> (переменной <code>c</code> присваивается значение <code>c &gt;&gt; b</code>)</p>
</div>
</div>
<div class="sect4">
<h5 id="_25"><code>&gt;&gt;&gt;=</code></h5>
<div class="paragraph">
<p><code>c &gt;&gt;&gt;= b;</code> (переменной <code>c</code> присваивается значение <code>c &gt;&gt;&gt; b</code>)</p>
</div>
</div>
<div class="sect4">
<h5 id="_примеры_операций">Примеры операций:</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 5;
a += 10; // 15
a -= 3; // 12
a *= 2; // 24
a /= 6; // 4
a &lt;&lt;= 4; // 64
a &gt;&gt;= 2; // 16
System.out.println(a);  // 16</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_побитовые_операторы">3.5.5. Побитовые операторы</h4>
<div class="paragraph">
<p>Побитовые операторы применяются к отдельным разрядам или битами чисел. Данные опараторы применяются с операндами, которые являются только целыми числами.</p>
</div>
<div class="sect4">
<h5 id="_логические_побитовые_операторы">Логические побитовые операторы</h5>
<div class="paragraph">
<p>Логические побитовые операторы для чисeл представляют собой поразрядные операторы. В данном случае числа рассматриваются в двоичном представлении, например, <code>2</code> в двоичной системе равно <code>10</code> и имеет два разряда, число <code>7</code> - <code>111</code> и имеет три разряда.</p>
</div>
<div class="sect5">
<h6 id="_логическое_умножение"><code>&amp;</code> (логическое умножение)</h6>
<div class="paragraph">
<p>Умножение производится поразрядно, и если у обоих операндов значения разрядов равно <code>1</code>, то после применения оператора возвращается <code>1</code>, иначе возвращается число <code>0</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a1 = 2; //010
int b1 = 5; //101
System.out.println(a1 &amp; b1); // результат 0

int a2 = 4; //100
int b2 = 5; //101
System.out.println(a2 &amp; b2); // результат 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>В первом случае у нас два числа <code>2</code> и <code>5</code>. <code>2</code> в двоичном виде представляет число <code>010</code>, а <code>5</code> - <code>101</code>. Поразрядное умножение чисел <code>(0*1, 1*0, 0*1)</code> дает результат <code>000</code>.</p>
</div>
<div class="paragraph">
<p>Во втором случае у нас вместо <code>2</code> число <code>4</code>, у которого в первом разряде <code>1</code>, так же как и у числа <code>5</code>, поэтому здесь результатом применения оператора <code>(1*1, 0*0, 0 *1) = 100</code> будет число <code>4</code> в десятичном формате.</p>
</div>
</div>
<div class="sect5">
<h6 id="_логическое_сложение"><code>|</code> (логическое сложение)</h6>
<div class="paragraph">
<p>Данный оператор также применяется к двоичным разрядам, но теперь возвращается единица, если хотя бы у одного числа в данном разряде имеется единица (оператор <strong>логическое ИЛИ</strong>). Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a1 = 2; //010
int b1 = 5; //101
System.out.println(a1 | b1); // результат 7 - 111

int a2 = 4; //100
int b2 = 5; //101
System.out.println(a2 | b2); // результат 5 - 101</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_логическое_исключающее_или"><code>^</code> (логическое исключающее <strong>ИЛИ</strong>)</h6>
<div class="paragraph">
<p>Иногда этот оператор называют <code>XOR</code>, нередко его применяют для простого шифрования:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int number = 45; // 1001 Значение, которое надо зашифровать - в двоичной форме 101101
int key = 102; // Ключ шифрования - в двоичной системе 1100110
int encrypt = number ^ key; // Результатом будет число 1001011 или 75
System.out.println("Зашифрованное число: " +encrypt);

int decrypt = encrypt ^ key; // Результатом будет исходное число 45
System.out.println("Расшифрованное число: " + decrypt);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь также производятся поразрядное применение оператора. Если значения текущего разряда у обоих чисел разные, то возвращается <code>1</code>, иначе возвращается <code>0</code>. Например, результатом выражения <code>9 ^ 5</code> будет число <code>12</code>. А чтобы расшифровать число, мы применяем обратный оператор к результату.</p>
</div>
</div>
<div class="sect5">
<h6 id="_логическое_отрицание"><code>~</code> (логическое отрицание)</h6>
<div class="paragraph">
<p>Поразрядный оператор, инвертирующий все разряды числа: если значение разряда равно <code>1</code>, то оно становится равным <code>0</code>, и наоборот.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int a = 56;
System.out.println(~a);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_побитовые_операторы_сдвига">Побитовые операторы сдвига</h5>
<div class="paragraph">
<p>Операторы сдвига также производятся над разрядами чисел. Сдвиг может происходить вправо и влево.</p>
</div>
<div class="sect5">
<h6 id="_26"><code>&lt;&lt;</code></h6>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">a &lt;&lt; b</code></pre>
</div>
</div>
<div class="paragraph">
<p>сдвигает число <code>a</code> влево на <code>b</code> разрядов. Например, выражение <code>4 &lt;&lt; 1</code> сдвигает число <code>4</code> (которое в двоичном представлении <code>100</code>) на один разряд влево, в результате получается число <code>1000</code> или число <code>8</code> в десятичном представлении.</p>
</div>
</div>
<div class="sect5">
<h6 id="_27"><code>&gt;&gt;</code></h6>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">a &gt;&gt; b</code></pre>
</div>
</div>
<div class="paragraph">
<p>смещает число <code>a</code> вправо на <code>b</code> разрядов. Например, <code>16 &gt;&gt; 1</code> сдвигает число 16 (которое в двоичной системе <code>10000</code>) на один разряд вправо, то есть в итоге получается <code>1000</code> или число <code>8</code> в десятичном представлении.</p>
</div>
</div>
<div class="sect5">
<h6 id="_28"><code>&gt;&gt;&gt;</code></h6>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">a &gt;&gt;&gt; b</code></pre>
</div>
</div>
<div class="paragraph">
<p>в отличие от предыдущих типов сдвигов данный оператор представляет беззнаковый сдвиг - сдвигает число <code>a</code> вправо на <code>b</code> разрядов. Например, выражение <code>-8 &gt;&gt;&gt; 2</code> будет равно <code>1073741822</code>.</p>
</div>
<div class="paragraph">
<p>Таким образом, если исходное число, которое надо сдвинуть в ту или другую строну, делится на два, то фактически получается умножение или деление на два. Поэтому подобный оператор можно использовать вместо непосредственного умножения или деления на два, так как оператор сдвига на аппаратном уровне менее дорогостоящая оператор в отличие от операторов деления или умножения.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_приоритет_операций">3.5.6. Приоритет операций</h4>
<div class="paragraph">
<p>При работе с операторами важно понимать их приоритет, который можно описать следующей схемой (по убыванию приоритета):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">i++ i--

++i --i +i -i ~ !

* / %

+ -

&lt;&lt; &gt;&gt; &gt;&gt;&gt;

&lt; &gt; &lt;= &gt;= instanceof

== !=

&amp;

^

|

&amp;&amp;

||

? : (тернарный оператор)

= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= (операторы присваивания)</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Cкобки повышают приоритет операторы, используемой в выражении.</p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_условные_конструкции">3.6. Условные конструкции</h3>
<div class="paragraph">
<p>Одним из фундаментальных элементов многих языков программирования являются условные конструкции. Данные конструкции позволяют направить работу программы по одному из путей в зависимости от определенных условий.</p>
</div>
<div class="paragraph">
<p>В языке <strong>Java</strong> используются следующие условные конструкции: <code>if..else</code> и <code>switch..case</code></p>
</div>
<div class="sect3">
<h4 id="_конструкция_ifelse">3.6.1. Конструкция <code>if/else</code></h4>
<div class="paragraph">
<p>Выражение if/else проверяет истинность некоторого условия и в зависимости от результатов проверки выполняет определенный код:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int num1 = 6;
int num2 = 4;
if (num1 &gt; num2) {
    System.out.println("Первое число больше второго");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>После ключевого слова <code>if</code> ставится условие. И если это условие выполняется, то срабатывает код, который помещен в далее в блоке <code>if</code> после фигурных скобок. В качестве условий выступает операция сравнения двух чисел.</p>
</div>
<div class="paragraph">
<p>Так как, в данном случае первое число больше второго, то выражение <code>num1 &gt; num2</code> истинно и возвращает значение <code>true</code>. Следовательно, управление переходит в блок кода после фигурных скобок и начинает выполнять содержащиеся там инструкции, а конкретно метод <code>System.out.println("Первое число больше второго");</code>. Если бы первое число оказалось бы меньше второго или равно ему, то инструкции в блоке <code>if</code> не выполнялись бы.</p>
</div>
<div class="paragraph">
<p>Но что, если мы захотим, чтобы при несоблюдении условия также выполнялись какие-либо действия? В этом случае мы можем добавить блок <code>else</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int num1 = 6;
int num2 = 4;
if (num1 &gt; num2) {
    System.out.println("Первое число больше второго");
} else {
    System.out.println("Первое число меньше второго");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Но при сравнении чисел мы можем насчитать три состояния:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>первое число больше второго</p>
</li>
<li>
<p>первое число меньше второго</p>
</li>
<li>
<p>числа равны</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>С помощью выражения <code>else if</code>, мы можем обрабатывать дополнительные условия:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int num1 = 6;
int num2 = 8;
if (num1 &gt; num2) {
    System.out.println("Первое число больше второго");
} else if (num1 &lt; num2) {
    System.out.println("Первое число меньше второго");
} else {
    System.out.println("Числа равны");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Также мы можем соединить сразу несколько условий, используя логические операторы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int num1 = 8;
int num2 = 6;
if (num1 &gt; num2 &amp;&amp; num1 &gt; 7) {
    System.out.println("Первое число больше второго и больше 7");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь блок <code>if</code> будет выполняться, если <code>num1 &gt; num2</code> равно <code>true</code> и одновременно <code>num1 &gt; 7</code> равно <code>true</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_конструкция_switch">3.6.2. Конструкция <code>switch</code></h4>
<div class="paragraph">
<p>Конструкция <code>switch/case</code> аналогична конструкции <code>if/else</code>, так как позволяет обработать сразу несколько условий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int num = 8;
switch(num) {
    case 1:
        System.out.println("число равно 1");
        break;
    case 8:
        System.out.println("число равно 8");
        num++;
        break;
    case 9:
        System.out.println("число равно 9");
        break;
    default:
        System.out.println("число не равно 1, 8, 9");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>После ключевого слова <code>switch</code> в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями, помещенными после оператора <code>сase</code>. И если совпадение будет найдено, то будет выполняться определенный блок <code>сase</code>.</p>
</div>
<div class="paragraph">
<p>В конце блока <code>сase</code> ставится оператор <code>break</code>, чтобы избежать выполнения других блоков. Например, если бы убрали бы оператор <code>break</code> в следующем случае:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">case 8:
    System.out.println("число равно 8");
    num++;
case 9:
    System.out.println("число равно 9");
    break;</code></pre>
</div>
</div>
<div class="paragraph">
<p>то так как у нас переменная <code>num</code> равно <code>8</code>, то выполнился бы блок <code>case 8</code>, но так как в этом блоке переменная <code>num</code> увеличивается на единицу, оператор <code>break</code> отсутствует, то начал бы выполняться блок <code>case 9</code>.</p>
</div>
<div class="paragraph">
<p>Если мы хотим также обработать ситуацию, когда совпадения не будет найдено, то можно добавить блок <code>default</code>, как в примере выше. Хотя блок <code>default</code> необязателен.</p>
</div>
<div class="paragraph">
<p>Начиная с <strong>JDK 7</strong> в выражении <code>switch..case</code> кроме примитивных типов можно также использовать строки:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">package firstapp;

import java.util.Scanner;

public class FirstApp {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println("Введите Y или N: ");
        String input = in.nextLine();
        switch(input) {
            case "Y":
                System.out.println("Вы нажали букву Y");
                break;
            case "N":
                System.out.println("Вы нажали букву N");
                break;
            default:
                System.out.println("Вы нажали неизвестную букву");
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_тернарная_операция">3.6.3. Тернарная операция</h4>
<div class="paragraph">
<p>Тернарная операция имеет следующий синтаксис:</p>
</div>
<div class="paragraph">
<p><code>[первый операнд - условие] ? [второй операнд] : [третий операнд]</code></p>
</div>
<div class="paragraph">
<p>Таким образом, в этой операции участвуют сразу три операнда. В зависимости от условия тернарная операция возвращает второй или третий операнд:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">если условие равно true,
    то возвращается второй операнд;
если условие равно false,
    то третий.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int x=3;
int y=2;
int z = x &lt; y ? (x + y) : (x - y);
System.out.println(z);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь результатом тернарной операции является переменная <code>z</code>. Сначала проверяется условие <code>x &lt; y</code>. И если оно соблюдается, то <code>z</code> будет равно второму операнду - <code>(x + y)</code>, иначе <code>z</code> будет равно третьему операнду.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_циклы">3.7. Циклы</h3>
<div class="paragraph">
<p>Еще одним видом управляющих конструкций являются циклы. Циклы позволяют в зависимости от определенных условий выполнять определенное действие множество раз. В языке <strong>Java</strong> есть следующие виды циклов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>for</code></p>
</li>
<li>
<p><code>while</code></p>
</li>
<li>
<p><code>do&#8230;&#8203;while</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_цикл_for">3.7.1. Цикл <code>for</code></h4>
<div class="paragraph">
<p>Цикл for имеет следующее формальное определение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">for ([инициализация счетчика]; [условие]; [изменение счетчика])
{
    // действия
}
Рассмотрим стандартный цикл for:</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">for (int i = 1; i &lt; 9; i++) {
    System.out.printf("Квадрат числа %d равен %d \n", i, i * i);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>объявления цикла</strong> - <code>int i = 1</code> создает и инициализирует <strong>счетчик</strong> <code>i</code>. <strong>Счетчик</strong> необязательно должен представлять тип <code>int</code>. Это может быть и любой другой числовой тип, например, <code>float</code>. Перед выполнением цикла значение <strong>счетчика</strong> будет равно <code>1</code>. В данном случае это то же самое, что и объявление переменной</p>
</li>
<li>
<p><strong>условие</strong>, при котором будет выполняться цикл. В данном случае цикл будет выполняться, пока <code>i</code> не достигнет <code>9</code></p>
</li>
<li>
<p><strong>приращение счетчика</strong> на единицу. Опять же нам необязательно увеличивать на единицу. Можно уменьшать: <code>i--</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В итоге блок цикла сработает 8 раз, пока значение <code>i</code> не станет равным <code>9</code>. И каждый раз это значение будет увеличиваться на <code>1</code>.</p>
</div>
<div class="paragraph">
<p>Нам необязательно указывать все условия при объявлении цикла. Например, мы можем написать так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int i = 1;
for ( ; ; ) {
    System.out.printf("Квадрат числа %d равен %d \n", i, i * i);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Определение цикла осталось тем же, только теперь блоки в определении у нас пустые: <code>for (; ;)</code>. Теперь нет инициализированной <strong>переменной-счетчика</strong>, нет <strong>условия</strong>, поэтому цикл будет работать вечно - <strong>бесконечный цикл</strong>.</p>
</div>
<div class="paragraph">
<p>Либо можно опустить ряд блоков:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int i = 1;
for ( ; i &lt; 9; ) {
    System.out.printf("Квадрат числа %d равен %d \n", i, i * i);
    i++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот пример эквивалентен первому примеру: у нас также есть <strong>счетчик</strong>, только создан он вне цикла. У нас есть <strong>условие выполнения цикла</strong>. И есть <strong>приращение счетчика</strong> уже в самом блоке <code>for</code>.</p>
</div>
<div class="paragraph">
<p>Цикл for может определять сразу несколько переменных и управлять ими:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int n = 10;
for (int i = 0, j = n - 1; i &lt; j; i++, j--) {
    System.out.println(i * j);
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_цикл_foreach">Цикл <code>foreach</code></h5>
<div class="paragraph">
<p>Специальная версия цикла <code>for</code> предназначена для перебора элементов в наборах элементов, например, в <strong>массивах</strong> и <strong>коллекциях</strong>. Она аналогична действию цикла <code>foreach</code> , который имеется в других языках программирования. Формальное ее объявление:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">for (тип_данных название_переменной : контейнер){
    // действия
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int[] array = new int[] { 1, 2, 3, 4, 5 };
for (int i : array) {
    System.out.println(i);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В качестве контейнера в данном случае выступает массив данных типа <code>int</code>. Затем объявляется переменная с типом <code>int</code></p>
</div>
<div class="paragraph">
<p>То же самое можно было бы сделать и с помощью обычной версии <code>for</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int[] array = new int[] { 1, 2, 3, 4, 5 };
for (int i = 0; i &lt; array.length; i++) {
    System.out.println(array[i]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В то же время эта версия цикла <code>for</code> более гибкая по сравнению <code>for (int i : array)</code>. В частности, в этой версии мы можем изменять элементы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int[] array = new int[] { 1, 2, 3, 4, 5 };
for (int i = 0; i &lt; array.length; i++) {
    array[i] = array[i] * 2;
    System.out.println(array[i]);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_перебор_многомерных_массивов_в_цикле">3.7.2. Перебор многомерных массивов в цикле</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int[][] nums = new int[][]
{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
for (int i = 0; i &lt; nums.length; i++) {
    for (int j = 0; j &lt; nums[i].length; j++) {
        System.out.printf("%d ", nums[i][j]);
    }
    System.out.println();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сначала создается цикл для перебора по строкам, а затем внутри первого цикла создается внутренний цикл для перебора по столбцам конкретной строки. Подобным образом можно перебрать и трехмерные массивы и наборы с большим количеством размерностей.</p>
</div>
</div>
<div class="sect3">
<h4 id="_цикл_do">3.7.3. Цикл <code>do</code></h4>
<div class="paragraph">
<p>Цикл <code>do</code> сначала выполняет <strong>код цикла</strong>, а потом проверяет <strong>условие</strong> в инструкции <code>while</code>. И пока это условие истинно, цикл повторяется. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int j = 7;
do {
    System.out.println(j);
    j--;
}
while (j &gt; 0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае код цикла сработает 7 раз, пока <code>j</code> не окажется равным нулю. Важно отметить, что цикл <code>do</code> <strong>гарантирует хотя бы однократное выполнение действий</strong>, даже если условие в инструкции <code>while</code> не будет истинно. Так, мы можем написать:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int j = -1;
do {
    System.out.println(j);
    j--;
}
while (j &gt; 0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Хотя переменная <code>j</code> изначально меньше <code>0</code>, цикл все равно один раз выполнится.</p>
</div>
</div>
<div class="sect3">
<h4 id="_цикл_while">3.7.4. Цикл <code>while</code></h4>
<div class="paragraph">
<p>Цикл <code>while</code> сразу проверяет истинность некоторого условия, и если условие истинно, то код цикла выполняется:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int j = 6;
while (j &gt; 0) {
    System.out.println(j);
    j--;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_операторы_continue_и_break">3.7.5. Операторы <code>continue</code> и <code>break</code></h4>
<div class="paragraph">
<p>Иногда требуется выйти из цикла, не дожидаясь его завершения. В этом случае мы можем воспользоваться оператором <code>break</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int[] nums = new int[] { 1, 2, 3, 4, 12, 9 };
for (int i = 0; i &lt; nums.length; i++) {
    if (nums[i] &gt; 10)
        break;
    System.out.println(nums[i]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так как в цикле идет проверка, больше ли элемент массива <code>10</code>, то мы не увидим на консоли последние два элемента, так как когда <code>nums[i]</code> окажется больше <code>10</code> (то есть равно <code>12</code>), сработает оператор <code>break</code>, и цикл завершится.</p>
</div>
<div class="paragraph">
<p>Правда, мы также не увидим и последнего элемента, который меньше <code>10</code>. Теперь сделаем так, чтобы если число больше <code>10</code>, цикл не завершался, а просто переходил к следующему элементу. Для этого используем оператор <code>continue</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int[] nums = new int[] { 1, 2, 3, 4, 12, 9 };
for (int i = 0; i &lt; nums.length; i++) {
    if (nums[i] &gt; 10)
        continue;
    System.out.println(nums[i]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом случае, когда выполнение цикла дойдет до числа <code>12</code>, которое не удовлетворяет условию проверки, то программа просто пропустит это число и перейдет к следующему элементу массива.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_массивы">3.8. Массивы</h3>
<div class="sect3">
<h4 id="_одномерные_массивы">3.8.1. Одномерные массивы</h4>
<div class="paragraph">
<p>Если переменные предназначены для хранения одиночного значения, то массив представляет набор однотипных значений. Объявление массива похоже на объявление переменной, причем есть два способа объявления массива:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">тип_данных[] название_массива;
// либо
тип_данных []название_массива;
// либо
тип_данных название_массива[];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например, определим массив чисел:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int[] nums3; // best practice
int []nums2;
int nums[];</code></pre>
</div>
</div>
<div class="paragraph">
<p>После объявления массива мы можем инициализовать его:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int nums[]; // объявили
nums = new int[4]; // инициализировали (массив из 4 чисел)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Создание массива производится с помощью следующей конструкции: <code>new тип_данных[количество_элементов]</code>, где <code>new</code> - ключевое слово, выделяющее память для указанного в скобках количества элементов. Например, <code>nums = new int[4];</code> - в этом выражении создается массив из четырех элементов <code>int</code> и каждый элемент по умолчанию равен <code>0</code>.</p>
</div>
<div class="paragraph">
<p>Также можно сразу при объявлении массива инициализировать его:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int nums[] = new int[4]; // массив из 4 чисел
int[] nums2 = new int[5]; // массив из 5 чисел</code></pre>
</div>
</div>
<div class="paragraph">
<p>При подобной инициализации все элементы массива имеют значение по умолчанию. Для числовых типов (в том числе для типа <code>char</code>) это число <code>0</code>, для типа <code>boolean</code> это значение <code>false</code>, а для остальных объектов это значение <code>null</code>. Например, для типа <code>int</code> значением по умолчанию является число <code>0</code>, поэтому выше определенный массив <code>nums</code> будет состоять из четырех нулей.</p>
</div>
<div class="paragraph">
<p>Однако также можно задать конкретные значения для элементов массива при его создании:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">// эти два способа равноценны
int[] nums = new int[] {1, 2, 3, 5};
int[] nums2 = {1, 2, 3, 5};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Стоит отметить, что в этом случае в квадратных скобках не указывается размер массива, так как он вычисляется по количеству элементов в фигурных скобках.</p>
</div>
<div class="paragraph">
<p>После создания массива мы можем обратиться к любому его элементу и изменить его:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int[] nums = new int[4];
nums[0] = 1;
nums[1] = 2;
nums[2] = 4;
nums[3] = 100;
System.out.println(nums[2]); // 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Отсчет элементов массива начинается с <code>0</code>, поэтому в данном случае, чтобы обратиться к четвертому элементу в массиве, нам надо использовать выражение <code>nums[3]</code>.</p>
</div>
<div class="paragraph">
<p>И так как у нас массив определен только для 4 элементов, то мы не можем обратиться, например, к шестому элементу: <code>nums[5] = 5;</code>. Если мы так попытаемся сделать, то мы получим ошибку.</p>
</div>
</div>
<div class="sect3">
<h4 id="_многомерные_массивы">3.8.2. Многомерные массивы</h4>
<div class="paragraph">
<p>Ранее мы рассматривали одномерные массивы, которые можно представить как цепочку или строку однотипных значений. Но кроме одномерных массивов также бывают и многомерными. Наиболее известный многомерный массив - таблица, представляющая двухмерный массив:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int[] nums1 = new int[] {0, 1, 2, 3, 4, 5};
int[][] nums2 = {
  {0, 1, 2},
  {3, 4, 5}
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Визуально оба массива можно представить следующим образом:</p>
</div>
<div class="sect4">
<h5 id="_одномерный_массив_nums1">Одномерный массив <code>nums1</code></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_двухмерный_массив_nums2">Двухмерный массив <code>nums2</code></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Поскольку массив <code>nums2</code> двухмерный, он представляет собой простую таблицу. Его также можно было создать следующим образом: <code>int[][] nums2 = new int[3][3];</code>. Количество квадратных скобок указывает на размерность массива. А числа в скобках - на количество строк и столбцов. И также, используя индексы, мы можем использовать элементы массива в программе:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">// установим элемент первого столбца второй строки
nums2[1][0] = 44;
System.out.println(nums2[1][0]);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Объявление трехмерного массива могло бы выглядеть так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int[][][] nums3 = new int[2][3][4];</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_массив_массивов">3.8.3. Массив массивов</h4>
<div class="paragraph">
<p>Многомерные массивы могут быть также представлены как "зубчатые массивы". В вышеприведенном примере двухмерный массив имел 3 строчки и три столбца, поэтому у нас получалась ровная таблица. Но мы можем каждому элементу в двухмерном массиве присвоить отдельный массив с различным количеством элементов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int[][] nums = new int[3][];
nums[0] = new int[2];
nums[1] = new int[3];
nums[2] = new int[5];
...</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_работа_с_массивами">3.8.4. Работа с массивами</h4>
<div class="paragraph">
<p>Важнейшее свойство, которым обладают массивы, является свойство <code>length</code>, возвращающее длину массива, то есть количество его элементов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int length = nums.length;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Нередко бывает неизвестная последний индекс, и чтобы получить последний элемент массива, мы можем использовать это свойство:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int last = nums[nums.length - 1];</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_класс_arrays">3.8.5. Класс <code>Arrays</code></h4>
<div class="paragraph">
<p>Класс <code>java.util.Arrays</code> предназначен для работы с массивами. Он содержит удобные методы для работы с целыми массивами:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String toString(T[])</code> − позволяет получить все элементы в виде одной строки</p>
</li>
<li>
<p><code>T[] copyOf(T[], int)</code> − предназначен для копирования массива</p>
</li>
<li>
<p><code>T[] copyOfRange(T[], int, int)</code> − копирует часть массива</p>
</li>
<li>
<p><code>void sort(T[])</code> — сортирует массив методом <code>quick sort</code></p>
</li>
<li>
<p><code>void sort(T[], int, int)</code> — сортирует массив методом <code>quick sort</code></p>
</li>
<li>
<p><code>int binarySearch(T[], T)</code> − ищет элемент методом бинарного поиска</p>
</li>
<li>
<p><code>int binarySearch(T[], int, int, T)</code> − ищет элемент методом бинарного поиска</p>
</li>
<li>
<p><code>void fill(T[], T)</code> − заполняет массив переданным значением (удобно использовать, если нам необходимо значение по умолчанию для массива)</p>
</li>
<li>
<p><code>void fill(T[], int, int, T)</code> − заполняет массив переданным значением (удобно использовать, если нам необходимо значение по умолчанию для массива)</p>
</li>
<li>
<p><code>boolean equals(T[], T[])</code> − проверяет на идентичность массивы</p>
</li>
<li>
<p><code>boolean equals(T[], int, int, T[], int, int)</code> − проверяет на идентичность массивы</p>
</li>
<li>
<p><code>int compare(T[], T[])</code> − сравнивает массивы</p>
</li>
<li>
<p><code>int compare(T[], int, int, T[], int, int)</code> − сравнивает массивы</p>
</li>
<li>
<p><code>boolean deepEquals(Object[], Object[])</code> − проверяет на идентичность массивы массивов</p>
</li>
<li>
<p><code>List&lt;T&gt; asList(T&#8230;&#8203;)</code> − возвращает массив как коллекцию</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_строки">3.9. Строки</h3>
<div class="paragraph">
<p>Строка представляет собой последовательность символов. Для работы со строками в Java определен класс <code>String</code>, который предоставляет ряд методов для манипуляции строками. Физически объект <code>String</code> представляет собой ссылку на область в памяти, в которой размещены символы.</p>
</div>
<div class="paragraph">
<p>Для создания новой строки мы можем использовать один из конструкторов класса <code>String</code>, либо напрямую присвоить строку в двойных кавычках:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static void main(String[] args) {
    String str1 = "Java";
    String str2 = new String(); // пустая строка
    String str3 = new String(new char[] {'h', 'e', 'l', 'l', 'o'});
    String str4 = new String(new char[] {'w', 'e', 'l', 'c', 'o', 'm', 'e'}, 3, 4); // 3 -начальный индекс, 4 -количество символов

    System.out.println(str1); // Java
    System.out.println(str2); //
    System.out.println(str3); // hello
    System.out.println(str4); // come
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>При работе со строками важно понимать, что объект <code>String</code> является неизменяемым (<strong>immutable</strong>). То есть при любых операциях над строкой, которые изменяют эту строку, фактически будет создаваться новая строка.</p>
</div>
<div class="sect3">
<h4 id="_конкатенация_строк">3.9.1. Конкатенация строк</h4>
<div class="paragraph">
<p>Для соединения строк можно использовать операцию сложения <code>+</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str1 = "Java";
String str2 = "Hello";
String str3 = str2 + " " + str1;

System.out.println(str3); // Hello Java</code></pre>
</div>
</div>
<div class="paragraph">
<p>При этом если в операции сложения строк используется нестроковый объект, например, число, то этот объект преобразуется к строке:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str3 = "Год " + 2015;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Фактически же при сложении строк с нестроковыми объектами будет вызываться метод <code>valueOf()</code> класса <code>String</code>. Данный метод имеет множество перегрузок и преобразует практически все типы данных к строке. Для преобразования объектов различных классов метод <code>valueOf()</code> вызывает метод <code>toString()</code> этих классов.</p>
</div>
</div>
<div class="sect3">
<h4 id="_основные_методы_класса_string">3.9.2. Основные методы класса String</h4>
<div class="sect4">
<h5 id="_lenght"><code>lenght()</code></h5>
<div class="paragraph">
<p>Поскольку строка рассматривается как набор символов, то мы можем применить метод <code>length()</code> для нахождения длины строки или длины набора символов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str1 = "Java";
System.out.println(str1.length()); // 4</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tochararray"><code>toCharArray()</code></h5>
<div class="paragraph">
<p>С помощью метода <code>toCharArray()</code> можно обратно преобразовать строку в массив символов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str1 = new String(new char[] {'h', 'e', 'l', 'l', 'o'});
char[] helloArray = str1.toCharArray();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Строка может быть пустой. Для этого ей можно присвоить пустые кавычки или удалить из стоки все символы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String s = ""; // строка не указывает на объект
if (s.length() == 0) {
    System.out.println("String is empty");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом случае длина строки, возвращаемая методом <code>length()</code>, равна <code>0</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_isempty"><code>isEmpty()</code></h5>
<div class="paragraph">
<p>Класс <code>String</code> имеет специальный метод, который позволяет проверить строку на пустоту - <code>isEmpty()</code>. Если строка пуста, он возвращает <code>true</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String s = ""; // строка не указывает на объект
if (s.length() == 0) {
    System.out.println("String is empty");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Переменная <code>String</code> может не указывать на какой-либо объект и иметь значение <code>null</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String s = null; // строка не указывает на объект
if (s == null) {
    System.out.println("String is null");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Значение <code>null</code> не эквивалентно пустой строке. Например, в следующем случае мы столкнемся с ошибкой выполнения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String s = null; // строка не указывает на объект
if (s.length() == 0) { // NullPointerException
    System.out.println("String is empty");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так как переменная не указывает ни на какой объект <code>String</code>, то соответственно мы не можем обращаться к методам объекта <code>String</code>. Чтобы избежать подобных ошибок, можно предварительно проверять строку на <code>null</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String s = null; // строка не указывает на объект
if (s != null &amp;&amp; s.length() == 0) {
    System.out.println("String is empty");
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_concat"><code>concat()</code></h5>
<div class="paragraph">
<p>Для объединения строк измользуют метод <code>concat()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str1 = "Java";
String str2 = "Hello";
str2 = str2.concat(str1); // HelloJava</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>concat()</code> принимает строку, с которой надо объединить вызывающую строку, и возвращает соединенную строку.</p>
</div>
</div>
<div class="sect4">
<h5 id="_join"><code>join()</code></h5>
<div class="paragraph">
<p>Для объединения строт используют метод <code>join()</code>, который позволяет объединить строки с учетом разделителя. Например, выше две строки сливались в одно слово <code>"HelloJava"</code>, но в идеале мы бы хотели, чтобы две подстроки были разделены пробелом. И для этого используем метод <code>join()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str1 = "Java";
String str2 = "Hello";
String str3 = String.join(" ", str2, str1); // Hello Java</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>join()</code> является статическим. Первым параметром идет разделитель, которым будут разделяться подстроки в общей строке, а все последующие параметры передают через запятую произвольный набор объединяемых подстрок - в данном случае две строки, хотя их может быть и больше.</p>
</div>
</div>
<div class="sect4">
<h5 id="_charat"><code>charAt()</code></h5>
<div class="paragraph">
<p>Для извлечения символов по индексу в классе <code>String</code> определен метод <code>charAt()</code>. Он принимает индекс, по которому надо получить символов, и возвращает извлеченный символ:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str = "Java";
char c = str.charAt(2);
System.out.println(c); // v</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как и в массивах индексация начинается с нуля.</p>
</div>
</div>
<div class="sect4">
<h5 id="_getchars"><code>getChars()</code></h5>
<div class="paragraph">
<p>Для извлечения группы символов или подстроку, то можно использовать метод <code>getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</code>. Он принимает следующие параметры:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>srcBegin</code> индекс в строке, с которого начинается извлечение символов</p>
</li>
<li>
<p><code>srcEnd</code> индекс в строке, до которого идет извлечение символов</p>
</li>
<li>
<p><code>dst</code> массив символов, в который будут извлекаться символы</p>
</li>
<li>
<p><code>dstBegin</code> индекс в массиве <code>dst</code>, с которого надо добавлять извлеченные из строки символы</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str = "Hello world!";
int start = 6;
int end = 11;
char[] dst=new char[end - start];
str.getChars(start, end, dst, 0);
System.out.println(dst); // world</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_equals_и_equalsignorecase"><code>equals()</code> и <code>equalsIgnoreCase()</code></h5>
<div class="paragraph">
<p>Для сравнения строк используются методы <code>equals()</code> (с учетом регистра) и <code>equalsIgnoreCase()</code> (без учета регистра). Оба метода в качестве параметра принимают строку, с которой надо сравнить:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str1 = "Hello";
String str2 = "hello";

System.out.println(str1.equals(str2)); // false
System.out.println(str1.equalsIgnoreCase(str2)); // true</code></pre>
</div>
</div>
<div class="paragraph">
<p>В отличие от сравнения числовых и других данных примитивных типов для строк не применяется знак равенства <code>==.</code> Вместо него надо использовать метод <code>equals()</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_regionmatches"><code>regionMatches()</code></h5>
<div class="paragraph">
<p>Еще один специальный метод <code>regionMatches()</code> сравнивает отдельные подстроки в рамках двух строк. Он имеет следующие формы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">boolean regionMatches(int toffset, String other, int oofset, int len)
boolean regionMatches(boolean ignoreCase, int toffset, String other, int oofset, int len)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод принимает следующие параметры:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ignoreCase</code> надо ли игнорировать регистр символов при сравнении. Если значение <code>true</code>, регистр игнорируется</p>
</li>
<li>
<p><code>toffset</code> начальный индекс в вызывающей строке, с которого начнется сравнение</p>
</li>
<li>
<p><code>other</code> строка, с которой сравнивается вызывающая</p>
</li>
<li>
<p><code>oofset</code> начальный индекс в сравниваемой строке, с которого начнется сравнение</p>
</li>
<li>
<p><code>len</code> количество сравниваемых символов в обеих строках</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Используем метод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str1 = "Hello world";
String str2 = "I work";
boolean result = str1.regionMatches(6, str2, 2, 3);
System.out.println(result); // true</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае метод сравнивает 3 символа с 6-го индекса первой строки (<code>"wor"</code>) и 3 символа со 2-го индекса второй строки (<code>"wor"</code>). Так как эти подстроки одинаковы, то возвращается <code>true</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_compareto_и_comparetoignorecase"><code>compareTo()</code> и <code>compareToIgnoreCase()</code></h5>
<div class="paragraph">
<p>Методы <code>compareTo()</code> и <code>compareToIgnoreCase()</code> позволяют сравнить две строки, но при этом они также позволяют узнать больше ли одна строка, чем другая или нет. Если возвращаемое значение больше <code>0</code>, то первая строка больше второй, если меньше нуля, то, наоборот, вторая больше первой. Если строки равны, то возвращается <code>0</code>.</p>
</div>
<div class="paragraph">
<p>Для определения больше или меньше одна строка, чем другая, используется лексикографический порядок. То есть, например, строка <code>"A"</code> меньше, чем строка <code>"B"</code>, так как символ <code>'A'</code> в алфавите стоит перед символом <code>'B'</code>. Если первые символы строк равны, то в расчет берутся следующие символы. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str1 = "hello";
String str2 = "world";
String str3 = "hell";

System.out.println(str1.compareTo(str2)); // -15 -&gt; str1 меньше чем strt2
System.out.println(str1.compareTo(str3)); // 1 -&gt; str1 больше чем str3</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_indexof_и_lastindexof"><code>indexOf()</code> и <code>lastIndexOf()</code></h5>
<div class="paragraph">
<p>Метод <code>indexOf()</code> находит индекс первого вхождения подстроки в строку, а метод <code>lastIndexOf()</code> - индекс последнего вхождения. Если подстрока не будет найдена, то оба метода возвращают <code>-1</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str = "Hello world";
int index1 = str.indexOf('l'); // 2
int index2 = str.indexOf("wo"); // 6
int index3 = str.lastIndexOf('l'); // 9</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_startswith_и_endswith"><code>startsWith()</code> и <code>endsWith()</code></h5>
<div class="paragraph">
<p>Метод <code>startsWith()</code> позволяют определить начинается ли строка с определенной подстроки, а метод <code>endsWith()</code> позволяет определить заканчивается строка на определенную подстроку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str = "myfile.exe";
boolean start = str.startsWith("my"); // true
boolean end = str.endsWith("exe"); // true</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_replace"><code>replace()</code></h5>
<div class="paragraph">
<p>Метод <code>replace()</code> позволяет заменить в строке одну последовательность символов на другую:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str = "Hello world";
String replStr1 = str.replace('l', 'd'); // Heddo world
String replStr2 = str.replace("Hello", "Bye"); // Bye world</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_trim"><code>trim()</code></h5>
<div class="paragraph">
<p>Метод <code>trim()</code> позволяет удалить начальные и конечные пробелы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str = "  hello world  ";
str = str.trim(); // "hello world"</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_substring"><code>substring()</code></h5>
<div class="paragraph">
<p>Метод <code>substring()</code> возвращает подстроку, начиная с определенного индекса до конца или до определенного индекса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str = "Hello world";
String substr1 = str.substring(6); // "world"
String substr2 = str.substring(3,5); // "lo"</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tolowercase_и_touppercase"><code>toLowerCase()</code> и <code>toUpperCase()</code></h5>
<div class="paragraph">
<p>Метод <code>toLowerCase()</code> переводит все символы строки в нижний регистр, а метод <code>toUpperCase()</code> - в верхний</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str = "Hello World";
System.out.println(str.toLowerCase()); // hello world
System.out.println(str.toUpperCase()); // HELLO WORLD</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_split"><code>split()</code></h5>
<div class="paragraph">
<p>Метод <code>split()</code> позволяет разбить строку на подстроки по определенному разделителю. Разделитель - какой-нибудь символ или набор символов передается в качестве параметра в метод. Например, разобьем текст на отдельные слова:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String text = "FIFA will never regret it";
String[] words = text.split(" ");
for (String word : words) {
    System.out.println(word);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае строка будет разделяться по пробелу. Консольный вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="output">FIFA
will
never
regret
it</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_регулярные_выражения">3.10. Регулярные выражения</h3>
<div class="paragraph">
<p>Регулярные выражения представляют мощный инструмент для обработки строк. Регулярные выражения позволяют задать шаблон, которому должна соответствовать строка или подстрока.</p>
</div>
<div class="paragraph">
<p>Большая часть функциональности по работе с регулярными выражениями в <strong>Java</strong> сосредоточена в пакете <code>java.util.regex</code>.</p>
</div>
<div class="paragraph">
<p>Само регулярное выражение представляет шаблон для поиска совпадений в строке. Для задания подобного шаблона и поиска подстрок в строке, которые удовлетворяют данному шаблону, в <strong>Java</strong> определены классы <code>Pattern</code> и <code>Matcher</code>.</p>
</div>
<div class="sect3">
<h4 id="_pattern">3.10.1. <code>Pattern</code></h4>
<div class="sect4">
<h5 id="_matches"><code>matches()</code></h5>
<div class="paragraph">
<p>Для простого поиска соответствий в классе <code>Pattern</code> определен статический метод <code>matches(String pattern, CharSequence input)</code>. Данный метод возвращает <code>true</code>, если последовательность символов <code>input</code> полностью соответствует шаблону строки <code>pattern</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.regex.Pattern;

public class StringsApp {
    public static void main(String[] args) {
        String input = "Hello";
        boolean found = Pattern.matches("Hello", input);
        if(found) {
            System.out.println("Найдено");
        } else {
            System.out.println("Не найдено");
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_split_2"><code>split()</code></h5>
<div class="paragraph">
<p>С помощью метода <code>split()</code> класса <code>Pattern</code> можно разделить строку на массив подстрок по определенному разделителю. Например, мы хотим выделить из строки отдельные слова:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.regex.Pattern;

public class StringsApp {
    public static void main(String[] args) {
        String input = "Hello Java! Hello JavaScript! JavaSE.";
        Pattern pattern = Pattern.compile("[ ,.!?]");
        String[] words = pattern.split(input);
        for (String word : words) {
            System.out.println(word);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>И консоль выведет набор слов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Hello
Java

Hello
JavaScript

JavaSE</code></pre>
</div>
</div>
<div class="paragraph">
<p>При этом все символы-разделители удаляются. Однако, данный способ разбивки не идеален: у нас остаются некоторые пробелы, которые расцениваются как лексемы, а не как разделители. Для более точной и изощренной разбивки нам следует применять элементы регулярных выражений. Так, заменим шаблон на следующий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Pattern pattern = Pattern.compile("\\s*(\\s|,|!|\\.)\\s*");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь у нас останутся только слова:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Hello
Java
Hello
JavaScript
JavaSE
8</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_matcher">3.10.2. <code>Matcher</code></h4>
<div class="paragraph">
<p>Но, как правило, для поиска соответствий применяется другой способ - использование класса <code>Matcher</code>.</p>
</div>
<div class="paragraph">
<p>Используем класс <code>Matcher</code>. Для этого вначале надо создать объект <code>Pattern</code> с помощью статического метода <code>compile()</code>, который позволяет установить шаблон:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Pattern pattern = Pattern.compile("Hello");</code></pre>
</div>
</div>
<div class="paragraph">
<p>В качестве шаблона выступает строка <code>"Hello"</code>. Метод <code>compile()</code> возвращает объект <code>Pattern</code>, который мы затем можем использовать в программе.</p>
</div>
<div class="paragraph">
<p>В классе <code>Pattern</code> также определен метод <code>matcher()</code>, который в качестве параметра принимает строку, где надо проводить поиск, и возвращает объект <code>Matcher</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String input = "Hello world! Hello Java!";
Pattern pattern = Pattern.compile("hello");
Matcher matcher = pattern.matcher(input);</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_matches_2"><code>matches()</code></h5>
<div class="paragraph">
<p>Затем у объекта <code>Matcher</code> вызывается метод <code>matches()</code> для поиска соответствий шаблону в тексте:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class StringsApp {
    public static void main(String[] args) {
        String input = "Hello";
        Pattern pattern = Pattern.compile("Hello");
        Matcher matcher = pattern.matcher(input);
        boolean found = matcher.matches();
        if (found) {
            System.out.println("Найдено");
        } else {
            System.out.println("Не найдено");
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_find_и_group"><code>find()</code> и <code>group()</code></h5>
<div class="paragraph">
<p>Рассмотрим более функциональный пример с нахождением не полного соответствия, а отдельных совпадений в строке:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class StringsApp {
    public static void main(String[] args) {
        String input = "Hello Java! Hello JavaScript! JavaSE.";
        Pattern pattern = Pattern.compile("Java(\\w*)");
        Matcher matcher = pattern.matcher(input);
        while (matcher.find()) {
            System.out.println(matcher.group());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Допустим, мы хотим найти в строке все вхождения слова <code>Java</code>. В исходной строке это три слова: <code>"Java"</code>, <code>"JavaScript"</code> и <code>"JavaSE"</code>. Для этого применим шаблон <code>"Java(\\w*)"</code>. Данный шаблон использует синтаксис регулярных выражений. Слово <code>"Java"</code> в начале говорит о том, что все совпадения в строке должны начинаться на <code>Java</code>. Выражение <code>(\\w*)</code> означает, что после <code>"Java"</code> в совпадении может находиться любое количество алфавитно-цифровых символов. Выражение <code>\w</code> означает алфавитно-цифровой символ, а звездочка после выражения указывает на неопределенное их количество - их может быть один, два, три или вообще не быть. И чтобы java не рассматривала <code>\w</code> как эскейп-последовательность, как <code>\n</code>, то выражение экранируется еще одним слешем.</p>
</div>
<div class="paragraph">
<p>Далее применяется метод <code>find()</code> класса <code>Matcher</code>, который позволяет переходить к следующему совпадению в строке. То есть первый вызов этого метода найдет первое совпадение в строке, второй вызов найдет второе совпадение и т.д. То есть с помощью цикла <code>while(matcher.find())</code> мы можем пройтись по всем совпадениям. Каждое совпадение мы можем получить с помощью метода <code>matcher.group()</code>. В итоге программа выдаст следующий результат:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Java
JavaScript
JavaSE</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_replaceall"><code>replaceAll()</code></h5>
<div class="paragraph">
<p>Можно сделать замену всех совпадений с помощью метода <code>replaceAll()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String input = "Hello Java! Hello JavaScript! JavaSE.";
Pattern pattern = Pattern.compile("Java(\\w*)");
Matcher matcher = pattern.matcher(input);
String newStr = matcher.replaceAll("HTML");
System.out.println(newStr); // Hello HTML! Hello HTML! HTML.</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_string">3.10.3. <code>String</code></h4>
<div class="paragraph">
<p>Некоторые методы класса <code>String</code> принимают регулярные выражения и используют их для выполнения операций над строками.</p>
</div>
<div class="sect4">
<h5 id="_split_3"><code>split()</code></h5>
<div class="paragraph">
<p>Для разделения строки на подстроки применяется метод <code>split()</code>. В качестве параметра он может принимать регулярное выражение, которое представляет критерий разделения строки.</p>
</div>
<div class="paragraph">
<p>Например, разделим предложение на слова:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String text = "FIFA will never regret it";
String[] words = text.split("\\s*(\\s|,|!|\\.)\\s*");
for (String word : words) {
    System.out.println(word);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для разделения применяется регулярное выражение <code>"\\s*(\\s|,|!|\\.)\\s*"</code>. Подвыражние <code>"\\s"</code> по сути представляет пробел. Звездочка указывает, что символ может присутствовать от 0 до бесконечного количества раз. То есть добавляем звездочку и мы получаем неопределенное количество идущих подряд пробелов - <code>"\\s*"</code> (то есть неважно, сколько пробелов между словами). Причем пробелы может вообще не быть. В скобках указывает группа выражений, которая может идти после неопределенного количества пробелов. Группа позволяет нам определить набо значений через вертикальную черту, и подстрока должна соответствовать одному из этих значений. То есть в группе <code>"\\s|,|!|\\."</code> подстрока может соответствовать пробелу, запятой, восклицательному знаку или точке. Причем поскольку точка представляет специальную последовательность, то, чтобы указать, что мы имеем в виду имеено знак точки, а не специальную последовательность, перед точкой ставим слеши.</p>
</div>
</div>
<div class="sect4">
<h5 id="_matches_3"><code>matches()</code></h5>
<div class="paragraph">
<p>Еще один метод класса <code>String</code> - <code>matches()</code> принимает регулярное выражение и возвращает <code>true</code>, если строка соответствует этому выражению. Иначе возвращает <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Например, проверим, соответствует ли строка номеру телефона:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String input = "+12343454556";
boolean result = input.matches("(\\+*)\\d{11}");
if (result == true) {
    System.out.println("It is a phone number");
} else {
    System.out.println("It is not a phone number!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае в регулярном выражение сначала определяется группа <code>"(\\+*)"</code>. То есть вначале может идти знак плюса, но также он может отсутствовать. Далее смотрим, соответствуют ли последующие 11 символов цифрам. Выражение <code>"\\d"</code> представляет цифровой символ, а число в фигурных скобках - <code>{11}</code> - сколько раз данный тип символов должен повторяться. То есть мы ищем строку, где вначале может идти знак плюс (или он может отсутствовать), а потом идет 11 цифровых символов.</p>
</div>
</div>
<div class="sect4">
<h5 id="_replaceall_2"><code>replaceAll()</code></h5>
<div class="paragraph">
<p>Также надо отметить, что в классе <code>String</code> также имеется метод <code>replaceAll()</code> с заменой всех выражений, удовлетворяющих регулярному выражению:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String input = "Hello Java! Hello JavaScript! JavaSE.";
String myStr =input.replaceAll("Java(\\w*)", "HTML");
System.out.println(myStr); // Hello HTML! Hello HTML! HTML.</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_java_object_oriented_programming">4. Java Object-Oriented Programming</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_концепции_ооп">4.1. Концепции ООП</h3>
<div class="paragraph">
<p><strong>Объектно-ориентированное программирование</strong> - это парадигма, которая предоставляет множество концепций, таких как наследование, полимофизм и т.д.</p>
</div>
<div class="paragraph">
<p><strong>Simula</strong> считается первым объектно-ориентированным языком программирования.</p>
</div>
<div class="paragraph">
<p>Парадигма программирования, в которой все представлено в виде объекта, называется истинно объектно-ориентированным языком программирования.</p>
</div>
<div class="paragraph">
<p><strong>Smalltalk</strong> считается первым истинным объектно-ориентированным языком программирования.</p>
</div>
<div class="paragraph">
<p>Популярными объектно-ориентированными языками являются:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Java</strong></p>
</li>
<li>
<p><strong>C#</strong></p>
</li>
<li>
<p><strong>PHP</strong></p>
</li>
<li>
<p><strong>Python</strong></p>
</li>
<li>
<p><strong>C++</strong></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_ооп">4.1.1. ООП</h4>
<div class="paragraph">
<p><strong>Объект</strong> представляет собой <strong>реальную сущность</strong> из реального мира, например: BMW X5, Boeing 737, Parker Jotter (ручка).</p>
</div>
<div class="paragraph">
<p><strong>Объектно-ориентированное программирование</strong> - это методология или парадигма для разработки программы с использованием классов и объектов. Это упрощает разработку и обслуживание программного обеспечения, предоставляя некоторые концепции:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Объект</strong>  (<strong>Object</strong>)</p>
</li>
<li>
<p><strong>Класс</strong> (<strong>Class</strong>)</p>
</li>
<li>
<p><strong>Наследование</strong> (<strong>Inheritance</strong>)</p>
</li>
<li>
<p><strong>Полиморфизм</strong> (<strong>Polymorphism</strong>)</p>
</li>
<li>
<p><strong>Абстракция</strong> (<strong>Abstraction</strong>)</p>
</li>
<li>
<p><strong>Инкапсуляция</strong> (<strong>Encapsulation</strong>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="/assets/img/java/core/oop/java-oops.png" alt="Java OOPs Concepts"></span></p>
</div>
<div class="paragraph">
<p>Помимо этих концепций, есть несколько других терминов, которые используются в объектно-ориентированном дизайне:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Связность</strong> (<strong>Coupling</strong>), <strong>Единство</strong> (<strong>Cohesion</strong>)</p>
</li>
<li>
<p><strong>Ассоциация</strong> (<strong>Association</strong>)</p>
</li>
<li>
<p><strong>Агрегация</strong> (<strong>Aggregation</strong>), <strong>Композиция</strong> (<strong>Composition</strong>)</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_object">Object</h5>
<div class="paragraph">
<p>Любая сущность, которая имеет <strong>состояние</strong> (<strong>state</strong>) и <strong>поведение</strong> (<strong>behavior</strong>), называется <strong>объектом</strong>. Например: овчарка, Apple MacBook Pro 13 Touch Bar 2019, Huawei Mate P10 Lite . Это может быть как физический предмет, так и нет.</p>
</div>
<div class="paragraph">
<p><strong>Объект</strong> может быть определен как <strong>экземпляр класса</strong>. Объект содержит адрес и занимает некоторое место в памяти. Объекты могут взаимодействовать, но не знать состояния и реализации друг друга. Единственная необходимая вещь - это <strong>контракт взаимодействия</strong>.</p>
</div>
<div class="paragraph">
<p>Пример: <code>собака</code> - это объект, потому что она имеет такие состояния, как <code>цвет</code>, <code>имя</code>, <code>порода</code>, а также поведение, такое как <code>вилять хвостом</code>, <code>лаять</code>, <code>есть</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_class">Class</h5>
<div class="paragraph">
<p><strong>Класс</strong> - это определенный пользователем шаблон или прототип, из которого создаются объекты. Он представляет собой набор <strong>свойств</strong> или <strong>методов</strong>, которые являются общими для всех объектов одного типа.</p>
</div>
</div>
<div class="sect4">
<h5 id="_inheritance">Inheritance</h5>
<div class="paragraph">
<p>Когда один объект приобретает все свойства и поведение родительского объекта, то это называется <strong>наследованием</strong>.</p>
</div>
<div class="paragraph">
<p><strong>Наследование</strong> обеспечивает повторное использование кода.</p>
</div>
<div class="paragraph">
<p><strong>Наследование</strong> используется для достижения полиморфизма во время выполнения.</p>
</div>
</div>
<div class="sect4">
<h5 id="_polymorphism">Polymorphism</h5>
<div class="paragraph">
<p>Если одна задача выполняется разными способами, это называется <strong>полиморфизмом</strong>.</p>
</div>
<div class="paragraph">
<p>В Java используется <strong>перегрузка</strong> и <strong>переопределение</strong> методов для достижения полиморфизма.</p>
</div>
<div class="paragraph">
<p>Например, когда вызвать метод <code>говорить</code>, то: <code>кошка</code> говорит <code>мяу</code>, <code>собака</code> лает <code>гав</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_abstraction">Abstraction</h5>
<div class="paragraph">
<p>Сокрытие внутренних деталей и предоставление функциональности называется <strong>абстракцией</strong>. Например, автомобиль, нам не обязательно знать устройство автомобиля, нам достаточно знаний того, что нам позволяет им управлять (руль, педали и т.д.).</p>
</div>
<div class="paragraph">
<p>В Java используется <strong>абстрактный класс</strong> и <strong>интерфейс</strong> для достижения абстракции.</p>
</div>
</div>
<div class="sect4">
<h5 id="_encapsulation">Encapsulation</h5>
<div class="paragraph">
<p><strong>Связывание</strong> (или упаковка) кода и данных в единый блок называется <strong>инкапсуляцией</strong>. Например, капсула, имеет одну оболочку, которая содержит различные лекарства.</p>
</div>
<div class="paragraph">
<p><strong>Java Class</strong> является примером инкапсуляции.</p>
</div>
<div class="paragraph">
<p><strong>Java Bean</strong> является полностью инкапсулированным классом, потому что все члены данных здесь являются закрытыми.</p>
</div>
</div>
<div class="sect4">
<h5 id="_coupling">Coupling</h5>
<div class="paragraph">
<p><strong>Связность</strong> относится к знаниям/информации/зависимости одного класса о другом классе. Если у класса есть подробная информация о другом классе, существует <strong>strong coupling</strong>.</p>
</div>
<div class="paragraph">
<p>В Java используются <code>private</code>, <code>protected</code>, <code>public</code> модификаторы для отображения уровня видимости класса, метода и поля.</p>
</div>
<div class="paragraph">
<p>Можно использовать интерфейсы для <strong>weak coupling</strong>, потому что нет конкретной реализации.</p>
</div>
</div>
<div class="sect4">
<h5 id="_cohesion">Cohesion</h5>
<div class="paragraph">
<p><strong>Сплоченность</strong> относится к уровню компонента, который выполняет одну четко определенную задачу. Одна четко определенная задача выполняется <strong>highly cohesive</strong> методом. <strong>weakly cohesive</strong> метод разделит задачу на отдельные части.</p>
</div>
<div class="paragraph">
<p>Например: пакет <code>java.io</code> представляет собой <strong>highly cohesive</strong> пакет, поскольку он имеет связанные с вводом/выводом классы и интерфейс. Тем не менее, пакет <code>java.util</code> является <strong>weakly cohesive</strong> пакетом, потому что он имеет несвязанные классы и интерфейсы.</p>
</div>
</div>
<div class="sect4">
<h5 id="_association">Association</h5>
<div class="paragraph">
<p><strong>Ассоциация</strong> представляет отношения между объектами. Здесь один объект может быть связан с одним или несколькими объектами. Между объектами может быть четыре типа связи:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>One to One</code></p>
</li>
<li>
<p><code>One to Many</code></p>
</li>
<li>
<p><code>Many to One</code></p>
</li>
<li>
<p><code>Many to Many</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Например, одна страна может иметь одного президента (<code>One to One</code>), а президент может иметь много министров (<code>One to Many</code>). Кроме того, у многих членов парламента может быть один президент (<code>Many to One</code>), а у многих министров может быть много департаментов (<code>Many to Many</code>).</p>
</div>
<div class="paragraph">
<p><strong>Ассоциация</strong> может быть:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>undirectional</code></p>
</li>
<li>
<p><code>bidirectional</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Ассоциация</strong> достигается с помощью:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Inheritance</code></p>
</li>
<li>
<p><code>Aggregation</code></p>
</li>
<li>
<p><code>Composition</code></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_aggregation">Aggregation</h6>
<div class="paragraph">
<p><strong>Агрегация</strong> - это способ достижения ассоциации. Агрегация представляет собой отношение, в котором один объект содержит другие объекты как часть своего состояния.</p>
</div>
<div class="paragraph">
<p><strong>Агрегация</strong> представляет <strong>weak relationship</strong> между объектами.</p>
</div>
<div class="paragraph">
<p><strong>Агрегация</strong> также называется связью <strong>has-a</strong> в Java. Мол, наследование представляет собой отношения <strong>is-a</strong> .</p>
</div>
<div class="paragraph">
<p><strong>Агрегация</strong> еще один способ повторного использования объектов.</p>
</div>
</div>
<div class="sect5">
<h6 id="_composition">Composition</h6>
<div class="paragraph">
<p><strong>Композиция</strong> представляет отношение, в котором один объект содержит другие объекты как часть своего состояния.</p>
</div>
<div class="paragraph">
<p><strong>Композиция</strong> также является способом достижения ассоциации.</p>
</div>
<div class="paragraph">
<p>Существует <strong>strong relationship</strong> между содержащим объектом и зависимым объектом. Это состояние, в котором содержащиеся объекты не имеют самостоятельного существования. Если вы удалите родительский объект, все дочерние объекты будут удалены автоматически.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_преимущество_ооп_над_процедурно_ориентированным_языком_программирования">4.1.2. Преимущество ООП над процедурно-ориентированным языком программирования</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>ООП</strong> облегчает разработку и сопровождение, в то время как в языке программирования, ориентированного на процедуры, нелегко управлять, если код увеличивается с увеличением размера проекта.</p>
</li>
<li>
<p><strong>ООП</strong> обеспечивает скрытие данных, тогда как в языке программирования, ориентированного на процедуры, глобальные данные могут быть доступны из любого места.</p>
</li>
<li>
<p><strong>ООП</strong> дает возможность имитировать события в реальном мире гораздо более эффективно. Мы можем обеспечить решение проблемы с реальными словами, если мы используем язык объектно-ориентированного программирования.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_в_чем_разница_между_object_oriented_языком_программирования_и_object_based_языком_программирования">4.1.3. В чем разница между <strong>object-oriented</strong> языком программирования и <strong>object-based</strong> языком программирования?</h4>
<div class="paragraph">
<p><strong>Object-based</strong> язык программирования следует всем функциям ООП, кроме наследования. <strong>JavaScript</strong> и <strong>VBScript</strong> являются примерами <strong>object-based</strong> языков программирования.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_классы_и_объекты">4.2. Классы и объекты</h3>
<div class="paragraph">
<p><strong>Java</strong> является объектно-ориентированным языком, поэтому такие понятия как "класс" и "объект" играют в нем ключевую роль. Любую программу на <strong>Java</strong> можно представить как набор взаимодействующих между собой объектов.</p>
</div>
<div class="paragraph">
<p>Шаблоном или описанием объекта является <strong>класс</strong>, а <strong>объект</strong> представляет экземпляр этого класса. Можно еще провести следующую аналогию. У нас у всех есть некоторое представление о человеке - наличие двух рук, двух ног, головы, туловища и т.д. Есть некоторый шаблон - этот шаблон можно назвать классом. Реально же существующий человек (фактически экземпляр данного класса) является объектом этого класса.</p>
</div>
<div class="paragraph">
<p>Класс определяется с помощью ключевого слова <code>сlass</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person {
    // тело класса
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае класс называется <code>Person</code>. После названия класса идут фигурные скобки, между которыми помещается тело класса - то есть его поля и методы.</p>
</div>
<div class="paragraph">
<p>Вся функциональность класса представлена <strong>членами класса</strong> - <strong>полями</strong> (<strong>fields</strong> - переменные класса), которые хранят состояние объекта, и <strong>методами</strong> (<strong>methods</strong>), которые определяют поведение объекта. Например, класс <code>Person</code>, который представляет человека, мог бы иметь следующее определение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person {
    String name; // имя
    int age; // возраст

    void displayInfo() {
        System.out.printf("Name: %s \tAge: %d\n", name, age);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В классе <code>Person</code> определены два поля: <code>name</code> представляет имя человека, а <code>age</code> - его возраст. И также определен метод <code>displayInfo()</code>, который ничего не возвращает и просто выводит эти данные на консоль.</p>
</div>
<div class="paragraph">
<p>Теперь используем данный класс. Для этого определим следующую программу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person tom;
    }
}

class Person {
    String name; // имя
    int age; // возраст

    void displayInfo() {
        System.out.printf("Name: %s \tAge: %d\n", name, age);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как правило, классы определяются в разных файлах. В данном случае для простоты мы определяем два класса в одном файле. Стоит отметить, что в этом случае только один класс может иметь модификатор <code>public</code> (в данном случае это класс <code>Program</code>), а сам файл кода должен называться по имени этого класса, то есть в данном случае файл должен называться <code>Program.java</code>.</p>
</div>
<div class="paragraph">
<p>Класс представляет новый тип, поэтому мы можем определять переменные, которые представляют данный тип. Так, здесь в методе <code>main()</code> определена переменная <code>tom</code>, которая представляет класс <code>Person</code>. Но пока эта переменная не указывает ни на какой объект и по умолчанию она имеет значение <code>null</code>. По большому счету мы ее пока не можем использовать, поэтому вначале необходимо создать объект класса <code>Person</code>.</p>
</div>
<div class="sect3">
<h4 id="_конструкторы">4.2.1. Конструкторы</h4>
<div class="paragraph">
<p>Кроме обычных методов классы могут определять специальные методы, которые называются <strong>конструкторами</strong> (<strong>constructors</strong>). Конструкторы вызываются при создании нового объекта данного класса. Конструкторы выполняют инициализацию объекта.</p>
</div>
<div class="paragraph">
<p>Если в классе не определено ни одного конструктора, то для этого класса автоматически создается <strong>конструктор без параметров</strong> (<strong>default constructor</strong>).</p>
</div>
<div class="paragraph">
<p>Выше определенный класс <code>Person</code> не имеет никаких конструкторов. Поэтому для него автоматически создается конструктор по умолчанию, который мы можем использовать для создания объекта <code>Person</code>. В частности, создадим один объект:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person tom = new Person(); // создание объекта
        tom.displayInfo();

        tom.name = "Tom"; // изменение имени
        tom.age = 34; // изменение возраста
        tom.displayInfo();
    }
}

class Person {
    String name; // имя
    int age; // возраст

    void displayInfo() {
        System.out.printf("Name: %s \tAge: %d\n", name, age);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для создания объекта <code>Person</code> используется выражение <code>new Person()</code>. Оператор <code>new</code> выделяет память для объекта <code>Person</code>. И затем вызывается конструктор по умолчанию, который не принимает никаких параметров. В итоге после выполнения данного выражения в памяти будет выделен участок, где будут храниться все данные объекта <code>Person</code>. А переменная <code>tom</code> получит ссылку на созданный объект.</p>
</div>
<div class="paragraph">
<p>Если конструктор не инициализирует значения переменных объекта, то они получают значения по умолчанию. Для переменных числовых типов это число <code>0</code>, а для типа <code>String</code> и других классов - это значение <code>null</code> (то есть фактически отсутствие значения).</p>
</div>
<div class="paragraph">
<p>После создания объекта мы можем обратиться к переменным объекта <code>Person</code> через переменную <code>tom</code> и установить или получить их значения, например, <code>tom.name = "Tom"</code>.</p>
</div>
<div class="paragraph">
<p>Если необходимо, что при создании объекта производилась какая-то логика, например, чтобы поля класса получали какие-то определенные значения, то можно определить в классе свои конструкторы. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person bob = new Person(); // вызов первого конструктора без параметров
        bob.displayInfo();

        Person tom = new Person("Tom"); // вызов второго конструктора с одним параметром
        tom.displayInfo();

        Person sam = new Person("Sam", 25); // вызов третьего конструктора с двумя параметрами
        sam.displayInfo();
    }
}

class Person {
    String name; // имя
    int age; // возраст

    Person() {
        name = "Undefined";
        age = 18;
    }

    Person(String n) {
        name = n;
        age = 18;
    }

    Person(String n, int a) {
        name = n;
        age = a;
    }

    void displayInfo() {
        System.out.printf("Name: %s \tAge: %d\n", name, age);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь в классе определено три коструктора, каждый из которых принимает различное количество параметров и устанавливает значения полей класса.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ключевое_слово_this">4.2.2. Ключевое слово <code>this</code></h4>
<div class="paragraph">
<p>Ключевое слово <code>this</code> представляет ссылку на текущий экземпляр класса. Через это ключевое слово мы можем обращаться к переменным, методам объекта, а также вызывать его конструкторы. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person undef = new Person();
        undef.displayInfo();

        Person tom = new Person("Tom");
        tom.displayInfo();

        Person sam = new Person("Sam", 25);
        sam.displayInfo();
    }
}

class Person {
    String name; // имя
    int age; // возраст

    Person() {
        this("Undefined", 18);
    }

    Person(String name) {
        this(name, 18);
    }

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void displayInfo() {
        System.out.printf("Name: %s \tAge: %d\n", name, age);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В третьем конструкторе параметры называются так же, как и поля класса. И чтобы разграничить поля и параметры, применяется ключевое слово <code>this</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">this.name = name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так, в данном случае указываем, что значение параметра <code>name</code> присваивается полю <code>name</code>.</p>
</div>
<div class="paragraph">
<p>Кроме того, у нас три конструктора, которые выполняют идентичные действия: устанавливают поля <code>name</code> и <code>age</code>. Чтобы избежать повторов, с помощью <code>this</code> можно вызвать один из конструкторов класса и передать для его параметров необходимые значения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Person(String name) {
    this(name, 18);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В итоге результат программы будет тот же, что и в предыдущем примере.</p>
</div>
</div>
<div class="sect3">
<h4 id="_инициализаторы">4.2.3. Инициализаторы</h4>
<div class="paragraph">
<p>Кроме конструктора начальную инициализацию объекта вполне можно было проводить с помощью <strong>инициализатора</strong> (<strong>initializer</strong>) объекта. Инициализатор выполняется до любого конструктора. То есть в инициализатор мы можем поместить код, общий для всех конструкторов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person undef = new Person();
        undef.displayInfo();

        Person tom = new Person("Tom");
        tom.displayInfo();
    }
}

class Person {
    String name; // имя
    int age; // возраст

    /*начало блока инициализатора*/
    {
        name = "Undefined";
        age = 18;
    }
    /*конец блока инициализатора*/

    Person() {
    }

    Person(String name) {
        this.name = name;
    }

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void displayInfo() {
        System.out.printf("Name: %s \tAge: %d\n", name, age);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_объекты_как_параметры_методов">4.3. Объекты как параметры методов</h3>
<div class="paragraph">
<p>Объекты классов, как и данные примитивных типов могут передаваться в методы. Однако в данном случае есть одна особенность - при передаче объектов в качестве значения передается копия ссылки на область в памяти, где рассположен этот объект. Рассмотрим небольшой пример. Пусть у нас есть следующий класс <code>Person</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person kate = new Person("Kate");
        System.out.println(kate.getName()); // "Kate"
        changeName(kate);
        System.out.println(kate.getName()); // "Alice"
    }

    static void changeName(Person p) {
        p.setName("Alice");
    }
}

class Person {
    private String name;

    Person(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь в метод <code>changeName</code> передается объект <code>Person</code>, у которого изменяется имя. Так как в метод будет передаваться копия ссылки на область памяти, в которой находится объект <code>Person</code>, то переменная <code>kate</code> и параметр <code>p</code> метода <code>changeName()</code> будут указывать на один и тот же объект в памяти. Поэтому после выполнения метода у объекта <code>kate</code>, который передается в метод, будет изменено имя с <code>"Kate"</code> на <code>"Alice"</code>.</p>
</div>
<div class="paragraph">
<p>От этого случая следует отличать другой случай:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person kate = new Person("Kate");
        System.out.println(kate.getName()); // "Kate"
        changePerson(kate);
        System.out.println(kate.getName()); // "Kate" - изменения не произошло, т.к. 'kate' хранит ссылку на старый объект
    }

    static void changePerson(Person p) {
        p = new Person("Alice"); // 'p' указывает на новый объект
        p.setName("Ann");
    }

    static void changeName(Person p) {
        p.setName("Alice");
    }
}

class Person {
    private String name;

    Person(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В метод <code>changePerson()</code> также передается копия ссылки на объект <code>Person</code>. Однако в самом методе мы изменяем не отдельные значения объекта, а пересоздаем объект с помощью конструктора и оператора <code>new</code>. В результате в памяти будет выделено новое место для нового объекта <code>Person</code>, и ссылка на этот объект будет присвоена параметру <code>p</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">static void changePerson(Person p) {
    p = new Person("Alice"); // 'p' указывает на новый объект
    p.setName("Ann"); // изменяется новый объект
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>То есть после создания нового объекта <code>Person</code> параметр <code>p</code> и переменная <code>kate</code> в методе <code>main()</code> будут хранить ссылки на разные объекты. Переменная <code>kate</code>, которая передавалась в метод, продолжит хранить ссылку на старый объект в памяти. Поэтому ее значение не меняется.</p>
</div>
</div>
<div class="sect2">
<h3 id="_пакеты">4.4. Пакеты</h3>
<div class="paragraph">
<p>Как правило, в <strong>Java</strong> классы объединяются в пакеты. Пакеты позволяют организовать классы логически в наборы. По умолчанию <strong>java</strong> уже имеет ряд встроенных пакетов, например, <code>java.lang</code>, <code>java.util</code>, <code>java.io</code> и т.д. Кроме того, пакеты могут иметь вложенные пакеты.</p>
</div>
<div class="paragraph">
<p>Организация классов в виде пакетов позволяет избежать конфликта имен между классами. Ведь нередки ситуации, когда разработчики называют свои классы одинаковыми именами. Принадлежность к пакету позволяет <strong>гарантировать однозначность имен</strong>.</p>
</div>
<div class="paragraph">
<p>Чтобы указать, что класс принадлежит определенному пакету, надо использовать директиву <code>package</code>, после которой указывается имя пакета:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">package название_пакета;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как правило, названия пакетов соответствуют физической структуре проекта, то есть организации каталогов, в которых находятся файлы с исходным кодом. А путь к файлам внутри проекта соответствует названию пакета этих файлов. Например, если классы принадлежат пакету <code>my.pack</code>, то эти классы помещаются в проекте в папку <code>my/pack</code>.</p>
</div>
<div class="paragraph">
<p>Классы необязательно определять в пакеты. Если для класса пакет не определен, то считается, что данный класс находится <strong>в пакете по умолчанию</strong>, который не имеет имени.</p>
</div>
<div class="paragraph">
<p>Например, создадим в папке для исходных файлов директорию <code>study</code>. В нем создадим файл <code>Program.java</code> со следующим кодом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">package study;

public class Program {
    public static void main(String[] args) {
        Person kate = new Person("Kate", 32);
        kate.displayInfo();
    }
}

class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void displayInfo() {
        System.out.printf("Name: %s \t Age: %d \n", name, age);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Директива <code>package study</code> в начале файла указывает, что классы <code>Program</code> и <code>Person</code>, которые здесь определены, принадлежат пакету <code>study</code>.</p>
</div>
<div class="paragraph">
<p>Когда мы работаем в среде разработке, то <strong>IDE</strong> берет на себя все вопросы компиляции пакетов и входящих в них файлов. Соответственно нам достаточно нажать на кнопку, и все будет готово. Однако если мы компилируем программу в командной строке, то мы можем столкнуться с некоторыми трудностями. Поэтому рассмотрим этот аспект.</p>
</div>
<div class="sect3">
<h4 id="_работа_с_пакетами_в_terminal">4.4.1. Работа с пакетами в <code>terminal</code></h4>
<div class="paragraph">
<p>Для компиляции программы вначале в командной строке/терминале с помощью команды <code>cd</code> перейдем к папке, где находится каталог <code>study</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="sh">cd C:\java</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например, в моем случае это каталог <code>C:\java</code> (то есть файл с исходным кодом расположен по пути <code>C:\java\study\Program.java</code>).</p>
</div>
<div class="paragraph">
<p>Для компиляции выполним команду</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="sh">javac study\Program.java</code></pre>
</div>
</div>
<div class="paragraph">
<p>После этого в папке <code>study</code> появятся скомпилированные файлы <code>Program.class</code> и <code>Person.class</code>. Для запуска программы выполним команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="sh">java study.Program</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_импорт_пакетов_и_классов">4.4.2. Импорт пакетов и классов</h4>
<div class="paragraph">
<p>Если нам надо использовать классы из других пакетов, то нам надо подключить эти пакеты и классы. Исключение составляют классы из пакета <code>java.lang</code> (например, <code>String</code>), которые подключаются в программу автоматически.</p>
</div>
<div class="paragraph">
<p>Например, класс <code>Scanner</code> находится в пакете <code>java.util</code>, поэтому мы можем получить к нему доступ следующим способом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">java.util.Scanner in = new java.util.Scanner(System.in);</code></pre>
</div>
</div>
<div class="paragraph">
<p>То есть указываем полный путь к файлу в пакете при создании его объекта. Однако такое нагромождение имен пакетов не всегда удобно, и в качестве альтернативы  можем импортировать пакеты и классы в проект с помощью директивы <code>import</code>, которая указывается после директивы <code>package</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">package study;

import java.util.Scanner; // импорт класса Scanner

public class Program {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Директива <code>import</code> указывается в самом начале кода, после чего идет имя подключаемого класса (в данном случае класса <code>Scanner</code>).</p>
</div>
<div class="paragraph">
<p>В примере выше мы подключили только один класс, однако пакет <code>java.util</code> содержит еще множество классов. И чтобы не подключать по отдельности каждый класс, мы можем сразу подключить весь пакет:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.*; // импорт всех классов из пакета java.util</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь мы можем использовать любой класс из пакета <code>java.util</code>.</p>
</div>
<div class="paragraph">
<p>Возможна ситуация, когда мы используем два класса с одним и тем же названием из двух разных пакетов, например, класс <code>Date</code> имеется и в пакете <code>java.util</code>, и в пакете <code>java.sql</code>. И если нам надо одновременно использовать два этих класса, то необходимо указывать полный путь к этим классам в пакете:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">java.util.Date utilDate = new java.util.Date();
java.sql.Date sqlDate = new java.sql.Date();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_статический_импорт">4.4.3. Статический импорт</h4>
<div class="paragraph">
<p>В <strong>java</strong> есть также особая форма импорта - <strong>статический импорт</strong>. Для этого вместе с директивой <code>import</code> используется модификатор <code>static</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">package study;

import static java.lang.System.*;
import static java.lang.Math.*;

public class Program {
    public static void main(String[] args) {
        double result = sqrt(20);
        out.println(result);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь происходит статический импорт классов <code>System</code> и <code>Math</code>. Эти классы имеют статические методы. Благодаря операции статического импорта мы можем использовать эти методы без названия класса. Например, писать не <code>Math.sqrt(20)</code>, а <code>sqrt(20)</code>, так как функция <code>sqrt()</code>, которая возвращает квадратный корень числа, является статической.</p>
</div>
<div class="paragraph">
<p>То же самое в отношении класса <code>System</code>: в нем определен статический объект <code>out</code>, поэтому мы можем его использовать без указания класса.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_модификаторы_доступа">4.5. Модификаторы доступа</h3>
<div class="paragraph">
<p>Все члены класса в языке <strong>Java</strong> - поля и методы - имеют модификаторы доступа. <strong>Модификаторы доступа</strong> позволяют задать допустимую область видимости для членов класса, то есть контекст, в котором можно употреблять данную переменную или метод.</p>
</div>
<div class="paragraph">
<p>В Java используются следующие модификаторы доступа:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>public</code> - публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором <code>public</code>, видны другим классам из текущего пакета и из внешних пакетов.</p>
</li>
<li>
<p><code>private</code> - закрытый класс или член класса, противоположность модификатору <code>public</code>. Закрытый класс или член класса доступен только из кода в том же классе.</p>
</li>
<li>
<p><code>protected</code> - такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах</p>
</li>
<li>
<p><strong>default</strong> (<strong>package</strong>): отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Рассмотрим модификаторы доступа на примере следующей программы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person kate = new Person("Kate", 32, "Baker Street", "+12334567");
        kate.displayName(); // норм, метод public
        kate.displayAge(); // норм, метод имеет модификатор по умолчанию
        kate.displayPhone(); // норм, метод protected
        kate.displayAddress(); // ! Ошибка, метод private

        System.out.println(kate.name); // норм, модификатор по умолчанию
        System.out.println(kate.address); // норм, модификатор public
        System.out.println(kate.age); // норм, модификатор protected
        System.out.println(kate.phone); // ! Ошибка, модификатор private
    }
}

class Person {
    String name;
    protected int age;
    public String address;
    private String phone;

    public Person(String name, int age, String address, String phone) {
        this.name = name;
        this.age = age;
        this.address = address;
        this.phone = phone;
    }

    public void displayName() {
        System.out.printf("Name: %s \n", name);
    }

    void displayAge() {
        System.out.printf("Age: %d \n", age);
    }

    private void displayAddress() {
        System.out.printf("Address: %s \n", address);
    }

    protected void displayPhone() {
        System.out.printf("Phone: %s \n", phone);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае оба класса расположены в одном пакете - <strong>пакете по умолчанию</strong>, поэтому в классе <code>Program</code> мы можем использовать все методы и переменные класса <code>Person</code>, которые имеют <strong>модификатор по умолчанию</strong>, <code>public</code> и <code>protected</code>. А поля и методы с модификатором <code>private</code> в классе <code>Program</code> не будут доступны.</p>
</div>
<div class="paragraph">
<p>Если бы класс <code>Program</code> располагался бы в другом пакете, то ему были бы доступны только поля и методы с модификатором <code>public</code>.</p>
</div>
<div class="paragraph">
<p>Модификатор доступа должен предшествовать остальной части определения переменной или метода.</p>
</div>
</div>
<div class="sect2">
<h3 id="_инкапсуляция">4.6. Инкапсуляция</h3>
<div class="paragraph">
<p>Казалось бы, почему бы не объявить все переменные и методы с модификатором <code>public</code>, чтобы они были доступны в любой точке программы вне зависимости от пакета или класса?</p>
</div>
<div class="paragraph">
<p>Возьмем, например, поле <code>age</code>, которое представляет возраст. Если другой класс имеет прямой доступ к этому полю, то есть вероятность, что в процессе работы программы ему будет передано некорректное значение, например, отрицательное число. Подобное изменение данных не является желательным. Либо же мы хотим, чтобы некоторые данные были достуны напрямую, чтобы их можно было вывести на консоль или просто узнать их значение.</p>
</div>
<div class="paragraph">
<p>В этой связи рекомендуется как можно больше ограничивать доступ к данным, чтобы защитить их от нежелательного доступа извне (как для получения значения, так и для его изменения). Использование различных модификаторов гарантирует, что данные не будут искажены или изменены не надлежащим образом. Подобное сокрытие данных внутри некоторой области видимости называется <strong>инкапсуляцией</strong>.</p>
</div>
<div class="paragraph">
<p>Так, как правило, вместо непосредственного использования полей, как правило, используют методы доступа. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person kate = new Person("Kate", 30, true);
        System.out.println(kate.getAge()); // 30
        kate.setAge(33);
        System.out.println(kate.getAge()); // 33
        kate.setAge(123450);
        System.out.println(kate.getAge()); // 33
    }
}

class Person {
    private String name;
    private int age;
    private boolean adult;

    public Person(String name, int age, boolean adult) {
        this.name = name;
        this.age = age;
        this.adult = adult;
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return this.age;
    }

    public void setAge(int age) {
        if (age &gt; 0 &amp;&amp; age &lt; 110) {
            this.age = age;
        }
    }

    public boolean isAdult() {
        return this.adult;
    }

    public void setAdult(boolean adult) {
        this.adult = adult;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>И затем вместо непосредственной работы с полями <code>name</code> и <code>age</code> в классе <code>Person</code> мы будем работать с методами, которые устанавливает и возвращают значения этих полей. Методы <code>setName()</code>, <code>setAge()</code> и <code>setAdult()</code>, которые меняют состояние объекта, иногда называют <strong>мьютейтерами</strong> (<strong>mutator</strong>). А методы <code>getName()</code>, <code>getAge()</code> и <code>isAdult()</code>, с помощью которых получаем доступ к состоянию класса, называют <strong>аксессерами</strong> (<strong>accessor</strong>).</p>
</div>
<div class="paragraph">
<p>Причем в эти методы мы можем вложить дополнительную логику. Например, в данном случае при изменении возраста производится проверка, насколько соответствует новое значение допустимому диапазону.</p>
</div>
</div>
<div class="sect2">
<h3 id="_наследование">4.7. Наследование</h3>
<div class="paragraph">
<p>Одним из ключевых аспектов объектно-ориентированного программирования является <strong>наследование</strong> (<strong>inheritance</strong>). С помощью наследования можно расширить функционал уже имеющихся классов за счет добавления нового функционала или изменения старого. Например, имеется следующий класс <code>Person</code>, описывающий отдельного человека:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person {
    private String name;
    public String getName() {
        return name;
    }

    public Person(String name) {
        this.name = name;
    }

    public void display() {
        System.out.println("Name: " + name);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>И, возможно, впоследствии мы захотим добавить еще один класс, который описывает сотрудника предприятия - класс <code>Employee</code>. Так как этот класс реализует тот же функционал, что и класс <code>Person</code>, так как сотрудник - это также и человек, то было бы рационально сделать класс <code>Employee</code> <strong>производным</strong> (<strong>subclass</strong>, <strong>наследником</strong>, <strong>подклассом</strong>) от класса <code>Person</code>, который, в свою очередь, называется <strong>базовым классом</strong> (<strong>superclass</strong>, <strong>родителем</strong>, <strong>суперклассом</strong>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Employee extends Person {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы объявить один класс наследником от другого, надо использовать после имени класса-наследника ключевое слово <code>extends</code>, после которого идет имя базового класса. Для класса <code>Employee</code> базовым является <code>Person</code>, и поэтому класс <code>Employee</code> наследует все те же поля и методы, которые есть в классе <code>Person</code>.</p>
</div>
<div class="paragraph">
<p>Использование классов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person tom = new Person("Tom");
        tom.display();
        Employee sam = new Employee("Sam");
        sam.display();
    }
}

class Person {
    private String name;

    public String getName() {
        return name;
    }

    public Person(String name) {
        this.name = name;
    }

    public void display() {
        System.out.println("Name: " + name);
    }
}

class Employee extends Person {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Производный класс имеет доступ ко всем методам и полям базового класса (даже если базовый класс находится в другом пакете) кроме тех, которые определены с модификатором <code>private</code>. При этом производный класс также может добавлять свои поля и методы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Employee sam = new Employee("Sam", "Red Hat");
        sam.display(); // Sam
        sam.work(); // Sam works in Red Hat
    }
}

class Person {
    private String name;

    public String getName() {
        return name;
    }

    public Person(String name) {
        this.name = name;
    }

    public void display() {
        System.out.println("Name: " + name);
    }
}

class Employee extends Person {
    private String company;

    public Employee(String name, String company) {
        super(name);
        this.company = company;
    }

    public void work() {
        System.out.printf("%s works in %s \n", getName(), company);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае класс <code>Employee</code> добавляет поле <code>company</code>, которое хранит место работы сотрудника, а также метод <code>work()</code>.</p>
</div>
<div class="paragraph">
<p>Если в базовом классе определены конструкторы, то в конструкторе производного классы необходимо вызвать один из конструкторов базового класса с помощью ключевого слова <code>super</code>. Например, класс <code>Person</code> имеет конструктор, который принимает один параметр. Поэтому в классе <code>Employee</code> в конструкторе нужно вызвать констуктор класса <code>Person</code>. После слова <code>super</code> в скобках идет перечисление передаваемых аргументов. Таким образом, установка имени сотрудника делегируется конструктору базового класса.</p>
</div>
<div class="paragraph">
<p>При этом вызов конструктора базового класса должен идти в самом начале в конструкторе производного класса.</p>
</div>
<div class="sect3">
<h4 id="_переопределение_методов">4.7.1. Переопределение методов</h4>
<div class="paragraph">
<p>Производный класс может определять свои методы, а может переопределять методы, которые унаследованы от базового класса. Например, переопределим в классе <code>Employee</code> метод <code>display()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Employee sam = new Employee("Sam", "Red Hat");
        sam.display();  // Sam
        // Works in Red Hat
    }
}

class Person {
    private String name;

    public String getName() {
        return name;
    }

    public Person(String name) {
        this.name = name;
    }

    public void display() {
        System.out.println("Name: " + name);
    }
}

class Employee extends Person {
    private String company;

    public Employee(String name, String company) {
        super(name);
        this.company = company;
    }

    @Override
    public void display() {
        System.out.printf("Name: %s \n", getName());
        System.out.printf("Works in %s \n", company);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Перед переопределяемым методом указывается аннотация <code>@Override</code>. Данная аннотация в принципе необязательна.</p>
</div>
<div class="paragraph">
<p>При переопределении метода он должен иметь уровень доступа не меньше, чем уровень доступа в базовом класса. Например, если в базовом классе метод имеет модификатор <code>public</code>, то и в производном классе метод должен иметь модификатор <code>public</code>.</p>
</div>
<div class="paragraph">
<p>Однако в данном случае мы видим, что часть метода <code>display</code> в <code>Employee</code> повторяет действия из метода <code>display()</code> базового класса. Поэтому мы можем сократить класс <code>Employee</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Employee extends Person {
    private String company;

    public Employee(String name, String company) {
        super(name);
        this.company = company;
    }

    @Override
    public void display() {
        super.display();
        System.out.printf("Works in %s \n", company);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>С помощью ключевого слова <code>super</code> мы также можем обратиться к реализации методов базового класса.</p>
</div>
</div>
<div class="sect3">
<h4 id="_запрет_наследования">4.7.2. Запрет наследования</h4>
<div class="paragraph">
<p>Хотя наследование очень интересный и эффективный механизм, но в некоторых ситуациях его применение может быть нежелательным. И в этом случае можно запретить наследование с помощью ключевого слова <code>final</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public final class Person {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если бы класс <code>Person</code> был бы определен таким образом, то следующий код был бы ошибочным и не сработал, так как мы тем самым запретили наследование:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Employee extends Person {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Кроме запрета наследования можно также запретить переопределение отдельных методов. Например, в примере выше переопределен метод <code>displayInfo()</code>, запретим его переопределение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Person {
    public final void display() {
        System.out.println("Имя: " + name);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом случае класс <code>Employee</code> не сможет переопределить метод <code>display()</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_динамическая_диспетчеризация_методов">4.7.3. Динамическая диспетчеризация методов</h4>
<div class="paragraph">
<p>Наследование и возможность переопределения методов открывают нам большие возможности. Прежде всего мы можем передать переменной суперкласса ссылку на объект подкласса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Person sam = new Employee("Sam", "Oracle");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так как <code>Employee</code> наследуется от <code>Person</code>, то объект <code>Employee</code> является в то же время и объектом <code>Person</code>. Грубо говоря, любой работник предприятия одновременно является человеком.</p>
</div>
<div class="paragraph">
<p>Однако несмотря на то, что переменная представляет объект <code>Person</code>, виртуальная машина видит, что в реальности она указывает на объект <code>Employee</code>. Поэтому при вызове методов у этого объектов будет вызывать та версия методов, которая определена в классе <code>Employee</code>, а не в <code>Person</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person tom = new Person("Tom");
        tom.display();
        Person sam = new Employee("Sam", "Oracle");
        sam.display();
    }
}

class Person {
    private String name;

    public String getName() {
        return name;
    }

    public Person(String name) {
        this.name = name;
    }

    public void display() {
        System.out.printf("Person %s \n", name);
    }
}

class Employee extends Person {
    private String company;

    public Employee(String name, String company) {
        super(name);
        this.company = company;
    }

    @Override
    public void display() {
        System.out.printf("Employee %s works in %s \n", super.getName(), company);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>При вызове переопределенного метода виртуального машина динамически находит и вызывает именно ту версию метода, которая определена в подклассе. Данный процесс еще называется <strong>динамическая диспетчеризация методов</strong> (<strong>dynamic method lookup</strong>, <strong>динамический поиск метода</strong>).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_иерархия_наследования_и_преобразование_типов">4.8. Иерархия наследования и преобразование типов</h3>
<div class="paragraph">
<p>Преобразование объектов классов происходит по-другому, чем с примитивными типами. Допустим, у нас есть следующая иерархия классов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person tom = new Person("Tom");
        tom.display();
        Person sam = new Employee("Sam", "Oracle");
        sam.display();
        Person bob = new Client("Bob", "DeutscheBank", 3000);
        bob.display();
    }
}

class Person {
    private String name;

    public String getName() {
        return name;
    }

    public Person(String name) {
        this.name = name;
    }

    public void display() {
        System.out.printf("Person %s \n", name);
    }
}

class Employee extends Person {
    private String company;

    public Employee(String name, String company) {
        super(name);
        this.company = company;
    }

    public String getCompany() {
        return company;
    }

    public void display() {
        System.out.printf("Employee %s works in %s \n", super.getName(), company);
    }
}

class Client extends Person {
    private int sum; // Переменная для хранения суммы на счете
    private String bank;

    public Client(String name, String bank, int sum) {
        super(name);
        this.bank = bank;
        this.sum = sum;
    }

    public void display() {
        System.out.printf("Client %s has account in %s \n", super.getName(), bank);
    }

    public String getBank() {
        return bank;
    }

    public int getSum() {
        return sum;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этой иерархии классов можно проследить следующую цепь наследования: <code>Object</code> &#8594; <code>Person</code> &#8594; <code>Employee</code>|<code>Client</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/assets/img/java/core/oop/hierarhy-classes.png" alt="hierarhy classes"></span></p>
</div>
<div class="sect3">
<h4 id="_преобразование_типов_в_языке_java">4.8.1. Преобразование типов в языке Java</h4>
<div class="paragraph">
<p>Суперклассы обычно размещаются выше подклассов, поэтому на вершине наследования находится класс <code>Object</code>, а в самом низу <code>Employee</code> и <code>Client</code>.</p>
</div>
<div class="paragraph">
<p>Объект подкласса также представляет объект суперкласса. Поэтому в программе мы можем написать следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Object tom = new Person("Tom");
Object sam = new Employee("Sam", "Oracle");
Object kate = new Client("Kate", "DeutscheBank", 2000);
Person bob = new Client("Bob", "DeutscheBank", 3000);
Person alice = new Employee("Alice", "Google");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это так называемое <strong>восходящее преобразование</strong> (<strong>upcasting</strong>) от подкласса внизу к суперклассу вверху иерархии. Такое преобразование осуществляется автоматически.</p>
</div>
<div class="paragraph">
<p>Обратное не всегда верно. Например, объект <code>Person</code> не всегда является объектом <code>Employee</code> или <code>Client</code>. Поэтому <strong>нисходящее преобразование</strong> (<strong>downcasting</strong>) от суперкласса к подклассу автоматически не выполняется. В этом случае нам надо использовать операцию преобразования типов.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Object sam = new Employee("Sam", "Oracle");

// нисходящее преобразование от Object к типу Employee
Employee emp = (Employee) sam;
emp.display();
System.out.println(emp.getCompany());</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае переменная <code>sam</code> приводится к типу <code>Employee</code>. И затем через объект emp мы можем обратиться к функционалу объекта <code>Employee</code>.</p>
</div>
<div class="paragraph">
<p>Мы можем преобразовать объект <code>Employee</code> по всей прямой линии наследования от <code>Object</code> к <code>Employee</code>.</p>
</div>
<div class="paragraph">
<p>Примеры нисходящих перобразований:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Object kate = new Client("Kate", "DeutscheBank", 2000);
((Person) kate).display();

Object sam = new Employee("Sam", "Oracle");
((Employee) sam).display();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Но рассмотрим еще одну ситуацию:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Object kate = new Client("Kate", "DeutscheBank", 2000);
Employee emp = (Employee) kate;
emp.display();

// или так
((Employee) kate).display();</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае переменная типа <code>Object</code> хранит ссылку на объект <code>Client</code>. Мы можем без ошибок привести этот объект к типам <code>Person</code> или <code>Client</code>. Но при попытке преобразования к типу <code>Employee</code> мы получим ошибку во время выполнения. Так как <code>kate</code> не представляет объект типа <code>Employee</code>.</p>
</div>
<div class="paragraph">
<p>Здесь мы явно видим, что переменная <code>kate</code> - это ссылка на объект <code>Client</code>, а не <code>Employee</code>. Однако нередко данные приходят извне, и мы можем точно не знать, какой именно объект эти данные представляют. Соответственно возникает большая вероятная столкнуться с ошибкой. И перед тем, как провести преобразование типов, мы можем проверить, а можем ли мы выполнить приведение с помощью оператора <code>instanceof</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Object kate = new Client("Kate", "DeutscheBank", 2000);
if (kate instanceof Employee) {
    ((Employee) kate).display();
} else {
    System.out.println("Conversion is invalid");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Выражение <code>kate instanceof Employee</code> проверяет, является ли переменная <code>kate</code> объектом типа <code>Employee</code>. Но так как в данном случае явно не является, то такая проверка вернет значение <code>false</code>, и преобразование не сработает.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_перегрузка_методов">4.9. Перегрузка методов</h3>
<div class="paragraph">
<p>В программе мы можем использовать методы с одним и тем же именем, но с разными типами и/или количеством параметров. Такой механизм называется <strong>перегрузкой методов</strong> (<strong>method overloading</strong>).</p>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        System.out.println(sum(2, 3)); // 5
        System.out.println(sum(4.5, 3.2)); // 7.7
        System.out.println(sum(4, 3, 7)); // 14
    }

    static int sum(int x, int y) {
        return x + y;
    }

    static double sum(double x, double y) {
        return x + y;
    }

    static int sum(int x, int y, int z) {
        return x + y + z;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь определено три варианта или три перегрузки метода <code>sum()</code>, но при его вызове в зависимости от типа и количества передаваемых параметров система выберет именно ту версию, которая наиболее подходит.</p>
</div>
<div class="paragraph">
<p>Стоит отметить, что на перегрузку методов влияют количество и типы параметров. Однако различие в типе возвращаемого значения для перегрузки не имеют никакого значения. Например, в следующем случае методы различаются по типу возвращаемого значения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        System.out.println(sum(2, 3));
        System.out.println(sum(4, 3));
    }

    static int sum(int x, int y) {
        return x + y;
    }

    static double sum(int x, int y) {
        return x + y;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Однако перегрузкой это не будет считаться. Более того такая программа некорректна и попросту не скомилируется, так как метод с одним и тем же количеством и типом параметров определен несколько раз.</p>
</div>
</div>
<div class="sect2">
<h3 id="_абстрактные_классы">4.10. Абстрактные классы</h3>
<div class="paragraph">
<p>Кроме обычных классов в <strong>Java</strong> есть <strong>абстрактные классы</strong>. Абстрактный класс похож на обычный класс. В абстрактном классе также можно определить поля и методы, в то же время нельзя создать объект или экземпляр абстрактного класса. Абстрактные классы призваны предоставлять базовый функционал для классов-наследников. А производные классы уже реализуют этот функционал.</p>
</div>
<div class="paragraph">
<p>При определении абстрактных классов используется ключевое слово <code>abstract</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public abstract class Human {
    private String name;

    public String getName() {
        return name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Но главное отличие состоит в том, что мы не можем использовать конструктор абстрактного класса для создания его объекта. Например, следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Human h = new Human();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Кроме обычных методов абстрактный класс может содержать абстрактные методы. Такие методы определяются с помощью ключевого слова <code>abstract</code> и не имеют никакого функционала:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public abstract void display();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Производный класс обязан переопределить и реализовать все абстрактные методы, которые имеются в базовом абстрактном классе. Также следует учитывать, что если класс имеет хотя бы один абстрактный метод, то данный класс должен быть определен как абстрактный.</p>
</div>
<div class="paragraph">
<p>Зачем нужны абстрактные классы? Допустим, мы делаем программу для обсулживания банковских операций и определяем в ней три класса: <code>Person</code>, который описывает человека, <code>Employee</code>, который описывает банковского служащего, и класс <code>Client</code>, который представляет клиента банка. Очевидно, что классы <code>Employee</code> и <code>Client</code> будут производными от класса <code>Person</code>, так как оба класса имеют некоторые общие поля и методы. И так как все объекты будут представлять либо сотрудника, либо клиента банка, то напрямую мы от класса <code>Person</code> создавать объекты не будем. Поэтому имеет смысл сделать его абстрактным.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Employee sam = new Employee("Sam", "Leman Brothers");
        sam.display();
        Client bob = new Client("Bob", "Leman Brothers");
        bob.display();
    }
}

abstract class Person {
    private String name;

    public String getName() {
        return name;
    }

    public Person(String name) {
        this.name = name;
    }

    public abstract void display();
}

class Employee extends Person {
    private String bank;

    public Employee(String name, String company) {
        super(name);
        this.bank = company;
    }

    public void display() {
        System.out.printf("Employee Name: %s \t Bank: %s \n", super.getName(), bank);
    }
}

class Client extends Person {
    private String bank;

    public Client(String name, String company) {
        super(name);
        this.bank = company;
    }

    public void display() {
        System.out.printf("Client Name: %s \t Bank: %s \n", super.getName(), bank);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Другим хрестоматийным примером является системы фигур. В реальности не существует геометрической фигуры как таковой. Есть круг, прямоугольник, квадрат, но просто фигуры нет. Однако же и круг, и прямоугольник имеют что-то общее и являются фигурами:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">abstract class Figure {
    float x; // x-координата точки
    float y; // y-координата точки

    Figure(float x, float y) {
        this.x = x;
        this.y = y;
    }

    public abstract float getPerimeter();

    public abstract float getArea();
}

class Rectangle extends Figure {
    private float width;
    private float height;

    Rectangle(float x, float y, float width, float height) {
        super(x, y);
        this.width = width;
        this.height = height;
    }

    public float getPerimeter() {
        return width * 2 + height * 2;
    }

    public float getArea() {
        return width * height;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_интерфейсы">4.11. Интерфейсы</h3>
<div class="paragraph">
<p>Механизм наследования очень удобен, но он имеет свои ограничения. В частности мы можем наследовать только от одного класса, в отличие, например, от языка С++, где имеется <strong>множественное наследование</strong>.</p>
</div>
<div class="paragraph">
<p>В языке <strong>Java</strong> подобную проблему частично позволяют решить интерфейсы. <strong>Интерфейсы</strong> определяют некоторый функционал, не имеющий конкретной реализации, который затем реализуют классы, применяющие эти интерфейсы. И один класс может применить множество интерфейсов.</p>
</div>
<div class="paragraph">
<p>Чтобы определить интерфейс, используется ключевое слово <code>interface</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">interface Printable {
    void print();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Данный интерфейс называется <code>Printable</code>. Интерфейс может определять константы и методы, которые могут иметь, а могут и не иметь реализации. Методы без реализации похожи на абстрактные методы абстрактных классов. Так, в данном случае объявлен один метод, который не имеет реализации.</p>
</div>
<div class="paragraph">
<p>Все методы интерфейса не имеют модификаторов доступа, но фактически по умолчанию доступ <code>public</code>, так как цель интерфейса - определение функционала для реализации его классом. Поэтому весь функционал должен быть открыт для реализации.</p>
</div>
<div class="paragraph">
<p>Чтобы класс применил интерфейс, надо использовать ключевое слово <code>implements</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Book b1 = new Book("Java. Complete Referense.", "H. Shildt");
        b1.print();
    }
}

interface Printable {
    void print();
}

class Book implements Printable {
    String name;
    String author;

    Book(String name, String author) {
        this.name = name;
        this.author = author;
    }

    public void print() {
        System.out.printf("%s (%s) \n", name, author);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае класс <code>Book</code> реализует интерфейс <code>Printable</code>. При этом надо учитывать, что если класс применяет интерфейс, то он должен реализовать все методы интерфейса, как в случае выше реализован метод <code>print()</code>. Потом в методе main мы можем объект класса <code>Book</code> и вызвать его метод <code>print()</code>. Если класс не реализует какие-то методы интерфейса, то такой класс должен быть определен как абстрактный, а его неабстрактные классы-наследники затем должны будут эти методы.</p>
</div>
<div class="paragraph">
<p>В тоже время мы не можем напрямую создавать объекты интерфейсов, поэтому следующий код не будет работать:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Printable pr = new Printable();
pr.print();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Одним из преимуществ использования интерфейсов является то, что они позволяют добавить в приложение гибкости. Например, в дополнение к классу <code>Book</code> определим еще один класс, который будет реализовывать интерфейс <code>Printable</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Journal implements Printable {
    private String name;

    String getName() {
        return name;
    }

    Journal(String name) {
        this.name = name;
    }

    public void print() {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Класс <code>Book</code> и класс <code>Journal</code> связаны тем, что они реализуют интерфейс <code>Printable</code>. Поэтому мы динамически в программе можем создавать объекты <code>Printable</code> как экземпляры обоих классов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Printable printable = new Book("Java. Complete Reference", "H. Shildt");
        printable.print(); // Java. Complete Reference (H. Shildt)
        printable = new Journal("Foreign Policy");
        printable.print(); // Foreign Policy
    }
}

interface Printable {
    void print();
}

class Book implements Printable {
    String name;
    String author;

    Book(String name, String author) {
        this.name = name;
        this.author = author;
    }

    public void print() {
        System.out.printf("%s (%s) \n", name, author);
    }
}

class Journal implements Printable {
    private String name;

    String getName() {
        return name;
    }

    Journal(String name) {
        this.name = name;
    }

    public void print() {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_интерфейсы_в_преобразованиях_типов">4.11.1. Интерфейсы в преобразованиях типов</h4>
<div class="paragraph">
<p>Все сказанное в отношении преобразования типов характерно и для интерфейсов. Например, так как класс <code>Journal</code> реализует интерфейс <code>Printable</code>, то переменная типа <code>Printable</code> может хранить ссылку на объект типа <code>Journal</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Printable p = new Journal("Foreign Affairs");
p.print();
// Интерфейс не имеет метода getName, необходимо явное приведение
String name = ((Journal) p).getName();
System.out.println(name);</code></pre>
</div>
</div>
<div class="paragraph">
<p>И если мы хотим обратиться к методам класса <code>Journal</code>, которые определены не в интерфейсе <code>Printable</code>, а в самом классе <code>Journal</code>, то нам надо явным образом выполнить преобразование типов: <code>((Journal) p).getName();</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_методы_по_умолчанию">4.11.2. Методы по умолчанию</h4>
<div class="paragraph">
<p>Ранее до <strong>JDK 8</strong> при реализации интерфейса мы должны были обязательно реализовать все его методы в классе. А сам интерфейс мог содержать только определения методов без конкретной реализации. В <strong>JDK 8</strong> была добавлена такая функциональность как <strong>методы по умолчанию</strong>. И теперь интерфейсы кроме определения методов могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод. Например, создадим метод по умолчанию в интерфейсе <code>Printable</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">interface Printable {
    default void print() {
        System.out.println("Undefined printable");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод по умолчанию - это обычный метод без модификаторов, который помечается ключевым словом <code>default</code>. Затем в классе <code>Journal</code> нам необязательно этот метод реализовать, хотя мы можем его и переопределить:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Journal implements Printable {
    private String name;

    String getName() {
        return name;
    }

    Journal(String name) {
        this.name = name;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_статические_методы">4.11.3. Статические методы</h4>
<div class="paragraph">
<p>Начиная с <strong>JDK 8</strong> в интерфейсах доступны <strong>статические методы</strong> - они аналогичны методам класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">interface Printable {
    void print();

    static void read() {
        System.out.println("Read printable");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы обратиться к статическому методу интерфейса также, как и в случае с классами, пишут название интерфейса и метод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static void main(String[] args) {
    Printable.read();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_приватные_методы">4.11.4. Приватные методы</h4>
<div class="paragraph">
<p>По умолчанию все методы в интерфейсе фактически имеют модификатор <code>public</code>. Однако начиная с <strong>Java 9</strong> мы также можем определять в интерфейсе методы с модификатором <code>private</code>. Они могут быть статическими и нестатическими, но они не могут иметь реализации по умолчанию.</p>
</div>
<div class="paragraph">
<p>Подобные методы могут использоваться только внутри самого интерфейса, в котором они определены. То есть к примеру нам надо выполнять в интерфейсе некоторые повторяющиеся действия, и в этом случае такие действия можно выделить в приватные методы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Calculatable c = new Calculation();
        System.out.println(c.sum(1, 2));
        System.out.println(c.sum(1, 2, 4));
    }
}

class Calculation implements Calculatable {
}

interface Calculatable {
    default int sum(int a, int b) {
        return sumAll(a, b);
    }

    default int sum(int a, int b, int c) {
        return sumAll(a, b, c);
    }

    private int sumAll(int... values) {
        int result = 0;
        for (int n : values) {
            result += n;
        }
        return result;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_константы_в_интерфейсах">4.11.5. Константы в интерфейсах</h4>
<div class="paragraph">
<p>Кроме методов в интерфейсах могут быть определены статические константы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">interface Stateable {
    int OPEN = 1;
    int CLOSED = 0;

    void printState(int n);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Хотя такие константы также не имеют модификаторов, но по умолчанию они имеют модификатор доступа <code>public static final</code>, и поэтому их значение доступно из любого места программы.</p>
</div>
<div class="paragraph">
<p>Применение констант:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        WaterPipe pipe = new WaterPipe();
        pipe.printState(1);
    }
}

class WaterPipe implements Stateable {
    public void printState(int n) {
        if (n == OPEN) {
            System.out.println("Water is opened");
        } else if (n == CLOSED) {
            System.out.println("Water is closed");
        } else {
            System.out.println("State is invalid");
        }
    }
}

interface Stateable {
    int OPEN = 1;
    int CLOSED = 0;

    void printState(int n);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_множественная_реализация_интерфейсов">4.11.6. Множественная реализация интерфейсов</h4>
<div class="paragraph">
<p>Если нам надо применить в классе несколько интерфейсов, то они все перечисляются через запятую после слова <code>implements</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">interface Printable {
    // методы интерфейса
}

interface Searchable {
    // методы интерфейса
}

class Book implements Printable, Searchable{
    // реализация класса
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_наследование_интерфейсов">4.11.7. Наследование интерфейсов</h4>
<div class="paragraph">
<p>Интерфейсы, как и классы, могут наследоваться:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">interface BookPrintable extends Printable {
    void paint();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>При применении этого интерфейса класс <code>Book</code> должен будет реализовать как методы интерфейса <code>BookPrintable</code>, так и методы базового интерфейса <code>Printable</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_вложенные_интерфейсы">4.11.8. Вложенные интерфейсы</h4>
<div class="paragraph">
<p>Как и классы, интерфейсы могут быть вложенными, то есть могут быть определены в классах или других интерфейсах. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Printer {
    interface Printable {
        void print();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>При применении такого интерфейса нам надо указывать его полное имя вместе с именем класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Journal implements Printer.Printable {
    String name;

    Journal(String name) {
        this.name = name;
    }

    public void print() {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Использование интерфейса будет аналогично предыдущим случаям:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Printer.Printable p = new Journal("Foreign Affairs");
p.print();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_интерфейсы_как_параметры_и_результаты_методов">4.11.9. Интерфейсы как параметры и результаты методов</h4>
<div class="paragraph">
<p>И также как и в случае с классами, интерфейсы могут использоваться в качестве типа параметров метода или в качестве возвращаемого типа:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Printable printable = createPrintable("Foreign Affairs", false);
        printable.print();

        read(new Book("Java for impatients", "Cay Horstmann"));
        read(new Journal("Java Dayly News"));
    }

    static void read(Printable p) {
        p.print();
    }

    static Printable createPrintable(String name, boolean option) {
        if (option) {
            return new Book(name, "Undefined");
        } else {
            return new Journal(name);
        }
    }
}

interface Printable {
    void print();
}

class Book implements Printable {
    String name;
    String author;

    Book(String name, String author) {
        this.name = name;
        this.author = author;
    }

    public void print() {
        System.out.printf("%s (%s) \n", name, author);
    }
}

class Journal implements Printable {
    private String name;

    String getName() {
        return name;
    }

    Journal(String name) {
        this.name = name;
    }

    public void print() {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>read()</code> в качестве параметра принимает объект интерфейса <code>Printable</code>, поэтому в этот метод мы можем передать как объект <code>Book</code>, так и объект <code>Journal</code>.</p>
</div>
<div class="paragraph">
<p>Метод <code>createPrintable()</code> возвращает объект <code>Printable</code>, поэтому также мы вожем возвратить как объект <code>Book</code>, так и <code>Journal</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_статические_члены_и_модификатор_static">4.12. Статические члены и модификатор <code>static</code></h3>
<div class="paragraph">
<p>Кроме обычных методов и полей класс может иметь статические поля, методы, константы и инициализаторы. Например, главный класс программы имеет метод <code>main()</code>, который является статическим:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static void main(String[] args) {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для объявления статических:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>полей</p>
</li>
<li>
<p>констант</p>
</li>
<li>
<p>методов</p>
</li>
<li>
<p>инициализаторов</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>перед их объявлением указывается ключевое слово <code>static</code>.</p>
</div>
<div class="sect3">
<h4 id="_статические_поля">4.12.1. Статические поля</h4>
<div class="paragraph">
<p>При создании объектов класса для каждого объекта создается своя копия нестатических обычных полей. А статические поля являются общими для всего класса. Поэтому они могут использоваться без создания объектов класса.</p>
</div>
<div class="paragraph">
<p>Например, создадим статическую переменную:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person tom = new Person();
        Person bob = new Person();

        tom.displayId(); // "Id: 1"
        bob.displayId(); // "Id: 2"
        System.out.println(Person.counter); // 3

        Person.counter = 8; // изменяем Person.counter

        Person sam = new Person();
        sam.displayId(); // "Id: 8"
    }
}

class Person {
    private int id;
    static int counter = 1;

    Person() {
        id = counter++;
    }

    public void displayId() {
        System.out.printf("Id: %d\n", id);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Класс <code>Person</code> содержит статическую переменную <code>counter</code>, которая увеличивается в конструкторе и ее значение присваивается переменной <code>id</code>. То есть при создании каждого нового объекта <code>Person</code> эта переменная будет увеличиваться, поэтому у каждого нового объекта <code>Person</code> значение поля <code>id</code> будет на <code>1</code> больше чем у предыдущего.</p>
</div>
<div class="paragraph">
<p>Так как переменная <code>counter</code> статическая, то мы можем обратиться к ней в программе по имени класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">System.out.println(Person.counter); // получаем значение
Person.counter = 8; // изменяем значение</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_статические_константы">4.12.2. Статические константы</h4>
<div class="paragraph">
<p>Также статическими бывают константы, которые являются общими для всего класса.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        double radius = 60;
        System.out.printf("Radius: %f\n", radius); // "Radius: 60"
        System.out.printf("Area: %f\n", Math.PI * radius); // "Area: 11304,0"
    }
}

class Math {
    public static final double PI = 3.14;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Стоит отметить, что на протяжении всех предыдущих тем уже активно использовались статические константы. В частности, в выражении:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">System.out.println("hello");</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>out</code> как раз представляет статическую константу класса <code>System</code>. Поэтому обращение к ней идет без создания объекта класса <code>System</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_статические_инициализаторы">4.12.3. Статические инициализаторы</h4>
<div class="paragraph">
<p>Статические инициализаторы предназначены для инициализации статических переменных, либо для выполнения таких действий, которые выполняются при создании самого первого объекта. Например, определим статический инициализатор:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person tom = new Person();
        Person bob = new Person();

        tom.displayId(); // "Id: 105"
        bob.displayId(); // "Id: 106"
    }
}

class Person {
    private int id;
    static int counter;

    static {
        counter = 105;
        System.out.println("Static initializer");
    }

    Person() {
        id = counter++;
        System.out.println("Constructor");
    }

    public void displayId() {
        System.out.printf("Id: %d\n", id);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Статический инициализатор определяется как обычный, только перед ним ставится ключевое слово <code>static</code>. В данном случае в статическом инициализаторе мы устанавливаем начальное значение статического поля <code>counter</code> и выводим на консоль сообщение.</p>
</div>
<div class="paragraph">
<p>В самой программе создаются два объекта класса <code>Person</code>.</p>
</div>
<div class="paragraph">
<p>Стоит учитывать, что вызов статического инициализатора производится только перед созданием самого первого объекта класса.</p>
</div>
</div>
<div class="sect3">
<h4 id="_статические_методы_2">4.12.4. Статические методы</h4>
<div class="paragraph">
<p>Статические методы также относятся ко всему классу в целом. Например, в примере выше статическая переменная <code>counter</code> была доступна извне, и мы могли изменить ее значение вне класса <code>Person</code>. Сделаем ее недоступной для изменения извне, но доступной для чтения. Для этого используем статический метод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person.displayCounter(); // "Counter: 1"

        Person tom = new Person();
        Person bob = new Person();

        Person.displayCounter(); // "Counter: 3"
    }
}

class Person {
    private int id;
    private static int counter = 1;

    Person() {
        id = counter++;
    }

    public static void displayCounter() {
        System.out.printf("Counter: %d\n", counter);
    }

    public void displayId() {
        System.out.printf("Id: %d\n", id);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь статическая переменная недоступна извне, она приватная. А ее значение выводится с помощью статического метода <code>displayCounter()</code>. Для обращения к статическому методу используется имя класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Person.displayCounter();</code></pre>
</div>
</div>
<div class="paragraph">
<p>При использовании статических методов надо учитывать ограничения: в статических методах мы можем вызывать только другие статические методы и использовать только статические переменные.</p>
</div>
<div class="paragraph">
<p>Вообще методы определяются как статические, когда методы не затрагиют состояние объекта, то есть его нестатические поля и константы, и для вызова метода нет смысла создавать экземпляр класса. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        System.out.println(Operation.sum(45, 23)); // 68
        System.out.println(Operation.subtract(45, 23)); // 22
        System.out.println(Operation.multiply(4, 23)); // 92
    }
}

class Operation {
    static int sum(int x, int y) {
        return x + y;
    }

    static int subtract(int x, int y) {
        return x - y;
    }

    static int multiply(int x, int y) {
        return x * y;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае для методов <code>sum()</code>, <code>subtract()</code>, <code>multiply()</code> не имеет значения, какой именно экземпляр класса <code>Operation</code> используется. Эти методы работают только с параметрами, не затрагивая состояние класса. Поэтому их можно определить как статические.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_вложенные_классы">4.13. Вложенные классы</h3>
<div class="paragraph">
<p><strong>Вложенные классы</strong> (<strong>nested class</strong>) - это классы определенные внутри другого класса. <strong>Область действия вложенного класса</strong> ограничена областью действия внешнего класса. Если класс В определен в классе А, то класс B не может существовать независимо от класса А. <strong>Вложенный класс</strong> имеет доступ к членам (в том числе <code>private</code>) того класса, в который он объявлен.</p>
</div>
<div class="paragraph">
<p><strong>Типы вложенных классов</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Обычный внутренний класс</strong> (<strong>regular inner class</strong> or <strong>member class</strong>).</p>
</li>
<li>
<p><strong>Локальный класс</strong> (<strong>method-local inner class</strong>).</p>
</li>
<li>
<p><strong>Анонимный класс</strong> (<strong>anonymous inner class</strong>).</p>
</li>
<li>
<p><strong>Статический вложенный класс</strong> (<strong>static nested class</strong>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="/assets/img/java/core/oop/nested-classes.png" alt="Nested Classes"></span></p>
</div>
<div class="sect3">
<h4 id="_обычный_внутренний_класс">4.13.1. Обычный внутренний класс</h4>
<div class="paragraph">
<p><strong>Внутренний класс</strong> (<strong>inner class</strong>) определяется в области действия внешнего класса.</p>
</div>
<div class="paragraph">
<p>Чтобы создать объект внутреннего класса, должен существовать объект внешнего класса.</p>
</div>
<div class="paragraph">
<p>Внутренний и внешний класс имеют доступ ко всем членам класса друг друга (даже <code>private</code>).</p>
</div>
<div class="paragraph">
<p>Следующий пример демонстрирует объявление обычного внутреннего класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Town {
    private String postCode = "33333";

    public class Street {
        private int house;

        public void printAddress() {
            System.out.println("Город " + Town.this);
            System.out.println("Индекс " + postCode);
            System.out.println("Улица " + this);
            System.out.println("Дом " + house);
        }
    }

    public void createStreet() {
        Street street = new Street();
        street.house = 78;
        street.printAddress();
    }

    public static void main(String[] args) {
        Town town = new Town();
        town.createStreet();
        Town.Street street1 = town.new Street();
        Town.Street street2 = new Town().new Street();
        street1.printAddress();
        street2.printAddress();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Внутри метода внешнего класса, объект внутреннего класса создается как обычно:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Street street = new Street();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если мы создаем объект внутреннего класса не в методах внешнего класса или в статических методах внешнего класса, необходимо использовать объект внешнего класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">new Town().new Street();
// or
town.new Street();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если необходимо получить ссылку на внутренний класс во внутреннем классе, используем слово <code>this</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">System.out.println("Street is " + this);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если необходимо получить ссылку на объект внешнего класса, запишите имя внешнего класса, за которым следует точка, а затем ключевое слово <code>this</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">System.out.println("Town is " + Town.this);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обычный внутренний класс является таким же членом внешнего класса, как и переменные и методы. Следующие модификаторы могут быть применены к обычному внутреннему классу:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>final</code></p>
</li>
<li>
<p><code>abstract</code></p>
</li>
<li>
<p><code>public</code></p>
</li>
<li>
<p><code>private</code></p>
</li>
<li>
<p><code>protected</code></p>
</li>
<li>
<p><code>static</code> – но <code>static</code> преобразует его во вложенный класс</p>
</li>
<li>
<p><code>strictfp</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если метод описан как <code>strictfp</code> (явно либо неявно), то JVM гарантирует, что результаты вычисления выражений с <code>double</code> и <code>float</code> в пределах метода будут одинаковыми на всех платформах. Модификатор <code>strictfp</code> для класса и интерфейса указывает на то, что все методы класса/интерфейса будут <code>strictfp</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_локальный_класс_java">4.13.2. Локальный класс Java</h4>
<div class="paragraph">
<p><strong>Локальный класс</strong> (<strong>local class</strong>) определяется в блоке Java кода. На практике чаще всего объявление происходит в методе некоторого другого класса. Как и <strong>inner classes</strong>, локальные классы ассоциируются с экземпляром внешнего класса и имеют доступ к его полям и методам.</p>
</div>
<div class="paragraph">
<p>Локальный класс может обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором <code>final</code> или являются <strong>effective final</strong> (начиная с Java 8).</p>
</div>
<div class="paragraph">
<p><strong>Effective final переменная</strong> это переменная, которая не объявлена явно как <code>final</code>, но ее значение не меняется.</p>
</div>
<div class="paragraph">
<p>Экземпляр класса может быть создан внутри того же метода, что и класс, но ниже объявления класса.</p>
</div>
<div class="paragraph">
<p>Локальные классы не могут быть объявлены как:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>private</code></p>
</li>
<li>
<p><code>public</code></p>
</li>
<li>
<p><code>protected</code></p>
</li>
<li>
<p><code>static</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Они не могут иметь внутри себя статических объявлений (полей, методов, классов). Исключением являются константы (<code>static final</code>).</p>
</div>
<div class="paragraph">
<p>Локальные классы могут быть объявлены как <code>abstract</code> или <code>final</code>.</p>
</div>
<div class="paragraph">
<p>Рассмотрим пример объявления локального класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Town2 {
    private String postCode = "33333";

    public void createAddress() {
        final int houseNumber = 34;
        class Street {
            public void printAddress() {
                System.out.println("PostCode is " + postCode);
                System.out.println("House Number is " + houseNumber);
            }
        }
        Street street = new Street();
        street.printAddress();
    }

    public static void main(String[] args) {
        Town2 town = new Town2();
        town.createAddress();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если локальный класс объявлен внутри статического метода, он имеет доступ только к статическим переменным класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Town3 {
    private static String postCode = "33333";

    public static void createAddress() {
        final int houseNumber = 34;
        class Street {
            public void printAddress() {
                System.out.println("PostCode is " + postCode);
                System.out.println("House Number is " + houseNumber);
            }
        }
        Street street = new Street();
        street.printAddress();
    }

    public static void main(String[] args) {
        Town3.createAddress();
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_анонимный_класс">4.13.3. Анонимный класс</h4>
<div class="paragraph">
<p><strong>Анонимный класс</strong> (<strong>anonymous class</strong>) - это локальный класс без имени. Используется тогда, когда нужно переопределить метод класса или интерфейса. Класс одновременно объявляется и инициализируется.</p>
</div>
<div class="paragraph">
<p>Они могут быть объявлены не только в методе, но и внутри аргумента метода.</p>
</div>
<div class="paragraph">
<p>Рассмотрим пример анонимного класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Potato {
    public void peel() {
        System.out.println("Чистим картошку.");
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Food {
    public static void main(String[] args) {
        Potato potato = new Potato() {
            @Override
            public void peel() {
                System.out.println("Чистим картошку в анонимном классе.");
            }
        };
        potato.peel();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Анонимный класс может не только переопределить методы класса наследника, но и добавить новые методы. Но новые методы НЕ могут быть вызваны извне анонимного класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class AnotherFood {
    public static void main(String[] args) {
        Potato potato = new Potato() {
            public void fry() {
                System.out.println("Жарим картошку в анонимном классе.");
            }

            @Override
            public void peel() {
                System.out.println("Чистим картошку в анонимном классе.");
                fry();
            }
        };
        potato.peel();
        //Ошибка компиляции
        //potato.fry();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Случаи использования анонимного класса:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Тело класса является очень коротким.</p>
</li>
<li>
<p>Нужен только один экземпляр класса.</p>
</li>
<li>
<p>Класс используется в месте его создания или сразу после него.</p>
</li>
<li>
<p>Имя класса не важно и не облегчает понимание кода.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Анонимный класс могут также расширять интерфейс:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public interface Moveable {
    void moveRight();
    void moveLeft();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class MoveableDemo {
    public static void main(String[] args) {
        Moveable moveable = new Moveable() {
            @Override
            public void moveRight() {
                System.out.println("MOVING RIGHT!!!");
            }

            @Override
            public void moveLeft() {
                System.out.println("MOVING LEFT!!!");
            }
        };
        moveable.moveRight();
        moveable.moveLeft();
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_статический_вложенный_класс">4.13.4. Статический вложенный класс</h4>
<div class="paragraph">
<p><strong>Статический вложенный класс</strong> (<strong>static nested class</strong>) – это внутренний класс объявленный с модификатором <code>static</code>.</p>
</div>
<div class="paragraph">
<p>Статический вложенный класс не имеет доступа к нестатическим полям и методам внешнего класса. Доступ к нестатическим полям и методам может осуществляться только через ссылку на экземпляр внешнего класса. В этом плане <code>static</code> nested классы очень похожи на любые другие классы верхнего уровня.</p>
</div>
<div class="paragraph">
<p>Рассмотрим примеры объявления статических вложенных классов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Town4 {
    public static class Street {
        public void go() {
            System.out.println("Go to the Street.");
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class City {
    public static class District {
        public void go() {
            System.out.println("Go to the District.");
        }
    }

    public static void main(String[] args) {
        Town4.Street street = new Town4.Street();
        street.go();
        District district = new District();
        district.go();
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_java_misc">5. Java Misc</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_stringbuffer_и_stringbuilder">5.1. <code>StringBuffer</code> и <code>StringBuilder</code></h3>
<div class="paragraph">
<p>Объекты <code>String</code> являются неизменяемыми, поэтому все операции, которые изменяют строки, фактически приводят к созданию новой строки, что сказывается на производительности приложения. Для решения этой проблемы, чтобы работа со строками проходила с меньшими издержками в Java были добавлены классы <code>StringBuffer</code> и <code>StringBuilder</code>. По сути они напоминает расширяемую строку, которую можно изменять без ущерба для производительности.</p>
</div>
<div class="paragraph">
<p>Эти классы похожи, практически двойники, они имеют одинаковые конструкторы, одни и те же методы, которые одинаково используются. Единственное их различие состоит в том, что класс <code>StringBuffer</code> синхронизированный и потокобезопасный. То есть класс <code>StringBuffer</code> удобнее использовать в многопоточных приложениях, где объект данного класса может меняться в различных потоках. Если же речь о многопоточных приложениях не идет, то лучше использовать класс <code>StringBuilder</code>, который не потокобезопасный, но при этом работает быстрее, чем <code>StringBuffer</code> в однопоточных приложениях.</p>
</div>
<div class="paragraph">
<p><code>StringBuffer</code> определяет четыре конструктора:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">StringBuffer()
StringBuffer(int capacity)
StringBuffer(String str)
StringBuffer(CharSequence chars)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Аналогичные конструкторы определяет <code>StringBuilder</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">StringBuilder()
StringBuilder(int capacity)
StringBuilder(String str)
StringBuilder(CharSequence chars)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Рассмотрим работу этих классов на примере функциональности <code>StringBuffer</code>.</p>
</div>
<div class="paragraph">
<p>При всех операциях со строками <code>StringBuffer</code> / <code>StringBuilder</code> перераспределяет выделенную память. И чтобы избежать слишком частого перераспределения памяти, <code>StringBuffer</code>/<code>StringBuilder</code> заранее резервирует некоторую область памяти, которая может использоваться. Конструктор без параметров резервирует в памяти место для 16 символов. Если мы хотим, чтобы количество символов было иным, то мы можем применить второй конструктор, который в качестве параметра принимает количество символов.</p>
</div>
<div class="paragraph">
<p>Третий и четвертый конструкторы обоих классов принимают строку и набор символов, при этом резервируя память для дополнительных 16 символов.</p>
</div>
<div class="paragraph">
<p>С помощью метода <code>capacity()</code> мы можем получить количество символов, для которых зарезервирована память. А с помощью метода <code>ensureCapacity()</code> изменить минимальную емкость буфера символов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str = "Java";
StringBuffer strBuffer = new StringBuffer(str);
System.out.println("Емкость: " + strBuffer.capacity()); // 20
strBuffer.ensureCapacity(32);
System.out.println("Емкость: " + strBuffer.capacity()); // 42
System.out.println("Длина: " + strBuffer.length()); // 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так как в самом начале <code>StringBuffer</code> инициализируется строкой <code>"Java"</code>, то его емкость составляет 4 + 16 = 20 символов. Затем мы увеличиваем емкость буфера с помощью вызова <code>strBuffer.ensureCapacity(32)</code> повышаем минимальную емкость буфера до 32 символов. Однако финальная емкость может отличаться в большую сторону. Так, в данном случае я получаю емкость не 32 и не 32 + 4 = 36, а 42 символа. Дело в том, что в целях повышения эффективности Java может дополнительно выделять память.</p>
</div>
<div class="paragraph">
<p>Но в любом случае вне зависимости от емкости длина строки, которую можно получить с помощью метода <code>length()</code>, в <code>StringBuffer</code> остается прежней - 4 символа (так как в <code>"Java"</code> 4 символа).</p>
</div>
<div class="paragraph">
<p>Чтобы получить строку, которая хранится в <code>StringBuffer</code>, мы можем использовать стандартный метод <code>toString()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String str = "Java";
StringBuffer strBuffer = new StringBuffer(str);
System.out.println(strBuffer.toString()); // Java</code></pre>
</div>
</div>
<div class="paragraph">
<p>По всем своим операциям <code>StringBuffer</code> и <code>StringBuilder</code> напоминают класс <code>String</code>.</p>
</div>
<div class="sect3">
<h4 id="_charat_и_setcharat">5.1.1. <code>charAt()</code> и <code>setCharAt()</code></h4>
<div class="paragraph">
<p>Метод <code>charAt()</code> получает, а метод <code>setCharAt()</code> устанавливает символ по определенному индексу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">StringBuffer strBuffer = new StringBuffer("Java");
char c = strBuffer.charAt(0); // J
System.out.println(c);
strBuffer.setCharAt(0, 'c');
System.out.println(strBuffer.toString()); // cava</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_getchars_2">5.1.2. <code>getChars()</code></h4>
<div class="paragraph">
<p>Метод <code>getChars()</code> получает набор символов между определенными индексами:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">StringBuffer strBuffer = new StringBuffer("world");
int startIndex = 1;
int endIndex = 4;
char[] buffer = new char[endIndex-startIndex];
strBuffer.getChars(startIndex, endIndex, buffer, 0);
System.out.println(buffer); // orl</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_append">5.1.3. <code>append()</code></h4>
<div class="paragraph">
<p>Метод <code>append()</code> добавляет подстроку в конец <code>StringBuffer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">StringBuffer strBuffer = new StringBuffer("hello");
strBuffer.append(" world");
System.out.println(strBuffer.toString()); // hello world</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_insert">5.1.4. <code>insert()</code></h4>
<div class="paragraph">
<p>Метод <code>insert()</code> добавляет строку или символ по определенному индексу в <code>StringBuffer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">StringBuffer strBuffer = new StringBuffer("word");

strBuffer.insert(3, 'l');
System.out.println(strBuffer.toString()); // world

strBuffer.insert(0, "s");
System.out.println(strBuffer.toString()); // sworld</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_delete_и_deletecharat">5.1.5. <code>delete()</code> и <code>deleteCharAt()</code></h4>
<div class="paragraph">
<p>Метод <code>delete()</code> удаляет все символы с определенного индекса о определенной позиции, а метод <code>deleteCharAt()</code> удаляет один символ по определенному индексу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">StringBuffer strBuffer = new StringBuffer("assembler");
strBuffer.delete(0,2);
System.out.println(strBuffer.toString()); // sembler

strBuffer.deleteCharAt(6);
System.out.println(strBuffer.toString()); // semble</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_substring_2">5.1.6. <code>substring()</code></h4>
<div class="paragraph">
<p>Метод <code>substring()</code> обрезает строку с определенного индекса до конца, либо до определенного индекса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">StringBuffer strBuffer = new StringBuffer("hello java!");
String str1 = strBuffer.substring(6); // обрезка строки с 6 символа до конца
System.out.println(str1); //java!

String str2 = strBuffer.substring(3, 9); // обрезка строки с 3 по 9 символ
System.out.println(str2); //lo jav</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_setlength">5.1.7. <code>setLength()</code></h4>
<div class="paragraph">
<p>Для изменения длины <code>StringBuffer</code> (не емкости буфера символов) применяется метод <code>setLength()</code>. Если <code>StringBuffer</code> увеличивается, то его строка просто дополняется в конце пустыми символами, если уменьшается - то строка по сути обрезается:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">StringBuffer strBuffer = new StringBuffer("hello");
strBuffer.setLength(10);
System.out.println(strBuffer.toString()); // "hello     "

strBuffer.setLength(4);
System.out.println(strBuffer.toString()); // "hell"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_replace_2">5.1.8. <code>replace()</code></h4>
<div class="paragraph">
<p>Для замены подстроки между определенными позициями в <code>StringBuffer</code> на другую подстроку применяется метод <code>replace()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">StringBuffer strBuffer = new StringBuffer("hello world!");
strBuffer.replace(6, 11, "java");
System.out.println(strBuffer.toString()); // hello java!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Первый параметр метода <code>replace()</code> указывает, с какой позиции надо начать замену, второй параметр - до какой позиции, а третий параметр указывает на подстроку замены.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reverse">5.1.9. <code>reverse()</code></h4>
<div class="paragraph">
<p>Метод <code>reverse()</code> меняет порядок в <code>StringBuffer</code> на обратный:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">StringBuffer strBuffer = new StringBuffer("assembler");
strBuffer.reverse();
System.out.println(strBuffer.toString()); // relbmessa</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_форматирование_строк">5.2. Форматирование строк</h3>
<div class="sect3">
<h4 id="_класс_formatter">5.2.1. Класс <code>Formatter</code></h4>
<div class="paragraph">
<p>Базовой частью поддержки создания форматированного вывода в языке Java служит класс <code>Formatter</code>, включенный в пакет <code>java.util</code>. Он обеспечивает <strong>преобразования формата</strong> (<strong>format conversions</strong>) позволяющие выводить числа, строки и время и даты практически в любом понравившемся вам формате.</p>
</div>
<div class="paragraph">
<p>В классе <code>Formatter</code> объявлен метод <code>format()</code>, который преобразует переданные в него параметры в строку заданного формата и сохраняет в объекте типа <code>Formatter</code>.</p>
</div>
<div class="paragraph">
<p>Рассмотрим использование класса <code>Formatter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.Formatter;

public class SimpleFormatString {
    public static void main(String[] args) {
        Formatter f = new Formatter();
        f.format("This %s is about %n%S %c", "book", "java", '8');
        System.out.print(f);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>где <code>%s</code> называется <strong>спецификатором формата</strong>.</p>
</div>
<div class="paragraph">
<p>Следующий пример использует класс <code>Formatter</code> для отображения дробного числа:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.Formatter;

public class FormatDemo1 {
    public static void main(String[] args) {
        double x = 1000.0 / 3.0;
        System.out.println("Строка без форматирования: " + x);

        Formatter formatter = new Formatter();
        formatter.format("Строка c форматированием: %.2f%n", x);
        formatter.format("Строка c форматированием: %8.2f%n", x);
        formatter.format("Строка c форматированием: %16.2f%n", x);
        System.out.println(formatter);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_метод_format_классов_string_printstream_и_printwriter">5.2.2. Метод <code>format()</code> классов <code>String</code>, <code>PrintStream</code> и <code>PrintWriter</code></h4>
<div class="paragraph">
<p>Аналогичный метод <code>format()</code> объявлен у классов <code>PrintStream</code> и <code>PrintWriter</code>. <code>System.out</code> это статическая переменная типа <code>PrintStream</code>.</p>
</div>
<div class="paragraph">
<p>В Java 5 для классов <code>PrintStream</code> и <code>PrintWriter</code> добавлен метод <code>printf()</code>. Методы <code>printf()</code> и <code>format()</code> автоматически используют класс <code>Formatter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class FormatDemo4 {
    public static void main(String[] args) {
        System.out.printf("Строка c форматированием: %.2f%n", 1000.0 / 3.0);
        System.out.format("%s, в следующем году вам будет %d", "Джон", 23);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>С помощью метода <code>String.format()</code> тоже возможно форматирование:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class StringFormatDemo {
    public static void main(String[] args) {
        String str = String.format("Строка c форматированием: %16.2f", 1000.0 / 3.0);
        System.out.println(str);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_спецификаторы_формата">5.2.3. Спецификаторы формата</h4>
<div class="ulist">
<ul>
<li>
<p><code>%a</code> Шестнадцатеричное значение с плавающей точкой</p>
</li>
<li>
<p><code>%b</code> Логическое (булево) значение аргумента</p>
</li>
<li>
<p><code>%c</code> Символьное представление аргумента</p>
</li>
<li>
<p><code>%d</code> Десятичное целое значение аргумента</p>
</li>
<li>
<p><code>%h</code> Хэш-код аргумента</p>
</li>
<li>
<p><code>%e</code> Экспоненциальное представление аргумента</p>
</li>
<li>
<p><code>%f</code> Десятичное значение с плавающей точкой</p>
</li>
<li>
<p><code>%g</code> Выбирает более короткое представление из двух: <code>%е</code> или <code>%f</code></p>
</li>
<li>
<p><code>%o</code> Восьмеричное целое значение аргумента</p>
</li>
<li>
<p><code>%n</code> Вставка символа новой строки</p>
</li>
<li>
<p><code>%s</code> Строковое представление аргумента</p>
</li>
<li>
<p><code>%t</code> Время и дата</p>
</li>
<li>
<p><code>%x</code> Шестнадцатеричное целое значение аргумента</p>
</li>
<li>
<p><code>%%</code> Вставка знака <code>%</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_флаги_формата">5.2.4. Флаги формата</h4>
<div class="ulist">
<ul>
<li>
<p><code>-</code> выравнивание влево</p>
</li>
<li>
<p><code>#</code> изменяет формат преобразования</p>
</li>
<li>
<p><code>0</code> выводит значение, дополненное нулями вместо пробелов. Применим только к числам</p>
</li>
<li>
<p>` ` положительные числа предваряются пробелом</p>
</li>
<li>
<p><code>+</code> положительные числа предваряются знаком +. Применим только к числам</p>
</li>
<li>
<p><code>,</code> числовые значения включают разделители групп. Применим только к числам</p>
</li>
<li>
<p><code>(</code> отрицательные числовые значения заключаются в скобки. Применим только к числам</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Рассмотрим пример использования флагов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class FormatterDemo2 {
    public static void main(String[] args) {
        System.out.printf("%,.2f%n", 10000.0 / 3.0);
        System.out.printf("%, (.2f%n", -10000.0 / 3.0);
        System.out.printf("%09.2f%n", 10000.0 / 3.0);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В строке, определяющей формат, может задаваться индекс форматируемого параметра. Индекс должен следовать непосредственно за символом <code>%</code> и завершаться знаком <code>$</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class FormatterDemo3 {
    public static void main(String[] args) {
        System.out.printf("Hello %1$s!%n%1$s, how are you?%n"
                        + "Welcome to the site %2$s",
                "John", "www.site.com");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Общий синтаксис можно описать так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">%[аргумент_индекс][флаги][ширина][.точность]символ_преобразования</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_перечисления">5.3. Перечисления</h3>
<div class="paragraph">
<p>Кроме отдельных примитивных типов данных и классов в <strong>Java</strong> есть такой тип как <code>enum</code> или <strong>перечисление</strong>. Перечисления представляют набор логически связанных констант. Объявление перечисления происходит с помощью оператора <code>enum</code>, после которого идет название перечисления. Затем идет список элементов перечисления через запятую:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">enum Day {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Перечисление фактически представляет новый тип, поэтому мы можем определить переменную данного типа и использовать ее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Day current = Day.MONDAY;
        System.out.println(current); // MONDAY
    }
}

enum Day {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Перечисления могут использоваться в классах для хранения данных:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Book b1 = new Book("War and Peace", "L. Tolstoy", Type.BELLETRE);
        System.out.printf("Book '%s' has a type %s", b1.name, b1.bookType);

        switch (b1.bookType) {
            case BELLETRE:
                System.out.println("Belletre");
                break;
            case SCIENCE:
                System.out.println("Science");
                break;
            case SCIENCE_FICTION:
                System.out.println("Science fiction");
                break;
            case PHANTASY:
                System.out.println("Phantasy");
                break;
        }
    }
}

class Book {
    String name;
    Type bookType;
    String author;

    Book(String name, String author, Type type) {
        bookType = type;
        this.name = name;
        this.author = author;
    }
}

enum Type {
    SCIENCE,
    BELLETRE,
    PHANTASY,
    SCIENCE_FICTION
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Само перечисление объявлено вне класса, оно содержит четыре жанра книг. Класс <code>Book</code> кроме обычных переменных содержит также переменную типа нашего перечисления. В конструкторе мы ее также можем присвоить, как и обычные поля класса.</p>
</div>
<div class="paragraph">
<p>С помощью конструкции <code>switch..case</code> можно проверить принадлежность значения <code>bookType</code> определенной константе перечисления.</p>
</div>
<div class="sect3">
<h4 id="_методы_перечислений">5.3.1. Методы перечислений</h4>
<div class="paragraph">
<p>Каждое перечисление имеет статический метод <code>values()</code>. Он возвращает массив всех констант перечисления:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Type[] types = Type.values();
        for (Type s : types) {
            System.out.println(s);
        }
    }
}

enum Type {
    SCIENCE,
    BELLETRE,
    PHANTASY,
    SCIENCE_FICTION
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>ordinal()</code> возвращает порядковый номер определенной константы (нумерация начинается с <code>0</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">System.out.println(Type.BELLETRE.ordinal()); // 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_конструкторы_поля_и_методы_перечисления">5.3.2. Конструкторы, поля и методы перечисления</h4>
<div class="paragraph">
<p>Перечисления, как и обычные классы, могут определять конструкторы, поля и методы. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        System.out.println(Color.RED.getCode()); // #FF0000
        System.out.println(Color.GREEN.getCode()); // #00FF00
    }
}

enum Color {
    RED("#FF0000"), BLUE("#0000FF"), GREEN("#00FF00");
    private String code;

    Color(String code) {
        this.code = code;
    }

    public String getCode() {
        return code;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Перечисление <code>Color</code> определяет приватное поле <code>code</code> для хранения кода цвета, а с помощью метода <code>getCode()</code> оно возвращается. Через конструктор передается для него значение. Следует отметить, что конструктор по умолчанию приватный, то есть имеет модификатор <code>private</code>. Любой другой модификатор будет считаться ошибкой. Поэтому создать константы перечисления с помощью конструктора мы можем только внутри перечисления.</p>
</div>
<div class="paragraph">
<p>Также можно определять методы для отдельных констант:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Operation op = Operation.SUM;
        System.out.println(op.action(10, 4)); // 14
        op = Operation.MULTIPLY;
        System.out.println(op.action(6, 4)); // 24
    }
}

enum Operation {
    SUM {
        public int action(int x, int y) {
            return x + y;
        }
    },
    SUBTRACT {
        public int action(int x, int y) {
            return x - y;
        }
    },
    MULTIPLY {
        public int action(int x, int y) {
            return x * y;
        }
    };

    public abstract int action(int x, int y);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_класс_object">5.4. Класс <code>Object</code></h3>
<div class="paragraph">
<p>Хотя мы можем создать обычный класс, который не является наследником, но фактически все классы наследуют от класса <code>Object</code>. Все остальные классы, даже те, которые мы добавляем в свой проект, являются неявно производными от класса <code>Object</code>. Поэтому все типы и классы могут реализовать те методы, которые определены в классе <code>Object</code>.</p>
</div>
<div class="sect3">
<h4 id="_hashcode">5.4.1. <code>hashCode()</code></h4>
<div class="sect4">
<h5 id="_что_такое_хеш_код">Что такое хеш-код?</h5>
<div class="paragraph">
<p>Если очень просто, то (<strong>хеш-код</strong>) — это число. Если более точно, то это <em>битовая строка фиксированной длины</em>, <em>полученная из массива произвольной длины</em>.</p>
</div>
<div class="paragraph">
<p>Выполним следующий код:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Main {
    public static void main(String[] args) {
        Object object = new Object();
        int hCode;
        hCode = object.hashCode();
        System.out.println(hCode);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В результате выполнения программы в консоль выведется целое 10-ти значное число. Это число и есть <em>битовая строка фиксированной длины</em>. В java она представлена в виде числа примитивного типа <code>int</code>, который равен 4-м байтам, и может помещать числа от <code>-2_147_483_648</code> до <code>2_147_483_647</code>. На данном этапе важно понимать, что <strong>хеш-код</strong> это число, у которого есть свой предел, который для java ограничен примитивным целочисленным типом <code>int</code>.</p>
</div>
<div class="paragraph">
<p>Вторая часть объяснения гласит: <em>полученная из массива произвольной длины</em>. Под массивом произвольной длины будет понимать объект. В примере выше в качестве массива произвольной длины выступает объект типа <code>Object</code>.</p>
</div>
<div class="paragraph">
<p>В итоге в терминах Java, <strong>хеш-код</strong> — это целочисленный результат работы метода, которому в качестве входного параметра передан объект.</p>
</div>
<div class="paragraph">
<p>Этот метод реализован таким образом, что для одного и того-же входного объекта, хеш-код всегда будет одинаковым. Следует понимать, что множество возможных хеш-кодов ограничено примитивным типом <code>int</code>, а множество объектов ограничено только нашей фантазией. Отсюда следует утверждение: <em>Множество объектов мощнее множества хеш-кодов</em>. Из-за этого ограничения, вполне возможна ситуация, что хеш-коды разных объектов могут совпасть.</p>
</div>
<div class="paragraph">
<p>Здесь главное понять, что:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Если хеш-коды разные, то и входные объекты гарантированно будут разные.</p>
</li>
<li>
<p>Если хеш-коды равны, то входные объекты не всегда равны.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ситуация, когда у разных объектов одинаковые хеш-коды называется — <strong>коллизией</strong>. <em>Вероятность возникновения коллизии</em> зависит от используемого <em>алгоритма генерации хеш-кода</em>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_hashcode_2"><code>hashCode()</code></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Person tom = new Person("Tom");
System.out.println(tom.hashCode()); // 2036368507</code></pre>
</div>
</div>
<div class="paragraph">
<p>Но мы можем задать свой алгоритм определения хэш-кода объекта:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    @Override
    public int hashCode(){
        return 11 * name.hashCode() + 7;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_подведём_итог">Подведём итог</h5>
<div class="paragraph">
<p><strong>Одинаковые объекты</strong> — это объекты одного класса с одинаковым содержимым полей.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Для одного и того-же объекта, хеш-код всегда будет одинаковым</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../assets/img/java/core/misc/hash-code-1.png" alt="Hash Code">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Если объекты одинаковые, то и хеш-коды будут одинаковые, но не наоборот.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../assets/img/java/core/misc/hash-code-2.png" alt="Hash Code">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Если хеш-коды равны, то входные объекты не всегда равны (коллизия).</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../assets/img/java/core/misc/hash-code-3.png" alt="Hash Code">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Если хеш-коды разные, то и объекты гарантированно будут разные.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../assets/img/java/core/misc/hash-code-4.png" alt="Hash Code">
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_понятие_эквивалентности_метод_equals">5.4.2. Понятие эквивалентности. Метод equals()</h4>
<div class="paragraph">
<p>В java, каждый вызов оператора <code>new</code> порождает новый объект в памяти. Для иллюстрации создадим какой-нибудь класс, пускай он будет называться <code>BlackBox</code>.</p>
</div>
<div class="paragraph">
<p>Выполним следующий код:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class BlackBox {
    int varA;
    int varB;

    BlackBox(int varA, int varB){
        this.varA = varA;
        this.varB = varB;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Создадим класс для демонстрации <code>BlackBox</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class DemoBlackBox {
    public static void main(String[] args) {
        BlackBox object1 = new BlackBox(5, 10);
        BlackBox object2 = new BlackBox(5, 10);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом примере, в памяти создастся два объекта.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../assets/img/java/core/misc/equals.png" alt="Equals">
</div>
</div>
<div class="paragraph">
<p>Но, как вы уже обратили внимание, содержимое этих объектов одинаково, то есть эквивалентно. Для проверки эквивалентности в классе <code>Object</code> существует метод <code>equals()</code>, который сравнивает содержимое объектов и выводит значение типа <code>boolean</code> <code>true</code>, если содержимое эквивалентно, и <code>false</code> — если нет.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">object1.equals(object2); // должно быть true, поскольку содержимое объектов эквивалентно</code></pre>
</div>
</div>
<div class="paragraph">
<p>Эквивалентность и хеш-код тесно связанны между собой, поскольку хеш-код вычисляется на основании содержимого объекта (значения полей) и <em>если у двух объектов одного и того же класса содержимое одинаковое, то и хеш-коды должны быть одинаковые</em>.</p>
</div>
<div class="paragraph">
<p>Иными словами:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">object1.equals(object2); // должно быть true
object1.hashCode() == object2.hashCode(); // должно быть true</code></pre>
</div>
</div>
<div class="paragraph">
<p>"Должно быть", потому что если вы выполните предыдущий пример, то на самом деле результатом выполнения всех операций будет <code>false</code>. Для пояснения причин, заглянем в исходные коды класса <code>Object</code>.</p>
</div>
<div class="sect4">
<h5 id="_пример">Пример</h5>
<div class="paragraph">
<p>Метод <code>equals()</code> сравнивает два объекта на равенство:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person tom = new Person("Tom");
        Person bob = new Person("Bob");
        System.out.println(tom.equals(bob)); // false

        Person tom2 = new Person("Tom");
        System.out.println(tom.equals(tom2)); // true
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Person) {
            Person p = (Person) obj;
            return (this.name == p.name);
        }
        return false;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>equals()</code> принимает в качестве параметр объект любого типа, который мы затем приводим к текущему, если они являются объектами одного класса.</p>
</div>
<div class="paragraph">
<p>Оператор <code>instanceof</code> позволяет выяснить, является ли переданный в качестве параметра объект объектом определенного класса, в данном случае класса <code>Person</code>.
Затем сравниваем по именам. Если они совпадают, возвращаем <code>true</code>, что будет говорить, что объекты равны.</p>
</div>
<div class="paragraph">
<p>Если объекты принадлежат к разным классам, то их сравнение не имеет смысла, и возвращается значение <code>false</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_класс_object_2">5.4.3. Класс <code>Object</code></h4>
<div class="paragraph">
<p>Как известно, все java-классы наследуются от класса <code>Object</code>. В этом классе уже определены методы <code>hashCode()</code> и <code>equals()</code>.</p>
</div>
<div class="paragraph">
<p>Определяя свой класс, вы автоматически наследуете все методы класса <code>Object</code>. И в ситуации, когда в вашем классе не переопределены (<strong>overriding</strong>) <code>hashCode()</code> и <code>equals()</code>, то используется их реализация из <code>Object</code>.</p>
</div>
<div class="paragraph">
<p>Рассмотрим исходный код метода <code>equals()</code> в классе <code>Object</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public boolean equals(Object obj) {
    return (this == obj);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>При сравнении объектов, операция <code>==</code> вернет <code>true</code> лишь в одном случае — когда ссылки указывают на один и тот-же объект. В данном случае не учитывается содержимое полей.</p>
</div>
<div class="paragraph">
<p>Выполнив приведённый ниже код, <code>equals()</code> вернет <code>true</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class DemoBlackBox {
    public static void main(String[] args) {
        BlackBox object3 = new BlackBox(5, 10);
        BlackBox object4 = object3; // Переменная object4 ссылается на
        // тот-же объект что и переменная object3
        object3.equals(object4); // true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь понято, почему <code>Object.equals()</code> работает не так как нужно, ведь он сравнивает ссылки, а не содержимое объектов.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../assets/img/java/core/misc/equals-objects.png" alt="Equals">
</div>
</div>
<div class="paragraph">
<p>Далее на очереди <code>hashCode()</code>, который тоже работает не так как полагается.</p>
</div>
<div class="paragraph">
<p>Заглянем в исходный код метода <code>hashCode()</code> в классе <code>Object</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public native int hashCode();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вот собственно и вся реализация. Ключевое слово <code>native</code> означает, что реализация данного метода выполнена на другом языке, например на C, C или *ассемблере*. Конкретный `native int hashCode()` реализован на C, вот исходники функции <a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/tip/src/share/vm/runtime/synchronizer.cpp"><code>get_next_hash</code></a>.</p>
</div>
<div class="paragraph">
<p>При вычислении хэш-кода для объектов класса <code>Object</code> по умолчанию используется <strong>Park-Miller RNG</strong> алгоритм. В основу работы данного алгоритма положен генератор случайных чисел. Это означает, что при каждом запуске программы у объекта будет разный хэш-код.</p>
</div>
<div class="paragraph">
<p>Получается, что используя реализацию метода <code>hashCode()</code> от класса <code>Object</code>, мы при каждом создании объекта класса new <code>BlackBox()</code>, будем получать разные хеш-коды. Мало того, перезапуская программу, мы будем получать абсолютно разные значения, поскольку это просто случайное число.</p>
</div>
<div class="paragraph">
<p>Но, как мы помним, должно выполняться правило: <em>если у двух объектов одного и того же класса содержимое одинаковое, то и хеш-коды должны быть одинаковые</em>. Поэтому, при создании пользовательского класса, принято переопределять методы <code>hashCode()</code> и <code>equals()</code> таким образом, что бы учитывались поля объекта.
Это можно сделать вручную либо воспользовавшись средствами генерации исходного кода в <strong>IDE</strong>. Например, в <strong>Eclipse</strong> это <em>Source</em> &#8594; <em>Generate hashCode() and equals()&#8230;&#8203;</em></p>
</div>
<div class="paragraph">
<p>В итоге класс <code>BlackBox</code> приобретает вид:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class BlackBox {
    int varA;
    int varB;

    BlackBox(int varA, int varB) {
        this.varA = varA;
        this.varB = varB;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + varA;
        result = prime * result + varB;
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        BlackBox other = (BlackBox) obj;
        if (varA != other.varA)
            return false;
        if (varB != other.varB)
            return false;
        return true;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь методы <code>hashCode()</code> и <code>equals()</code> работают корректно и учитывают содержимое полей объекта:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">object1.equals(object2); // true
object1.hashCode() == object2.hashCode(); // true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Поэтому создавая пользовательский класс, нужно переопределять методы <code>hashCode()</code> и <code>equals()</code>, что бы они корректно работали и учитывали данные объекта. Кроме того, если оставить реализацию из <code>Object</code>, то при использовании <code>java.util.HashMap</code> возникнут проблемы, поскольку <code>HashMap</code> активно используют <code>hashCode()</code> и <code>equals()</code> в своей работе.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tostring">5.4.4. <code>toString()</code></h4>
<div class="paragraph">
<p>Метод <code>toString()</code> служит для получения представления данного объекта в виде строки. При попытке вывести строковое представления какого-нибудь объекта, как правило, будет выводиться полное имя класса. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person tom = new Person("Tom");
        System.out.println(tom.toString()); // Будет выводить что-то наподобие Person@7960847b
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Полученное мной значение (в данном случае <code>Person@7960847b</code>) вряд ли может служить хорошим строковым описанием объекта. Поэтому метод <code>toString()</code> нередко переопределяют. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person tom = new Person("Tom");
        System.out.println(tom.toString()); // Person Tom
    }
}

class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Person " + name;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_getclass">5.4.5. <code>getClass()</code></h4>
<div class="paragraph">
<p>Метод <code>getClass()</code> позволяет получить тип данного объекта:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Person tom = new Person("Tom");
System.out.println(tom.getClass()); // class Person</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ссылочные_типы_и_клонирование_объектов">5.5. Ссылочные типы и клонирование объектов</h3>
<div class="paragraph">
<p>При работе с объектами классов надо учитывать, что они все представляют ссылочные типы, то есть указывают на какой-то объект, расположенный в памяти. Чтобы понять возможные трудности, с которыми мы можем столкнуться, рассмотрим пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Person tom = new Person("Tom", 23);
        tom.display(); // Person Tom
        Person bob = tom;
        bob.setName("Bob");
        tom.display(); // Person Bob
    }
}

class Person {
    private String name;
    private int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void setName(String name) {
        this.name = name;
    }

    void setAge(int age) {
        this.age = age;
    }

    void display() {
        System.out.printf("Person Name: %s \n", name);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь создаем два объекта <code>Person</code> и один присваиваем другому. Но, несмотря на то, что мы изменяем только объект <code>bob</code>, вместе с ним изменяется и объект <code>tom</code>. Потому что после присвоения они указывают на одну и ту же область в памяти, где собственно данные об объекте <code>Person</code> и его полях и хранятся.</p>
</div>
<div class="paragraph">
<p>Чтобы избежать этой проблемы, необходимо создать отдельный объект для переменной <code>bob</code>, например, с помощью метода <code>clone</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person implements Cloneable {
    private String name;
    private int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void setName(String name) {
        this.name = name;
    }

    void setAge(int age) {
        this.age = age;
    }

    void display() {
        System.out.printf("Person %s \n", name);
    }

    public Person clone() throws CloneNotSupportedException {
        return (Person) super.clone();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для реализации клонирования класс <code>Person</code> должен применить интерфейс <code>Cloneable</code>, который определяет метод <code>clone()</code>. Реализация этого метода просто возвращает вызов метода <code>clone()</code> для родительского класса - то есть класса <code>Object</code> с преобразованием к типу <code>Person</code>.</p>
</div>
<div class="paragraph">
<p>Кроме того, на случай если класс не поддерживает клонирование, метод должен выбрасывать исключение <code>CloneNotSupportedException</code>, что определяется с помощью оператора <code>throws</code>.</p>
</div>
<div class="paragraph">
<p>Затем с помощью вызова этого метода мы можем осуществить копирование:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">try {
    Person tom = new Person("Tom", 23);
    Person bob = tom.clone();
    bob.setName("Bob");
    tom.display(); // Person Tom
} catch (CloneNotSupportedException ex) {
    System.out.println("Clonable not implemented");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Однако данный способ осуществляет неполное копирование и подойдет, если клонируемый объект не содержит сложных объектов. Например, пусть класс <code>Book</code> имеет следующее определение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Book implements Cloneable {
    private String name;
    private Author author;

    public void setName(String n) {
        name = n;
    }

    public String getName() {
        return name;
    }

    public void setAuthor(String n) {
        author.setName(n);
    }

    public String getAuthor() {
        return author.getName();
    }

    Book(String name, String author) {
        this.name = name;
        this.author = new Author(author);
    }

    public String toString() {
        return "Книга '" + name + "' (автор " + author + ")";
    }

    public Book clone() throws CloneNotSupportedException {
        return (Book) super.clone();
    }
}

class Author {
    private String name;

    public void setName(String n) {
        name = n;
    }

    public String getName() {
        return name;
    }

    public Author(String name) {
        this.name = name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если мы попробуем изменить автора книги, нас последует неудача:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">try {
    Book book = new Book("War and Peace", "Leo Tolstoy");
    Book book2 = book.clone();
    book2.setAuthor("Ivan Turgenev");
    System.out.println(book.getAuthor());
} catch (CloneNotSupportedException ex) {
    System.out.println("Cloneable not implemented");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом случае, хотя переменные <code>book</code> и <code>book2</code> будут указывать на разные объекты в памяти, но эти объекты при этом будут указывать на один объект <code>Author</code>.</p>
</div>
<div class="paragraph">
<p>И в этом случае нам необходимо выполнить полное копирование. Для этого, во-первых, надо определить метод клонирования у класса <code>Author</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Author implements Cloneable {
    // остальной код класса

    public Author clone() throws CloneNotSupportedException {
        return (Author) super.clone();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>И затем исправим метод <code>clone()</code> в классе <code>Book</code> следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public Book clone() throws CloneNotSupportedException {
    Book newBook = (Book) super.clone();
    newBook.author = (Author) author.clone();
    return newBook;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_wrapper_classes">5.6. Wrapper Classes</h3>
<div class="sect3">
<h4 id="_wrapper_classes_2">5.6.1. Wrapper Classes</h4>
<div class="paragraph">
<p>Очень часто необходимо создать класс, основное назначение которого содержать в себе какое-то примитивное значение.
Например, как мы увидим в следующих занятиях, обобщенные классы и в частности коллекции работают только с объектами.
Поэтому, чтобы каждый разработчик не изобретал велосипед, в Java уже добавлены такие классы, которые называются <strong>Wrapper Classes</strong> (<strong>оболочки типов</strong>/<strong>классы обертки</strong>/<strong>wrappers</strong>).</p>
</div>
<div class="paragraph">
<p>К оболочкам типов относятся классы <code>Double</code>, <code>Float</code>, <code>Long</code>, <code>Integer</code>, <code>Short</code>, <code>Byte</code>, <code>Character</code>, <code>Boolean</code>, <code>Void</code>.
Для каждого примитивного значения и ключевого слова <code>void</code> есть свой класс-двойник.
Имя класса, как вы видите, совпадает с именем примитивного значения.
Исключения составляют класс <code>Integer</code> (примитивный тип <code>int</code>) и класс <code>Character</code> (примитивный тип <code>char</code>).
Кроме содержания в себе значения, классы оболочки предоставляют обширный ряд методов.</p>
</div>
<div class="paragraph">
<p>Объекты классов оболочек <strong>неизменяемые</strong> (<strong>immutable</strong>).
Это значит, что объект не может быть изменен.</p>
</div>
<div class="paragraph">
<p>Все классы-обертки числовых типов имеют переопределенный метод <code>equals(Object)</code>, сравнивающий примитивные значения объектов.</p>
</div>
<div class="sect4">
<h5 id="_конструкторы_оболочек">Конструкторы оболочек</h5>
<div class="paragraph">
<p>В следующей таблицы для каждого класса оболочки указан соответствующий примитивный тип и варианты конструкторов.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Примитивный тип</th>
<th class="tableblock halign-left valign-top">Оболочка</th>
<th class="tableblock halign-left valign-top">Аргументы конструктора</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code> or <code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>byte</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Byte</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>byte</code> or <code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>char</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Character</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>char</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>double</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Double</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>double</code> or <code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Float</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float</code>, double, or <code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Integer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code> or <code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>long</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Long</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>long</code> or <code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>short</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Short</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>short</code> or <code>String</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Как вы видите каждый класс имеет два конструктора, которые принимаю значения типа:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>соответствующего примитива</p>
</li>
<li>
<p><code>String</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Исключения: класс <code>Character</code>, у которого только один конструктор с аргументом <code>char</code> и класс <code>Float</code>, объявляющий три конструктора - для значения <code>float</code>, <code>String</code> и еще <code>double</code>.</p>
</div>
<div class="paragraph">
<p>Рассмотрим варианты вызова конструкторов на примере.
Чтобы создать объект класса <code>Integer</code>, передаем в конструктор либо значение типа <code>int</code> либо <code>String</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Integer i1 = new Integer(42);
Integer i2 = new Integer("42");

Float f1 = new Float(3.14f);
Float f2 = new Float("3.14f");

Character c1 = new Character('c');</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если передаваемая в конструктор строка не содержит числового значения, то выбросится исключение <code>NumberFormatException</code>.</p>
</div>
<div class="paragraph">
<p>При вызове конструктора с аргументом <code>String</code> класса <code>Boolean</code>, не обязательно передавать строки <code>true</code> или <code>false</code>.
Если аргумент содержит любую другую строку, просто будет создан объект, содержащий значение <code>false</code>.
Исключение выброшено не будет:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class WrapperDemo1 {
    public static void main(String[] args) {
        Boolean boolean1 = new Boolean(true);
        Boolean boolean2 = new Boolean("Some String");

        System.out.println(boolean2);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_методы_классов_оболочек">Методы классов оболочек</h5>
<div class="paragraph">
<p>Как уже было сказано, классы оболочки содержат обширный ряд методов.
Рассмотрим их.</p>
</div>
<div class="sect5">
<h6 id="_методы_valueof">Методы <code>valueOf()</code></h6>
<div class="paragraph">
<p>Метод <code>valueOf()</code> предоставляет второй способ создания объектов оболочек.
Метод перегруженный, для каждого класса существует два варианта - один принимает на вход значение соответствующего типа, а второй - значение типа <code>String</code>.
Так же как и с конструкторами, передаваемая строка должна содержать числовое значение.
Исключение составляет опять же класс <code>Character</code> - в нем объявлен только один метод, принимающий на вход значение <code>char</code>.</p>
</div>
<div class="paragraph">
<p>И в целочисленные классы <code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code> добавлен еще один метод, в который можно передать строку, содержащую число в любой системе исчисления.
Вторым параметром вы указываете саму систему исчисления.</p>
</div>
<div class="paragraph">
<p>В следующем примере показано использование всех трех вариантов для создания объектов класса <code>Integer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class WrapperValueOf {
    public static void main(String[] args) {
        Integer integer1 = Integer.valueOf("6");
        Integer integer2 = Integer.valueOf(6);
        // преобразовывает 101011 к 43
        Integer integer3 = Integer.valueOf("101011", 2);

        System.out.println(integer1);
        System.out.println(integer2);
        System.out.println(integer3);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_методы_parse">Методы <code>parse()</code></h6>
<div class="paragraph">
<p>В каждом классе оболочке содержатся методы, позволяющие преобразовывать строку в соответствующее примитивное значение.
В классе <code>Double</code> - это метод <code>parseDouble()</code>, в классе <code>Long</code> - <code>parseLong()</code> и так далее.
Разница с методом <code>valueOf()</code> состоит в том, что метод <code>valueOf()</code> возвращает объект, а <code>parse()</code> - примитивное значение.</p>
</div>
<div class="paragraph">
<p>Также в целочисленные классы <code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code> добавлен метод, в который можно передать строку, содержащую число в любой системе исчисления.
Вторым параметром вы указываете саму систему исчисления.
Следующий пример показывает использование метода <code>parseLong()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class WrapperDemo3 {
    public static void main(String[] args) {
        Long long1 = Long.valueOf("45");
        long long2 = Long.parseLong("67");
        long long3 = Long.parseLong("101010", 2);

        System.out.println("long1 = " + long1);
        System.out.println("long2 = " + long2);
        System.out.println("long3 = " + long3);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_методы_tostring">Методы <code>toString()</code></h6>
<div class="paragraph">
<p>Все типы-оболочки переопределяют <code>toString()</code>.
Этот метод возвращает читабельную для человека форму значения, содержащегося в оболочке.
Это позволяет выводить значение, передавая объект оболочки типа методу <code>println()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Double double1 = Double.valueOf("4.6");
System.out.println(double1);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Также все числовые оболочки типов предоставляют статический метод <code>toString()</code>, на вход которого передается примитивное значение.
Метод возвращает значение <code>String</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String string1 = Double.toString(3.14);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Integer</code> и <code>Long</code> предоставляют третий вариант <code>toString()</code> метода, позволяющий представить число в любой системе исчисления.
Он статический, первый аргумент – примитивный тип, второй - основание системы счисления:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String string2 = Long.toString(254, 16); // string2 = "fe"</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_методы_tohexstring_tooctalstring_tobinarystring">Методы <code>toHexString()</code>, <code>toOctalString()</code>, <code>toBinaryString()</code></h6>
<div class="paragraph">
<p><code>Integer</code> и <code>Long</code> позволяют преобразовывать числа из десятичной системы исчисления к шестнадцатеричной, восьмеричной и двоичной.
Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class WrapperToXString {
    public static void main(String[] args) {
        String string1 = Integer.toHexString(254);
        System.out.println("254 в 16-ой системе = " + string1);

        String string2 = Long.toOctalString(254);
        System.out.println("254 в  8-ой системе = " + string2);

        String string3 = Long.toBinaryString(254);
        System.out.println("254 в  2-ой системе = " + string3);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В классы <code>Double</code> и <code>Float</code> добавлен только метод <code>toHexString()</code>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_класс_number">Класс <code>Number</code></h5>
<div class="paragraph">
<p>Все оболочки числовых типов наследуют абстрактный класс <code>Number</code>. <code>Number</code> объявляет методы, которые возвращают значение объекта в каждом из различных числовых форматов.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../assets/img/java/core/misc/wrapper-classes/wrapper-classes.png" alt="Класс Number">
</div>
</div>
<div class="paragraph">
<p>Пример приведения типов</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class WrapperDemo2 {
    public static void main(String[] args) {
        Integer iOb = new Integer(1000);
        System.out.println(iOb.byteValue());
        System.out.println(iOb.shortValue());
        System.out.println(iOb.intValue());
        System.out.println(iOb.longValue());
        System.out.println(iOb.floatValue());
        System.out.println(iOb.doubleValue());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_статические_константы_классов_оболочек">Статические константы классов оболочек</h5>
<div class="paragraph">
<p>Каждый класс оболочка содержит статические константы, содержащие максимальное и минимальное значения для данного типа.</p>
</div>
<div class="paragraph">
<p>Например в классе <code>Integer</code> есть константы <code>Integer.MIN_VALUE</code> – минимальное <code>int</code> значение и <code>Integer.MAX_VALUE</code> – максимальное <code>int</code> значение.</p>
</div>
<div class="paragraph">
<p>Классы-обертки числовых типов <code>Float</code> и <code>Double</code>, помимо описанного для целочисленных примитивных типов, дополнительно содержат определения следующих констант:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NEGATIVE_INFINITY</code> – отрицательная бесконечность</p>
</li>
<li>
<p><code>POSITIVE_INFINITY</code> – положительная бесконечность</p>
</li>
<li>
<p><code>NaN</code> – не числовое значение (расшифровывается как <strong>Not a Number</strong>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Следующий пример демонстрирует использование трех последних переменных.
При делении на ноль возникает ошибка - на ноль делить нельзя.
Чтобы этого не происходило, и ввели переменные <code>NEGATIVE_INFINITY</code> и <code>POSITIVE_INFINITY</code>.
Результат умножения бесконечности на ноль - это значение <code>NaN</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class InfinityDemo {
    public static void main(String[] args) {
        int a = 7;
        double b = 0.0;
        double c = -0.0;
        double g = Double.NEGATIVE_INFINITY;
        System.out.println("7 / 0.0 = " + a / b);
        System.out.println("7 / -0.0 = " + a / c);
        System.out.println("0.0 == -0.0 = " + (b == c));
        System.out.println("-Infinity * 0 = " + g * 0);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Результат выполнения кода:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">7 / 0.0 = Infinity
7 / -0.0 = -Infinity
0.0 == -0.0 =  true
-Infinity * 0 = NaN</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_autoboxing_and_unboxing">5.6.2. Autoboxing and unboxing</h4>
<div class="paragraph">
<p><strong>Autoboxing</strong> and <strong>unboxing</strong> (<strong>авто-упаковка</strong> и <strong>распаковка</strong>) — это процесс преобразования примитивных типов в объектные и наоборот.
Весь процесс выполняется автоматически средой выполнения Java (<strong>JRE</strong>).
Эта возможность доступна в Java версии 5 и выше.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class AutoBoxDemo1 {
    public static void main(String[] args) {
        Integer iOb = 100; // упаковать значение int
        int i = iOb; // распаковать
        System.out.println(i + " " + iOb);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Autoboxing</strong> происходит при прямом присвоении примитива классу-обертке (с помощью оператора <code>=</code>), либо при передаче примитива в параметры метода.</p>
</div>
<div class="paragraph">
<p><strong>Unboxing</strong> происходит при прямом присвоении классу-обертке примитива.</p>
</div>
<div class="paragraph">
<p>Компилятор использует метод <code>valueOf()</code> для упаковки, а методы <code>intValue()</code>, <code>doubleValue()</code> и так далее, для распаковки.</p>
</div>
<div class="paragraph">
<p><strong>Autoboxing</strong> в <strong>классы-обертки</strong> могут быть подвергнуты как переменные примитивных типов, так и литералы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Integer iOb1 = 100;
int i = 200;
Integer iOb2 = i;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Autoboxing</strong> переменных примитивных типов требует точного соответствия типа исходного примитива — типу <strong>класса-обертки</strong>.</p>
</div>
<div class="paragraph">
<p>Например, попытка <strong>autoboxing</strong> переменную типа <code>byte</code> в <code>Short</code>, без предварительного явного приведения <code>byte</code> в <code>short</code> вызовет ошибку компиляции:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">byte b = 4;
// Short s1 = b;
Short s2 = (short) b;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Автоупаковку можно использовать при вызове метода:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class AutoBoxAndMethods {
    static int someMethod(Integer value) {
        return value;
    }

    public static void main(String[] args) {
        Integer iOb = someMethod(100);
        System.out.println(iOb);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Внутри выражения числовой объект автоматически распаковывается.
Выходной результат выражения при необходимости упаковывается заново:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class AutoBoxAndOperations {
    public static void main(String[] args) {
        Integer iOb1, iOb2;
        int i;

        iOb1 = 100;

        iOb2 = iOb1 + iOb1 / 3;
        System.out.println("iOb2 после выражения: " + iOb2);

        i = iOb1 + iOb1 / 3;
        System.out.println("i после выражения: " + i);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>C появлением <strong>autoboxing</strong>/<strong>unboxing</strong> стало возможным применять объекты <code>Boolean</code> для управления в операторе <code>if</code> и других циклических конструкциях Java:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class AutoBoxAndCharacters {
    public static void main(String[] args) {
        Boolean b = true;

        if (b) {
            System.out.println("В if тоже можно использовать распаковку.");
        }

        Character ch = 'x';
        char ch2 = ch;

        System.out.println("ch2 = " + ch2);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>До Java 5 работа с классами обертками была более трудоемкой:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class AutoBoxDemo2 {
    public static void main(String[] args) {
        Integer y = new Integer(567);
        int x = y.intValue();
        x++;
        y = new Integer(x);
        System.out.println("y = " + y);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Перепишет тот же пример для работы с классами начиная с Java 5:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class AutoBoxDemo3 {
    public static void main(String[] args) {
        Integer y = new Integer(567);
        y++;
        System.out.println("y = " + y);
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_объекты_классов_оболочек_неизменяемые">Объекты классов оболочек неизменяемые</h5>
<div class="paragraph">
<p>Объекты классов оболочек <strong>неизменяемые</strong> (<strong>immutable</strong>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class AutoBoxImmutability {
    public static void main(String[] args) {
        Integer y = 567;
        Integer x = y;
        // проверяем, что x и y указывают на один объект
        System.out.println(y == x);

        y++;
        System.out.println(x + " " + y);
        // проверяем, что x и y указывают на один объект
        System.out.println(y == x);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Рассмотрим следующий пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Integer y = 567;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Переменная <code>y</code> указывает на объект в памяти:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../../assets/img/java/core/misc/wrapper-classes/immutable1.png" alt="Объекты классов оболочек неизменяемы"></span></p>
</div>
<div class="paragraph">
<p>Если мы попытаемся изменить <code>y</code>, у нас создастся еще один объект в памяти, на который теперь и будет указывать <code>y</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Integer y = 567;
y++;</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../../assets/img/java/core/misc/wrapper-classes/immutable2.png" alt="Объекты классов оболочек неизменяемы"></span></p>
</div>
</div>
<div class="sect4">
<h5 id="_кэширование_объектов_классов_оболочек">Кэширование объектов классов оболочек</h5>
<div class="paragraph">
<p>Метод <code>valueOf()</code> не всегда создает новый объект.
Он кэширует следующие значения:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Boolean</code>,</p>
</li>
<li>
<p><code>Byte</code>,</p>
</li>
<li>
<p><code>Character</code> от <code>\u0000</code> до <code>\u007f</code> (<code>7f</code> это <code>127</code>),</p>
</li>
<li>
<p><code>Short</code> и <code>Integer</code> от <code>-128</code> до <code>127</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если передаваемое значение выходит за эти пределы, то новый объект создается, а если нет, то нет.</p>
</div>
<div class="paragraph">
<p>Если мы пишем <code>new Integer()</code>, то гарантированно создается новый объект.</p>
</div>
<div class="paragraph">
<p>Рассмотрим это на следующем примере:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class AutoBoxDemoCaching {
    public static void main(String[] args) {
        Integer i1 = 23;
        Integer i2 = 23;
        System.out.println(i1 == i2);
        System.out.println(i1.equals(i2));

        Integer i3 = 2300;
        Integer i4 = 2300;
        System.out.println(i3 == i4);
        System.out.println(i3.equals(i4));
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_перегрузка_с_дополнительными_факторами">5.6.3. Перегрузка с дополнительными факторами</h4>
<div class="paragraph">
<p>Перегрузка методов усложняется при одновременном использовании следующих факторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>расширение</p>
</li>
<li>
<p>автоупаковка/распаковка</p>
</li>
<li>
<p>аргументы переменной длины</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_расширение_примитивных_типов">Расширение примитивных типов</h5>
<div class="paragraph">
<p>При расширение примитивных типов используется наименьший возможный вариант из всех методов.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class EasyOver {
    static void go(int x) {
        System.out.print("int ");
    }

    static void go(long x) {
        System.out.print("long ");
    }

    static void go(double x) {
        System.out.print("double ");
    }

    public static void main(String[] args) {
        byte b = 5;
        short s = 5;
        long l = 5;
        float f = 5.0f;
        go(b);
        go(s);
        go(l);
        go(f);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_расширение_и_boxing">Расширение и boxing</h5>
<div class="paragraph">
<p>Между расширением примитивных типов и boxing всегда выигрывает расширение.
Исторически это более старый вид преобразования.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class AddBoxing {
    public static void go(Integer x) {
        System.out.println("Integer");
    }

    public static void go(long x) {
        System.out.println("long");
    }

    public static void main(String[] args) {
        int i = 5;
        go(i); // какой go() вызовется?
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_упаковка_и_расширение">Упаковка и расширение</h5>
<div class="paragraph">
<p>Можно упаковать, а потом расширить.
Значение типа <code>int</code> может стать <code>Object</code>, через преобразование <code>Integer</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class BoxAndWiden {
    public static void go(Object o) {
        Byte b2 = (Byte) o;
        System.out.println(b2);
    }

    public static void main(String[] args) {
        byte b = 5;
        go(b); // можно ли преобразовать byte в Object?
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_расширение_и_упаковка">Расширение и упаковка</h5>
<div class="paragraph">
<p>Нельзя расширить и упаковать.
Значение типа <code>byte</code> не может стать <code>Long</code>.
Нельзя расширить от одного класса обертки к другой.
(<strong>IS-A</strong> не работает.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class WidenAndBox {
    static void go(Long x) {
        System.out.println("Long");
    }

    public static void main(String[] args) {
        byte b = 5;
        // go(b); // нужно расширить до long и упаковать, что невозможно
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_расширение_и_аргументы_переменной_длины">Расширение и аргументы переменной длины</h5>
<div class="paragraph">
<p>Между расширением примитивных типов и <strong>var-args</strong> всегда проигрывает <strong>var-args</strong>:</p>
</div>
<div class="paragraph">
<p>public class AddVarargs {
public static void go(int x, int y) {
System.out.println("int,int"); }</p>
</div>
<div class="literalblock">
<div class="content">
<pre>public static void go(byte... x) {
    System.out.println("byte... ");
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    public static void main(String[] args) {
        byte b = 5;
        go(b, b); // какой go() вызовется?
    }
}</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_упаковка_и_аргументы_переменной_длины">Упаковка и аргументы переменной длины</h5>
<div class="paragraph">
<p>Упаковка и <strong>var-args</strong> совместимы с перегрузкой методов.
<strong>Var-args</strong> всегда проигрывает:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class BoxOrVararg {
    public static void go(Byte x, Byte y) {
        System.out.println("Byte, Byte");
    }

    public static void go(byte... x) {
        System.out.println("byte... ");
    }

    public static void main(String[] args) {
        byte b = 5;
        go(b, b); // какой go() вызовется?
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_правила_перегрузки_методов_при_использовании_расширения_упаковки_и_аргументов_переменной_длины">Правила перегрузки методов при использовании расширения, упаковки и аргументов переменной длины</h5>
<div class="paragraph">
<p>Подытожим все правила:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>При расширение примитивных типов используется наименьший возможный вариант из всех методов.</p>
</li>
<li>
<p>Между расширением примитивных типов и упаковкой всегда выигрывает расширение.
Исторически это более старый вид преобразования.</p>
</li>
<li>
<p>Можно упаковать, а потом расширить.
(Значение типа <code>int</code> может стать <code>Object</code>, через преобразование <code>Integer</code>.)</p>
</li>
<li>
<p>Нельзя расширить и упаковать.
Значение типа <code>byte</code> не может стать <code>Long</code>.
Нельзя расширить от одного класса обертки к другой.
(<strong>IS-A</strong> не работает.)</p>
</li>
<li>
<p>Можно комбинировать <strong>var-args</strong> с расширением или упаковкой. <strong>var-args</strong> всегда проигрывает.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_введение_в_лямбда_выражения">5.7. Введение в лямбда-выражения</h3>
<div class="sect3">
<h4 id="_введение">5.7.1. Введение</h4>
<div class="paragraph">
<p>Среди новшеств, которые были привнесены в язык Java с выходом JDK 8, особняком стоят <strong>лямбда-выражения</strong>. Лямбда-выражение представляет набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.</p>
</div>
<div class="paragraph">
<p>Основу лямбда-выражения составляет <strong>лямбда-оператор</strong>, который представляет стрелку <strong>&#8594;</strong>. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит <strong>список параметров выражения</strong>, а правая собственно представляет <strong>тело лямбда-выражения</strong>, где выполняются все действия.</p>
</div>
<div class="paragraph">
<p>Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.</p>
</div>
<div class="paragraph">
<p>Рассмотрим пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class LambdaApp {
    public static void main(String[] args) {
        Operationable operation;
        operation = (x, y) -&gt; x + y;

        int result = operation.calculate(10, 20);
        System.out.println(result); //30
    }
}

interface Operationable {
    int calculate(int x, int y);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В роли функционального интерфейса выступает интерфейс <code>Operationable</code>, в котором определен один метод без реализации - метод <code>calculate</code>. Данный метод принимает два параметра - целых числа, и возвращает некоторое целое число.</p>
</div>
<div class="paragraph">
<p>По факту <strong>лямбда-выражения являются</strong> в некотором роде <strong>сокращенной формой внутренних анонимных классов</strong>, которые ранее применялись в Java. В частности, предыдущий пример мы можем переписать следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class LambdaApp {
    public static void main(String[] args) {
        Operationable op = new Operationable() {
            public int calculate(int x, int y) {
                return x + y;
            }
        };
        int z = op.calculate(20, 10);
        System.out.println(z); // 30
    }
}

interface Operationable {
    int calculate(int x, int y);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы объявить и использовать лямбда-выражение, основная программа разбивается на ряд этапов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Определение ссылки на функциональный интерфейс:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Operationable operation;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Создание лямбда-выражения:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">operation = (x, y) -&gt; x + y;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Использование лямбда-выражения в виде вызова метода интерфейса:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int result = operation.calculate(10, 20);</code></pre>
</div>
</div>
<div class="paragraph">
<p>На втором этапе параметры лямбда-выражения соответствуют параметрам единственного метода интерфейса <code>Operationable</code>, а результат соответствует возвращаемому результату метода интерфейса. При этом нам не надо использовать ключевое слово <code>return</code> для возврата результата из лямбда-выражения.</p>
</div>
<div class="paragraph">
<p>Так, в методе интерфейса оба параметра представляют тип <code>int</code>, значит, в теле лямбда-выражения мы можем применить к ним сложение. Результат сложения также представляет тип <code>int</code>, объект которого возвращается методом интерфейса.</p>
</div>
<div class="paragraph">
<p>На третьем этапе результатом будет сумма чисел <code>10</code> и <code>20</code>, так как в лямбда-выражении определена операция сложения параметров.</p>
</div>
<div class="paragraph">
<p>При этом для одного функционального интерфейса мы можем определить множество лямбда-выражений. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Operationable operation1 = (int x, int y)-&gt; x + y;
Operationable operation2 = (int x, int y)-&gt; x - y;
Operationable operation3 = (int x, int y)-&gt; x * y;

System.out.println(operation1.calculate(20, 10)); //30
System.out.println(operation2.calculate(20, 10)); //10
System.out.println(operation3.calculate(20, 10)); //200</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_отложенное_выполнение">5.7.2. Отложенное выполнение</h4>
<div class="paragraph">
<p>Одним из ключевых моментов в использовании лямбд является <strong>отложенное выполнение</strong> (<strong>deferred execution</strong>). То есть мы определяем в одном месте программы лямбда-выражение и затем можем его вызывать при необходимости неопределенное количество раз в различных частях программы. Отложенное выполнение может потребоваться, к примеру, в следующих случаях:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>выполнение кода отдельном потоке</p>
</li>
<li>
<p>выполнение одного и того же кода несколько раз</p>
</li>
<li>
<p>выполнение кода в результате какого-то события</p>
</li>
<li>
<p>выполнение кода только в том случае, когда он действительно необходим и если он необходим</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_передача_параметров_в_лямбда_выражение">Передача параметров в лямбда-выражение</h5>
<div class="paragraph">
<p>Параметры лямбда-выражения должны соответствовать по тип параметрам метода из функционального интерфейса. При написании самого лямбда-выражения тип параметров писать необязательно, хотя в принципе это можно сделать, например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">operation = (int x, int y) -&gt; x + y;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если метод не принимает никаких параметров, то пишутся пустые скобки, например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">() -&gt; 30 + 20;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если метод принимает только один параметр, то скобки можно опустить:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">n -&gt; n * n;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_терминальные_лямбда_выражения">5.7.3. Терминальные лямбда-выражения</h4>
<div class="paragraph">
<p>Выше рассмотрены лямбда-выражения, которые возвращают определенное значение. Но также могут быть и <strong>терминальные лямбды</strong>, которые не возвращают никакого значения. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">interface Printable {
    void print(String s);
}

public class LambdaApp {
    public static void main(String[] args) {
        Printable printer = s -&gt; System.out.println(s);
        printer.print("Hello Java!");
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_лямбды_и_локальные_переменные">5.7.4. Лямбды и локальные переменные</h4>
<div class="paragraph">
<p>Лямбда-выражение может использовать переменные, которые объявлены во вне в более общей области видимости - на уровне класса или метода, в котором лямбда-выражение определено. Однако в зависимости от того, как и где определены переменные, могут различаться способы их использования в лямбдах. Рассмотрим первый пример - использования переменных уровня класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class LambdaApp {
    static int x = 10;
    static int y = 20;

    public static void main(String[] args) {
        Operation op = () -&gt; {
            x = 30;
            return x + y;
        };
        System.out.println(op.calculate()); // 50
        System.out.println(x); // 30 - значение x изменилось
    }
}

interface Operation {
    int calculate();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Переменные <code>x</code> и <code>y</code> объявлены на уровне класса, и в лямбда-выражении мы их может получить и даже изменить. Так, в данном случае после выполнения выражения изменяется значение переменной <code>x</code>.</p>
</div>
<div class="paragraph">
<p>Теперь рассмотрим другой пример - локальные переменные на уровне метода:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static void main(String[] args) {
    int n = 70;
    int m = 30;
    Operation op = () -&gt; {
        // n = 100; - так нельзя сделать
        return m + n;
    };
    // n = 100;  - так тоже нельзя
    System.out.println(op.calculate()); // 100
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Локальные переменные уровня метода мы также может использовать в лямбдах, но изменять их значение мы уже не сможем. Если мы попробуем это сделать, то среда разработки может нам высветить ошибку и то, что такую переменную надо пометить с помощью ключевого слова <code>final</code>, то есть сделать константой: <code>final int n = 70;</code>. Однако это необязательно.</p>
</div>
<div class="paragraph">
<p>Более того, мы не сможем изменить значение переменной, которая используется в лямбда-выражении, вне этого выражения. То есть даже если такая переменная не объявлена как константа, по сути она является константой.</p>
</div>
</div>
<div class="sect3">
<h4 id="_блоки_кода_в_лямбда_выражениях">5.7.5. Блоки кода в лямбда-выражениях</h4>
<div class="paragraph">
<p>Существуют два типа лямбда-выражений:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>однострочное выражение</p>
</li>
<li>
<p>блок кода</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Примеры однострочных выражений демонстрировались выше. Блочные выражения обрамляются фигурными скобками. В блочных лямбда-выражениях можно использовать внутренние вложенные блоки, циклы, конструкции <code>if</code>, <code>switch</code>, создавать переменные и т.д. Если блочное лямбда-выражение должно возвращать значение, то явным образом применяется оператор <code>return</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Operationable operation = (int x, int y) -&gt; {
    if(y == 0)
        return 0;
    else
        return x / y;
};

System.out.println(operation.calculate(20, 10)); //2
System.out.println(operation.calculate(20, 0)); //0</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_обобщенный_функциональный_интерфейс">5.7.6. Обобщенный функциональный интерфейс</h4>
<div class="paragraph">
<p>Функциональный интерфейс может быть обобщенным, однако в лямбда-выражении использование обобщений не допускается. В этом случае нам надо типизировать объект интерфейса определенным типом, который потом будет применяться в лямбда-выражении. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class LambdaApp {
    public static void main(String[] args) {
        Operationable&lt;Integer&gt; operation1 = (x, y) -&gt; x + y;
        Operationable&lt;String&gt; operation2 = (x, y) -&gt; x + y;

        System.out.println(operation1.calculate(20, 10)); //30
        System.out.println(operation2.calculate("20", "10")); //2010
    }
}

interface Operationable&lt;T&gt; {
    T calculate(T x, T y);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Таким образом, при объявлении лямбд-выражения ему уже известно, какой тип параметры будут представлять и какой тип они будут возвращать.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_лямбды_как_параметры_и_результаты_методов">5.8. Лямбды как параметры и результаты методов</h3>
<div class="sect3">
<h4 id="_лямбды_как_параметры_методов">5.8.1. Лямбды как параметры методов</h4>
<div class="paragraph">
<p>Одним из преимуществ лямбд в java является то, что их можно передавать в качестве параметров в методы. Рассмотрим пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class LambdaApp {
    public static void main(String[] args) {
        Expression func = (n) -&gt; n % 2 == 0;
        int[] nums = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        System.out.println(sum(nums, func)); // 20
    }

    private static int sum(int[] numbers, Expression func) {
        int result = 0;
        for (int i : numbers) {
            if (func.isEqual(i))
                result += i;
        }
        return result;
    }
}

interface Expression {
    boolean isEqual(int n);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функциональный интерфейс <code>Expression</code> определяет метод <code>isEqual()</code>, который возвращает <code>true</code>, если в отношении числа <code>n</code> действует какое-нибудь равенство.</p>
</div>
<div class="paragraph">
<p>В основном классе программы определяется метод <code>sum()</code>, который вычисляет сумму всех элементов массива, соответствующих некоторому условию. А само условие передается через параметр <code>Expression func</code>. Причем на момент написания метода <code>sum</code> мы можем абсолютно не знать, какое именно условие будет использоваться. Само же условие определяется в виде лямбда-выражения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Expression func = (n) -&gt; n % 2 == 0;</code></pre>
</div>
</div>
<div class="paragraph">
<p>То есть в данном случае все числа должны быть четными или остаток от их деления на <code>2</code> должен быть равен <code>0</code>. Затем это лямбда-выражение передается в вызов метода <code>sum</code>.</p>
</div>
<div class="paragraph">
<p>При этом можно не определять переменную интерфейса, а сразу передать в метод лямбда-выражение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
int x = sum(nums, (n)-&gt; n &gt; 5); // сумма чисел, которые больше 5
System.out.println(x);  // 30</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ссылки_на_метод_как_параметры_методов">5.8.2. Ссылки на метод как параметры методов</h4>
<div class="paragraph">
<p>Начиная с JDK 8 в Java можно в качестве параметра в метод передавать ссылку на другой метод. В принципе данный способ аналогичен передаче в метод лямбда-выражения.</p>
</div>
<div class="paragraph">
<p>Ссылка на метод передается в виде <code>имя_класса::имя_статического_метода</code> (если метод статический) или <code>объект_класса::имя_метода</code> (если метод нестатический). Рассмотрим на примере:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">interface Expression {
    boolean isEqual(int n);
}

class ExpressionHelper {
    static boolean isEven(int n) {
        return n % 2 == 0;
    }

    static boolean isPositive(int n) {
        return n &gt; 0;
    }
}

public class LambdaApp {
    public static void main(String[] args) {
        int[] nums = {-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5};
        System.out.println(sum(nums, ExpressionHelper::isEven));

        Expression expr = ExpressionHelper::isPositive;
        System.out.println(sum(nums, expr));
    }

    private static int sum(int[] numbers, Expression func) {
        int result = 0;
        for (int i : numbers) {
            if (func.isEqual(i))
                result += i;
        }
        return result;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь также определен функциональный интерфейс <code>Expression</code>, который имеет один метод. Кроме того, определен класс <code>ExpressionHelper</code>, который содержит два статических метода. В принципе их можно было определить и в основном классе программы, но я вынес их в отдельный класс.</p>
</div>
<div class="paragraph">
<p>В основном классе программы <code>LambdaApp</code> определен метод <code>sum()</code>, который возвращает сумму элементов массива, соответствующих некоторому условию. Условие передается в виде объекта функционального интерфейса <code>Expression</code>.</p>
</div>
<div class="paragraph">
<p>В методе <code>main</code> два раза вызываем метод <code>sum</code>, передавая в него один и тот же массив чисел, но разные условия. Первый вызов метода <code>sum</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">System.out.println(sum(nums, ExpressionHelper::isEven));</code></pre>
</div>
</div>
<div class="paragraph">
<p>На место второго параметра передается <code>ExpressionHelper::isEven</code>, то есть ссылка на статический метод <code>isEven()</code> класса <code>ExpressionHelper</code>. При этом методы, на которые идет ссылка, должны совпадать по параметрам и результату с методом функционального интерфейса.</p>
</div>
<div class="paragraph">
<p>При втором вызове метода <code>sum</code> отдельно создается объект <code>Expression</code>, который затем передается в метод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Expression expr = ExpressionHelper::isPositive;
System.out.println(sum(nums, expr));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Использование ссылок на методы в качестве параметром аналогично использованию лямбда-выражений.</p>
</div>
<div class="paragraph">
<p>Если нам надо вызвать нестатические методы, то в ссылке вместо имени класса применяется имя объекта этого класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">interface Expression {
    boolean isEqual(int n);
}

class ExpressionHelper {
    boolean isEven(int n) {
        return n % 2 == 0;
    }
}

public class LambdaApp {
    public static void main(String[] args) {
        int[] nums = {-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5};
        ExpressionHelper exprHelper = new ExpressionHelper();
        System.out.println(sum(nums, exprHelper::isEven)); // 0
    }

    private static int sum(int[] numbers, Expression func) {
        int result = 0;
        for (int i : numbers) {
            if (func.isEqual(i))
                result += i;
        }
        return result;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ссылки_на_конструкторы">5.8.3. Ссылки на конструкторы</h4>
<div class="paragraph">
<p>Подобным образом мы можем использовать конструкторы: <code>название_класса::new</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class LambdaApp {
    public static void main(String[] args) {
        UserBuilder userBuilder = User::new;
        User user = userBuilder.create("Tom");
        System.out.println(user.getName());
    }
}

interface UserBuilder {
    User create(String name);
}

class User {
    private String name;

    String getName() {
        return name;
    }

    User(String n) {
        this.name = n;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>При использовании конструкторов методы функциональных интерфейсов должны принимать тот же список параметров, что и конструкторы класса, и должны возвращать объект данного класса.</p>
</div>
</div>
<div class="sect3">
<h4 id="_лямбды_как_результат_методов">5.8.4. Лямбды как результат методов</h4>
<div class="paragraph">
<p>Также метод в Java может возвращать лямбда-выражение. Рассмотрим следующий пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">interface Operation {
    int execute(int x, int y);
}

public class LambdaApp {
    public static void main(String[] args) {
        Operation func = action(1);
        int a = func.execute(6, 5);
        System.out.println(a); // 11

        int b = action(2).execute(8, 2);
        System.out.println(b); // 6
    }

    private static Operation action(int number) {
        switch (number) {
            case 1:
                return (x, y) -&gt; x + y;
            case 2:
                return (x, y) -&gt; x - y;
            case 3:
                return (x, y) -&gt; x * y;
            default:
                return (x, y) -&gt; 0;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае определен функциональный интерфейс <code>Operation</code>, в котором метод <code>execute</code> принимает два значения типа <code>int</code> и возвращает значение типа <code>int</code>.</p>
</div>
<div class="paragraph">
<p>Метод <code>action</code> принимает в качестве параметра число и в зависимости от его значения возвращает то или иное лямбда-выражение. Оно может представлять либо сложение, либо вычитание, либо умножение, либо просто возвращает <code>0</code>. Стоит учитывать, что формально возвращаемым типом метода <code>action</code> является интерфейс <code>Operation</code>, а возвращаемое лямбда-выражение соответствует этому интерфейсу.</p>
</div>
<div class="paragraph">
<p>В методе <code>main</code> мы можем вызвать этот метод <code>action</code>. Например, сначала получить его результат - лямбда-выражение, которое присваивается переменной <code>Operation</code>. А затем через метод <code>execute</code> выполнить это лямбда-выражение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Operation func = action(1);
int a = func.execute(6, 5);
System.out.println(a); // 11</code></pre>
</div>
</div>
<div class="paragraph">
<p>Либо можно сразу получить и тут же выполнить лямбда-выражение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int b = action(2).execute(8, 2);
System.out.println(b); // 6</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_аннотации">5.9. Аннотации</h3>
<div class="paragraph">
<p><strong>Аннотации</strong> представляют собой некую мета-информацию. Они не выполняют какого-либо действия сами по себе, но они могут предоставлять дополнительную информацию, которая может быть использована компилятором, различными утилитами сборки и генерации кода, а также они могут обрабатываться во время выполнения программы.</p>
</div>
<div class="paragraph">
<p>Аннотации предваряются символом <code>@</code>. Пример часто используемой аннотации <code>@Override</code>, которая указывает компилятору, что этот метод переопределяет базовый метод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">@Override
public void someMethod() {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Аннотации могут иметь элементы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">@SuppressWarnings(value = "unchecked")
public void method() {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если элементов много, то они разделяются запятой, если элемент только один, и его имя <code>value</code>, то его название можно не указывать:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">@SuppressWarnings("unchecked")
void myMethod() {
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_объявление_аннотаций">5.9.1. Объявление аннотаций</h4>
<div class="paragraph">
<p>Предположим, что при объявлении каждого нового класса необходимо записывать в комментариях информацию об авторах в таком виде:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Goblin {
    // author : John Clark
    // sprites : Izabella Simpson
    // sound : Michael Lermontov
    // code : Pushkin A.
    // createdAt : 2016-03-30
    // description : Goblin is lurking creature.
    // comments :

    // ... code
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Можно записывать эту информацию с помощью аннотаций. Для этого вам сперва нужно объявить эту аннотацию:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">@interface Monstr {
    String author();
    String sprites();
    String sound();
    String code();
    String createdAt() default "0000-00-00";
    String description();

    // Example of array use
    String[] comments();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь можно применить его к нашему классу <code>Goblin</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">@Monstr(
    author="John Clark",
    sprites = "Izabella Simpson",
    sound = "Michael Lermontov",
    code = "Pushkin A.",
    createdAt = "2016-03-30",
    description = "Goblin is lurking creature",
    comments = {"lol", "gg", "Аффтар жжёт"}
)
class Goblin {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание на запись элементов аннотации (<code>author</code>, <code>sprites</code>, <code>sound</code>) и на запись массива элементов с использованием фигурных скобок (<code>comments</code>).</p>
</div>
<div class="paragraph">
<p>Можно использовать предопределённую аннотацию <code>@Documented</code>, чтобы наша аннотация попадала в документацию, сгенерированную утилитой <strong>JavaDoc</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.lang.annotation.Documented;

@Documented
@interface Monstr {
    String author();
    String sprites();
    String sound();
    String code();
    String createdAt() default "0000-00-00";
    String description();

    // Example of array use
    String[] comments();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_предопределённые_аннотации">5.9.2. Предопределённые аннотации</h4>
<div class="sect4">
<h5 id="_deprecated"><code>@Deprecated</code></h5>
<div class="paragraph">
<p><code>@Deprecated</code> указывает, что элемент устарел и не должен использоваться. Компилятор Java генерирует предупреждение, если вы используете класс, метод или поле, помеченные аннотацией <code>@Deprecated</code>. Устаревший элемент должен быть также помечен тегом <strong>JavaDoc</strong> <code>@deprecated</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">/*
 * @deprecated
 * explanation of why it was deprecated
 */
 @Deprecated
 static void deprecatedMethod() { }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_override"><code>@Override</code></h5>
<div class="paragraph">
<p><code>@Override</code> указывает, что метод переопределяет метод базового класса. Эту аннотацию использовать не обязательно, но рекомендуется.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">@Override
public int myMethod(double x) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если метод с <code>@Override</code> не может корректно переопределить метод базового класса, то компилятор генерирует ошибку.</p>
</div>
</div>
<div class="sect4">
<h5 id="_suppresswarnings"><code>@SuppressWarnings</code></h5>
<div class="paragraph">
<p><code>@SuppressWarnings</code> подавляет предупреждения. Пример подавления предупреждения об устаревшем методе:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">// Указываем компиляторе не генерировать
// предупреждение о использовании
// устаревшего метода.
@SuppressWarnings("deprecation")
void useDeprecatedMethod() {
    // Используем устаревший метод.
    objectOne.deprecatedMethod();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Каждое предупреждение принадлежит какой-либо категории. В спецификации Java описано две категории. В <code>@SupressWarnings</code> можно указывать несколько категорий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">@SuppressWarnings({"unchecked", "deprecation"})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Различные реализации компиляторов и различные IDE могут добавлять свои категории предупреждений. Неподдерживаемые названия категорий пропускаются при использовании <code>@SuppressWarnings</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_safevarargs"><code>@SafeVarargs</code></h5>
<div class="paragraph">
<p><code>@SafeVarargs</code> применяется к методу или конструктору и указывает, что код не осуществляет потенциально опасных операций со своим <code>varargs</code>-параметром (параметр, принимающий произвольное число параметров).</p>
</div>
</div>
<div class="sect4">
<h5 id="_functionalinterface"><code>@FunctionalInterface</code></h5>
<div class="paragraph">
<p><code>@FunctionalInterface</code> указывает, что это объявление типа будет функциональным интерфейсом Java 8.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_мета_аннотации">5.9.3. Мета-аннотации</h4>
<div class="paragraph">
<p>Аннотации, применяемые к другим аннотациям, называются <strong>мета-аннотациями</strong>. Есть несколько мета-аннотаций в пакете <code>java.lang.annotation</code>:</p>
</div>
<div class="sect4">
<h5 id="_retention"><code>@Retention</code></h5>
<div class="paragraph">
<p><code>@Retention</code> определяет, как аннотация будет сохранена:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RetentionPolicy.SOURCE</code> - аннотация будет только в исходном коде, и она будет игнорироваться компилятором.</p>
</li>
<li>
<p><code>RetentionPolicy.CLASS</code> - аннотация будет доступна компилятору, но но будет игнорироваться виртуальной машиной Java.</p>
</li>
<li>
<p><code>RetentionPolicy.RUNTIME</code> - аннотация будет сохраняться JVM и будет доступна во время выполнения.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_documented"><code>@Documented</code></h5>
<div class="paragraph">
<p><code>@Documented</code> - указывает, что элементы, помеченные этой аннотацией, должны документироваться JavaDoc. По умолчанию аннотации не включаются в документацию.</p>
</div>
</div>
<div class="sect4">
<h5 id="_target"><code>@Target</code></h5>
<div class="paragraph">
<p><code>@Target</code> - указывает какие элементы можно помечать этой аннотацией:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ElementType.ANNOTATION_TYPE</code> - данная аннотация может быть применена к другой аннотации.</p>
</li>
<li>
<p><code>ElementType.CONSTRUCTOR</code> - может быть применена к конструктору.</p>
</li>
<li>
<p><code>ElementType.FIELD</code> - может быть применена к полю.</p>
</li>
<li>
<p><code>ElementType.LOCAL_VARIABLE</code> - может быть применена к локальной переменной.</p>
</li>
<li>
<p><code>ElementType.METHOD</code> - может быть применена к методу.</p>
</li>
<li>
<p><code>ElementType.PACKAGE</code> - может быть применена к пакету.</p>
</li>
<li>
<p><code>ElementType.PARAMETER</code> - может быть применена к параметрам метода.</p>
</li>
<li>
<p><code>ElementType.TYPE</code> - может быть применена классу, интерфейсу, аннотации или перечислению.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_inherited"><code>@Inherited</code></h5>
<div class="paragraph">
<p><code>@Inherited</code> — аннотация может быть унаследована от базового класса (по умолчанию не наследуются). Когда запрашивается аннотация класса, и у класса нет такой аннотации, то запрашивается аннотация базового класса. Эта аннотация может быть применена только к классам.</p>
</div>
</div>
<div class="sect4">
<h5 id="_repeatable"><code>@Repeatable</code></h5>
<div class="paragraph">
<p><code>@Repeatable</code> - аннотация может быть применена несколько раз.</p>
</div>
<div class="paragraph">
<p>Допустим мы хотим применить аннотацию <code>@Author</code> несколько раз для указания нескольких авторов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">@Author("Petya")
@Author("Vasya")
@Author("Suslik")
class Goblin {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тогда необходимо объявить такую аннотацию следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.lang.annotation.Repeatable;

@Repeatable(Authors.class)
@interface Author {
    String value();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание, что добавлена аннотация <code>@Repeatable</code> с указанием <code>Authors.class</code>, который мы должны объявить как аннотацию с массивом аннотация <code>Author</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">@interface Authors{
    Author[] value();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь можно указывать аннотацию <code>@Author</code> столько раз, сколько необходимо, для любого класса.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reflection">5.10. Reflection</h3>
<div class="paragraph">
<p><strong>Рефлексия</strong> (от reflexio - обращение назад) - это механизм исследования данных о программе во время её выполнения. Рефлексия в Java осуществляется с помощью <strong>Java Reflection API</strong>, состоящий из классов пакетов <code>java.lang</code> и <code>java.lang.reflect</code>. В информатике рефлексия означает процесс, во время которого программа может отслеживать и модифицировать собственную структуру и поведение во время выполнения.</p>
</div>
<div class="paragraph">
<p><strong>Java Reflection API</strong> позволяет получать информацию о конструкторах, методах и полях классов и выполнять следующие операции над полями и методами объекта/класса:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>определение класса объекта</p>
</li>
<li>
<p>получение информации о полях, методах, конструкторах и суперклассах</p>
</li>
<li>
<p>получение информации о модификаторах полей и методов</p>
</li>
<li>
<p>создание экземпляра класса, имя которого неизвестно до момента выполнения программы</p>
</li>
<li>
<p>определение и изменение значений свойств объекта/класса</p>
</li>
<li>
<p>вызов методов объекта/класса</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>В исходном коде используется объект/класс. При работе с объектом (реализацией класса) можно обращаться к полям и методам класса напрямую, если они доступны (не private). При работе с классом можно обращаться к методам класса с использованием Java Reflection API. Но класс необходимо получить из объекта.</p>
</div>
</blockquote>
</div>
<div class="sect3">
<h4 id="_определение_свойств_класса">5.10.1. Определение свойств класса</h4>
<div class="paragraph">
<p>В работающем приложении для получения класса необходимо использовать метод <code>forName(String className)</code>. Следующий код демонстрирует возможность создания класса без использования и с использованием Reflection :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">// Без использования Reflection
Foo foo = new Foo();

// С использованием Reflection
Class foo = Class.forName("Foo");

// Загрузка JDBC-драйвера
Class.forName("com.mysql.jdbc.Driver");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод класса <code>forName(className)</code> часто используется для загрузки JDBC-драйвера.</p>
</div>
<div class="paragraph">
<p>Методом <code>getName()</code> объекта <code>Class</code> можно получить наименование класса, включающего пакет (<code>package</code>) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Class aclass = foo.getClass();
System.out.println (aclass.getName());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для получения значения модификатора класса используется метод <code>getModifiers()</code>. Класс <code>java.lang.reflect.Modifier</code> содержит статические методы, возвращающие логическое значения проверки модификатора класса :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Class cls = foo.getClass();
int mods = cls.getModifiers();
if (Modifier.isPublic(mods)) {
    System.out.println("public");
}
if (Modifier.isAbstract(mods)) {
    System.out.println("abstract");
}
if (Modifier.isFinal(mods))    {
    System.out.println("final");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для получения суперкласса рефлексированного объекта (класса) необходимо использовать метод <code>getSuperclass()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Class cls = foo.getClass();
Class superCls = cls.getSuperClass();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Поскольку в Java отсутствует множественное наследование, то для получения всех предков следует рекурсивно вызвать метод <code>getSuperclass()</code> в цикле, пока не будет достигнут <code>Object</code>, являющийся родителем всех классов. <code>Object</code> не имеет родителей, поэтому вызов его метода <code>getSuperclass()</code> вернет <code>null</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_определение_интерфейсов_и_конструкторов_класса">5.10.2. Определение интерфейсов и конструкторов класса</h4>
<div class="paragraph">
<p>Для получения в режиме <strong>runtime</strong> списка реализующих классом интерфейсов, необходимо получить <code>Class</code> и использовать его метод <code>getInterfaces()</code>. В следующем примере извлекается список интерфейсов класса <code>ArrayList</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Class&lt;?&gt;   cls = ArrayList.class;
Class&lt;?&gt;[] ifs = cls.getInterfaces();

System.out.println("List of interfaces\n");
for(Class&lt;?&gt; ifc : ifs) {
    System.out.println (ifc.getName());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы IDE не предупреждала о необходимости определения типа класса</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Class is a raw type. References to generic type Class&lt;T&gt; should be parameterized</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>в коде были использованы <strong>generic</strong>. В консоль выводятся следующие интерфейсы, реализуемые классом <code>ArrayList</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">List of interfaces

java.util.List
java.util.RandomAccess
java.lang.Cloneable
java.io.Serializable</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод класса <code>getConstructors()</code> позволяет получить массив открытых конструкторов типа <code>java.lang.reflect.Constructor</code>. После этого, можно извлекать информацию о типах параметров конструктора и генерируемых исключениях:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Class&lt;?&gt; cls = obj.getClass();
Constructor[] constructors = cls.getConstructors();
for (Constructor constructor : constructors) {
    Class&lt;?&gt;[] params = constructor.getParameterTypes();
    for (Class&lt;?&gt; param : params) {
        System.out.println(param.getName());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_определение_полей_класса">5.10.3. Определение полей класса</h4>
<div class="paragraph">
<p>Метод <code>getFields()</code> объекта <code>Class</code> возвращает массив открытых полей типа <code>java.lang.reflect.Field</code>, которые могут быть определены не только в данном классе, но также и в его родителях (суперклассе), либо интерфейсах, реализованных классом или его родителями. Класс <code>Field</code> позволяет получить имя поля, тип и модификаторы :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Class&lt;?&gt; cls = obj.getClass();
Field[] fields = cls.getFields();
for (Field field : fields) {
    Class&lt;?&gt; fld = field.getType();
    System.out.println("Class name : " + field.getName());
    System.out.println("Class type : " + fld.getName());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если известно наименование поля, то можно получить о нем информацию с помощью метода <code>getField()</code> объекта <code>Class</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Class&lt;?&gt; cls = obj.getClass();
Field fld = cls.getField("fieldName");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Методы <code>getField()</code> и <code>getFields()</code> возвращают только открытые члены данных класса. Чтобы получить все поля класса, включая закрытые и защищенные, необходимо использовать методы <code>getDeclaredField()</code> и <code>getDeclaredFields()</code>. Данные методы работают точно так же, как и их аналоги <code>getField()</code> и <code>getFields()</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_определение_значений_полей_класса">5.10.4. Определение значений полей класса</h4>
<div class="paragraph">
<p>Класс <code>Field</code> содержит специализированные методы для получения значений примитивных типов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getInt()</code></p>
</li>
<li>
<p><code>getFloat()</code></p>
</li>
<li>
<p><code>getByte()</code></p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Для установки значения поля, используется метод <code>set()</code>. Для примитивных типов имеются методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>setInt()</code></p>
</li>
<li>
<p><code>setFloat()</code></p>
</li>
<li>
<p><code>setByte()</code></p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Class&lt;?&gt; cls = obj.getClass();
Field field = cls.getField("fieldName");

String value = (String) field.get(obj);
field.set(obj, "New value");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ниже приведен пример изменения значения закрытого поля класса в runtime.</p>
</div>
</div>
<div class="sect3">
<h4 id="_определение_методов_класса">5.10.5. Определение методов класса</h4>
<div class="paragraph">
<p>Метод <code>getMethods()</code> объекта <code>Class</code> возвращает массив открытых методов типа <code>java.lang.reflect.Method</code>. Эти методы могут быть определены не только в классе, но также и в его родителях (суперклассе), либо интерфейсах, реализованных классом или его родителями. Класс <code>Method</code> позволяет получить имя метода, тип возвращаемого им значения, типы параметров метода, модификаторы и генерируемые исключения.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Class&lt;?&gt; cls = obj.getClass();
Method[] methods = cls.getMethods();
for (Method method : methods) {
    System.out.println("Method name : " + method.getName());
    System.out.println("Return type : " + method.getReturnType().getName());

    Class&lt;?&gt;[] params = method.getParameterTypes();
    System.out.print("Parameters : ");
    for (Class&lt;?&gt; paramType : params) {
        System.out.print(" " + paramType.getName());
    }
    System.out.println();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если известно имя метода и типы его параметров, то можно получить отдельный метод класса :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Class&lt;?&gt; cls = obj.getClass();
Class[] params = new Class[] {Integer.class, String.class};

Method method = cls.getMethod("methodName", params);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_пример_изменения_значения_закрытого_поля_класса">5.10.6. Пример изменения значения закрытого поля класса</h4>
<div class="paragraph">
<p>Чтобы изменить значение закрытого (<code>private</code>) поля класса необходимо получить это поле методом <code>getDeclaredField()</code> и вызвать метод <code>setAccessible(true)</code> объекта <code>Field</code>, чтобы открыть доступ к полю. После этого значение закрытого поля можно изменять, если оно не <code>final</code>. В следующем примере определен внутренний класс <code>PrivateFinalFields</code> с набором закрытых полей; одно из полей <code>final</code>. При создании объекта класса поля инициализируются. В методе <code>main()</code> примера поочередно в закрытые поля вносятся изменения и свойства объекта выводятся в консоль.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.lang.reflect.Field;

class PrivateFinalFields {
    private final String s  = "String S";
    private int i  = 1;
    private String s2 = "String S2";

    public String toString() {
        return "i = " + i + ", " + s + ", " + s2;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class ModifyngPrivateFields {
    public static void main(String[] args) throws Exception {
        PrivateFinalFields pf = new PrivateFinalFields();

        Field f = pf.getClass().getDeclaredField("i");
        f.setAccessible(true);
        f.setInt(pf, 47);
        System.out.println("1. " + pf);

        f = pf.getClass().getDeclaredField("s");
        f.setAccessible(true);
        f.set(pf, "MODIFY S");
        System.out.println("2. " + pf);

        f = pf.getClass().getDeclaredField("s2");
        f.setAccessible(true);
        f.set(pf, "MODIFY S2");

        f = pf.getClass().getDeclaredField("i");
        f.setAccessible(true);
        f.setInt(pf, 35);
        System.out.println("3. " + pf);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В результате выполнения примера в консоль будут выведены следующие сообщения :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">1. i = 47, String S, String S2
2. i = 47, String S, String S2
3. i = 35, String S, MODIFY S2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Из приведённого примера видно что поля <code>private</code> можно изменять. Для этого необходимо получить объект типа <code>java.lang.reflect.Field</code> с помощью метода <code>getDeclaredField()</code>, вызвать его метод <code>setAccessible(true)</code> и с помощью метода <code>set()</code> установить требуемое значение поля. Необходимо иметь в виду, что наличие модификатора <code>final</code> в закрытом текстовом поле не вызывает исключений при изменении значений, а само значение поля остаётся прежним, т.е. <code>final</code> поля остаются неизменные. Если не вызвать метод открытия доступа к полю <code>setAccessible(true)</code>, то будет вызвано исключение <code>java.lang.IllegalAccessException</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_пример_вызова_метода_invoke">5.10.7. Пример вызова метода <code>invoke()</code></h4>
<div class="paragraph">
<p><strong>Java Reflection Api</strong> позволяет вызвать метод класса. Рассмотрим пример, в котором определим класс <code>Reflect</code>, включающий поля и методы управления ими. В runtime с помощью метода данного класса будем изменять значения полей и распечатывать их.</p>
</div>
<div class="paragraph">
<p>Класс <code>Reflect</code> включает два закрытых поля <code>id</code>, <code>name</code> и методы управления их значениями <strong>set/get</strong>. Дополнительно в класс включим метод <code>setData()</code>, который будем вызывать для изменения значений полей, и метод <code>toString()</code> для печати их значений.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Reflect {
    private String name;
    private int id;

    Reflect() {
        this.name = "Test";
        this.id = 999;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setData(final int id, String name) {
        this.id   = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Reflect [ id : " + id + ", name : " + name + "]";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для тестирования объекта типа <code>Reflect</code> с помощью <strong>Java Reflection Api</strong> создадим класс <code>ReflectionTest</code>. В этот класс включим два метода <code>getClassFields()</code> и <code>getClassMethods()</code>, которые в <strong>runtime</strong> распечатают всю информацию (описание полей и методов) о классе. Методы получают класс в качестве параметра. В процедурах сначала определяются массивы полей и методы; после этого их параметры распечатываются :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">private void getClassFields(Class&lt;?&gt; cls) {
    Field[] fields = cls.getDeclaredFields();
    System.out.println("Class fields");
    for (Field field : fields) {
        Class&lt;?&gt; fld = field.getType();
        System.out.println("Class name : " + field.getName());
        System.out.println("Class type : " + fld.getName());
    }
}

private void getClassMethods(Class&lt;?&gt; cls) {
    Method[] methods = cls.getDeclaredMethods();
    System.out.println("Class methods");
    for (Method method : methods) {
        System.out.println("Method name : " + method.getName());
        System.out.println("Return type : " + method.getReturnType().getName());
        Class&lt;?&gt;[] params = method.getParameterTypes();
        System.out.print("Parameters : ");
        for (Class&lt;?&gt; param : params) {
            System.out.print(" " + param.getName());
        }
        System.out.println();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В конструкторе класса <code>ReflectionTest</code> сначала вызываются процедуры определения полей и методов объекта/класса <code>Reflect</code>. После этого вызываются методы изменения значений и печати значений с использованием <strong>Reflection API</strong>. Для определения метода <code>setData()</code> используется массив типов параметров. Вызов метода <code>setData()</code> выполняется с передачей ему массива новых значений.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class ReflectionTest {
    static Reflect reflect;

    public ReflectionTest() {
        getClassFields(reflect.getClass());
        getClassMethods(reflect.getClass());

        Class&lt;?&gt; cls = reflect.getClass();
        try {
            System.out.println("\n1. invoke method toString()\n");

            Method method = cls.getMethod("toString");
            System.out.println(method.invoke(reflect));

            Class&lt;?&gt;[] paramTypes;
            Object  [] args;

            paramTypes = new Class[] {int.class, String.class};
            method = cls.getMethod("setData", paramTypes);

            args = new Object[]{(int)123,new String("New value")};
            method.invoke(reflect, args);

            System.out.println("\n2. invoke method toString()\n");
            method = cls.getMethod("toString");
            System.out.println(method.invoke(reflect));

        } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
            System.out.println(e);
        }
    }

    private void getClassFields(Class&lt;?&gt; cls) {
        Field[] fields = cls.getDeclaredFields();
        System.out.println("Class fields");
        for (Field field : fields) {
            Class&lt;?&gt; fld = field.getType();
            System.out.println("Class name : " + field.getName());
            System.out.println("Class type : " + fld.getName());
        }
    }

    private void getClassMethods(Class&lt;?&gt; cls) {
        Method[] methods = cls.getDeclaredMethods();
        System.out.println("Class methods");
        for (Method method : methods) {
            System.out.println("Method name : " + method.getName());
            System.out.println("Return type : " + method.getReturnType().getName());
            Class&lt;?&gt;[] params = method.getParameterTypes();
            System.out.print("Parameters : ");
            for (Class&lt;?&gt; param : params) {
                System.out.print(" " + param.getName());
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        this.reflect = new Reflect();
        new ReflectionTest();
        System.exit(0);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В результате выполнения примера в консоль будут выведены представленные ниже сообщения. Методы <code>setData()</code> и <code>toString()</code>, вызываемые с помощью <strong>Java Reflection API</strong>, вносят измнения в закрытые поля класса и распечатываются их значения.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Class fields

Class name : name
Class type : java.lang.String
Class name : id
Class type : int

Class methods

Method name : toString
Return type : java.lang.String
Parameters  :

Method name : getId
Return type : int
Parameters  :

Method name : setId
Return type : void
Parameters :  int

Method name : getName
Return type : java.lang.String
Parameters  :

Method name : setName
Return type : void
Parameters :  java.lang.String

Method name : setData
Return type : void
Parameters :  int java.lang.String

1. invoke method toString()

Reflect [ id : 999, name : Test]

2. invoke method toString()

Reflect [ id : 123, name : New value]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_properties">5.11. Properties</h3>
<div class="paragraph">
<p>Класс <code>Properties</code> – это подкласс <code>Hashtable</code>.
Он используется для хранения списков значений, в которых ключ является <code>String</code>, а значение также является <code>String</code>.</p>
</div>
<div class="paragraph">
<p>Класс <code>Properties</code> в Java используется множеством других классов.
Например, это тип объекта, возвращаемый <code>System.getProperties()</code>, когда тот получает внешние значения.</p>
</div>
<div class="paragraph">
<p><code>Properties</code> определяет следующие переменную экземпляра.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Properties defaults;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Эта переменная содержит список свойств по умолчанию, связанный с объектом <code>Properties</code>.</p>
</div>
<div class="sect3">
<h4 id="_конструкторы_2">5.11.1. Конструкторы</h4>
<div class="paragraph">
<p>Вот список конструкторов, предоставляемые классом <code>Properties</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Properties()</code> конструктор создает объект <code>Properties</code>, который не имеет значений по умолчанию.</p>
</li>
<li>
<p><code>Properties(Properties propDefault)</code> создаёт объект, который использует propDefault для своих значений по умолчанию.
В обоих случаях список свойств пустой.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_методы_2">5.11.2. Методы</h4>
<div class="paragraph">
<p>Помимо методов, определённых <code>Hashtable</code>, <code>Properties</code> определяет следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String getProperty(String key)</code> возвращает значение, связанное с ключом.
Возвращается нулевой объект, если ключ не находится ни в списке, ни в списке свойств по умолчанию.</p>
</li>
<li>
<p><code>String getProperty(String key, String defaultProperty)</code> возвращает значение, связанное с ключом; Возвращается <code>defaultProperty</code>, если ключ не находится ни в списке, ни в списке свойств по умолчанию.</p>
</li>
<li>
<p><code>void list(PrintStream streamOut)</code> отправляет список свойств в выходной поток, связанный с <code>streamOut</code>.</p>
</li>
<li>
<p><code>void list(PrintWriter streamOut)</code> отправляет список свойств в выходной поток, связанный с <code>streamOut</code>.</p>
</li>
<li>
<p><code>void load(InputStream streamIn) throws IOException</code> вводит список свойств из входного потока, связанного с <code>streamIn</code>.</p>
</li>
<li>
<p><code>Enumeration propertyNames()</code> возвращает перечисление ключей, включая ключи, найденные в списке свойств по умолчанию.</p>
</li>
<li>
<p><code>Object setProperty(String key, String value)</code> связывает значение с ключом.
Возвращает предыдущее значение, связанное с ключом, или возвращает <code>null</code>, если такой связи не существует.</p>
</li>
<li>
<p><code>void store(OutputStream streamOut, String description)</code> после записи строки, указанной в описании, список свойств записывается в выходной поток, связанный с <code>streamOut</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_примеры_2">5.11.3. Примеры</h4>
<div class="sect4">
<h5 id="_пример_системные_свойства">Пример: системные свойства</h5>
<div class="paragraph">
<p>Получим и выведем все системные свойства:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.Map;
import java.util.Properties;
import java.util.Set;

/**
 * Java program to demonstrate Properties class to get all the system properties
 */
public class PropertiesExample2GetSystemProperties {
    /**
     * Main method for Demo
     *
     * @param args input arguments
     */
    public static void main(String[] args) {
        // get all the system properties
        Properties p = System.getProperties();

        // stores set of properties information
        Set&lt;Map.Entry&lt;Object, Object&gt;&gt; set = p.entrySet();

        // iterate over the set
        for (Map.Entry&lt;Object, Object&gt; entry : set) {
            // print each property
            System.out.printf("%s=%s\n", entry.getKey(), entry.getValue());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Будет выведено следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>java.specification.version=15
sun.management.compiler=HotSpot 64-Bit Tiered Compilers
sun.jnu.encoding=UTF-8
java.runtime.version=15.0.1+9
java.class.path=/home/rakovets/dev/course-java-basics/build/classes/java/main:/home/rakovets/dev/course-java-basics/build/resources/main
user.name=rakovets
java.vm.vendor=AdoptOpenJDK
path.separator=:
sun.arch.data.model=64
os.version=5.8.0-34-generic
user.variant=
java.runtime.name=OpenJDK Runtime Environment
file.encoding=UTF-8
java.vendor.url=https://adoptopenjdk.net/
java.vm.name=OpenJDK 64-Bit Server VM
java.vm.specification.version=15
os.name=Linux
java.vendor.version=AdoptOpenJDK
user.country=US
sun.java.launcher=SUN_STANDARD
sun.boot.library.path=/home/rakovets/.sdkman/candidates/java/15.0.1.hs-adpt/lib
sun.java.command=com.rakovets.course.javabasics.example.properties.PropertiesExample2GetSystemProperties
java.vendor.url.bug=https://github.com/AdoptOpenJDK/openjdk-support/issues
java.io.tmpdir=/tmp
jdk.debug=release
sun.cpu.endian=little
java.version=15.0.1
user.home=/home/rakovets
user.dir=/home/rakovets/dev/course-java-basics
user.language=en
os.arch=amd64
java.specification.vendor=Oracle Corporation
java.vm.specification.name=Java Virtual Machine Specification
java.version.date=2020-10-20
java.home=/home/rakovets/.sdkman/candidates/java/15.0.1.hs-adpt
file.separator=/
java.vm.compressedOopsMode=Zero based
line.separator=

java.library.path=/usr/java/packages/lib:/usr/lib64:/lib64:/lib:/usr/lib
java.vm.info=mixed mode, sharing
java.vm.specification.vendor=Oracle Corporation
java.specification.name=Java Platform API Specification
java.vendor=AdoptOpenJDK
java.vm.version=15.0.1+9
sun.io.unicode.encoding=UnicodeLittle
java.class.version=59.0</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_пример_чтение_свойств_из_файла">Пример: чтение свойств из файла</h5>
<div class="paragraph">
<p>Файл <code>account.properties</code> содержит следующий списком свойств:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="properties">username=rakovets
password=Fc9S42SMEfJbNVtM</code></pre>
</div>
</div>
<div class="paragraph">
<p>Прочитаем его и выведем все свойства:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;

/**
 * Java program to demonstrate Properties class to get information from the properties file
 */
public class PropertiesExample1 {
    /**
     * Main method for Demo
     *
     * @param args input arguments
     * @throws IOException throw IOException when work with IO
     */
    public static void main(String[] args) throws IOException {
        // get path for user.properties
        Path userPropertiesPath =
                Paths.get("src", "main", "resources", "example", "properties", "account.properties");

        // create a reader object on the properties file
        FileReader reader = new FileReader(userPropertiesPath.toFile());

        // create properties object
        Properties p = new Properties();

        // Add a wrapper around reader object
        p.load(reader);

        // access properties data
        System.out.printf("Username: '%s'\n", p.getProperty("username"));
        System.out.printf("Password: '%s'\n", p.getProperty("password"));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Будет выведено следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Username: 'rakovets'
Password: 'Fc9S42SMEfJbNVtM'</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_пример_записи_свойств_в_файл">Пример: записи свойств в файл</h5>
<div class="paragraph">
<p>Создадим свойства и запишем их в файл <code>user.properties</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;

/**
 * Java program to demonstrate Properties class to create the properties file
 */
public class PropertiesExample3CreateAndWriteToFile {
    /**
     * Main method for Demo
     *
     * @param args input arguments
     * @throws IOException throw IOException when work with IO
     */
    public static void main(String[] args) throws IOException {
        // create an instance of Properties
        Properties p = new Properties();

        // add properties to it
        p.setProperty("name", "Dmitry Rakovets");
        p.setProperty("email", "dmitryrakovets@gmail.com");

        // get path for account.properties
        Path userPropertiesPath =
                Paths.get("src", "main", "resources", "example", "properties", "user.properties");

        // store the properties to a file
        p.store(new FileWriter(userPropertiesPath.toFile()), "Properties Example");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Создастся файл <code>user.properties</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="properties">#Properties Example
#Fri Jan 08 10:05:19 MSK 2021
name=Dmitry Rakovets
email=dmitryrakovets@gmail.com</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_javadoc">5.12. Javadoc</h3>
<div class="paragraph">
<p>Наибольшая проблема, связанная с документированием кода – поддержка этой документации. Если документация и код разделены, возникают трудности, связанные с необходимостью внесения изменений в соответствующие разделы сопроводительной документации всякий раз при изменении программного кода. Среда разработки предлагает решение – связать код с документацией, поместив всё в один файл.</p>
</div>
<div class="paragraph">
<p><strong>Javadoc</strong> — генератор документации в HTML-формате из комментариев исходного кода на Java.</p>
</div>
<div class="paragraph">
<p>Комментарии документации применяют для документирования:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>классов</p>
</li>
<li>
<p>интерфейсов</p>
</li>
<li>
<p>полей (переменных)</p>
</li>
<li>
<p>конструкторов</p>
</li>
<li>
<p>методов</p>
</li>
<li>
<p>пакетов</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В каждом случае комментарий должен находиться перед документируемым элементом.</p>
</div>
<div class="paragraph">
<p>Утилита <strong>javadoc</strong> позволяет вставлять HTML тэги и использовать специальные ярлыки, <strong>дескрипторы</strong> (<strong>descriptor</strong>),  документирования.</p>
</div>
<div class="paragraph">
<p>НТМL тэги заголовков не используют, чтобы не нарушать стиль файла, сформированного утилитой.</p>
</div>
<div class="paragraph">
<p><strong>Дескрипторы javadoc</strong>, начинающиеся со знака <code>@,</code> называются автономными и должны помещаться с начала строки комментария (лидирующий символ <code>*</code> игнорируется).</p>
</div>
<div class="paragraph">
<p>Дескрипторы, начинающиеся с фигурной скобки, например <code>{@code}</code>, называются встроенными и могут применяться внутри описания.</p>
</div>
<div class="sect3">
<h4 id="_список_дескрипторов_javadoc">5.12.1. Список дескрипторов Javadoc</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Дескриптор</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Описание</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Применим к</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@author</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Автор</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">класс, интерфейс</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@version</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Версия (Не более одного дескриптора на класс)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">класс, интерфейс</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@since</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Указывает, с какой версии доступно</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">класс, интерфейс, поле, метод</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@see</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ссылка на другое место в документации</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">класс, интерфейс, поле, метод</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@param</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Входной параметр метода</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">метод</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@return</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Описание возвращаемого значения</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">метод</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@deprecated</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Описание устаревших блоков кода</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">класс, интерфейс, поле, метод</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{@link reference}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ссылка</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">класс, интерфейс, поле, метод</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{@value}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Описание значения переменной</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">статичное поле</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_генерация_файлов">5.12.2. Генерация файлов</h4>
<div class="paragraph">
<p>Утилита <strong>javadoc</strong> в качестве входных данных принимает файл с исходным кодом программы. Генерирует несколько НТМL файлов, содержащих документацию по этой программе. Информация о каждом классе будет содержаться в отдельном НТМL файле. Кроме того, создается дерево индексов и иерархии. Могут быть сгенерированы и другие НТМL файлы.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_java_nio">5.13. Java NIO</h3>
<div class="paragraph">
<p>Java NIO (New IO) - это альтернативный API для работы с IO в Java (начиная с Java 1.4), это значит альтернативный стандартным Java IO и API Java Networking. Java NIO предлагает другой способ работы с IO, чем стандартный IO API.</p>
</div>
<div class="paragraph">
<p><strong>Java NIO: channels и buffers</strong></p>
</div>
<div class="paragraph">
<p>В стандартном IO API работают с потоками байт и потоками символов. В NIO работают с каналами и буферами. Данные всегда читаются из канала в буфер или записываются из буфера в канал.</p>
</div>
<div class="paragraph">
<p><strong>Java NIO: non-bloking IO</strong></p>
</div>
<div class="paragraph">
<p>Java NIO позволяет выполнять неблокирующие операции ввода-вывода. Например, поток может попросить канал прочитать данные в буфер. Пока канал читает данные в буфер, поток может делать что-то другое. Как только данные будут считаны в буфер, поток сможет продолжить их обработку. Аналогично и для записи данных в каналы.</p>
</div>
<div class="paragraph">
<p><strong>Java NIO: selectors</strong></p>
</div>
<div class="paragraph">
<p>Java NIO имеет понятие «селекторы». <strong>Селектор</strong> - это объект, который может отслеживать несколько каналов на наличие событий (например: соединение установлено, данные получены и т.д.). Таким образом, один поток может контролировать несколько каналов данных.</p>
</div>
<div class="sect3">
<h4 id="_обзор_java_nio">5.13.1. Обзор Java NIO</h4>
<div class="paragraph">
<p><strong>Java NIO</strong> состоит из следующих основных компонентов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>каналы</p>
</li>
<li>
<p>буферы</p>
</li>
<li>
<p>селекторы</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Java NIO имеет не только эти компоненты, но фактически, <code>Channel</code>, <code>Buffer</code> и <code>Selector</code> являются ключевыми классами. Остальные компоненты, такие как <code>Pipe</code> и <code>FileLock</code> являются просто служебными классами, которые используются вместе с тремя основными компонентами.</p>
</div>
<div class="sect4">
<h5 id="_каналы_и_буферы">Каналы и Буферы</h5>
<div class="paragraph">
<p>Как правило, все операции ввода-вывода в NIO начинаются с <code>Channel</code>. <code>Channel</code> немного похож на <code>Stream</code>. Из <code>Channel</code> данные можно прочитать в <code>Buffer</code>. Данные также могут быть записаны из <code>Buffer</code> в <code>Channel</code>. :</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/assets/img/java/core/nio/channels-buffers.png" alt="Java NIO: каналы и буферы"></span></p>
</div>
<div class="paragraph">
<p>Есть несколько <code>Channel</code> и <code>Buffer</code> типов. Ниже приведен список основных реализаций <code>Channel</code> в Java NIO:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FileChannel</code></p>
</li>
<li>
<p><code>DatagramChannel</code></p>
</li>
<li>
<p><code>SocketChannel</code></p>
</li>
<li>
<p><code>ServerSocketChannel</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Эти каналы охватывают сетевой ввод-вывод по протоколам <strong>UDP</strong> и <strong>TCP</strong> и файловый ввод-вывод.</p>
</div>
<div class="paragraph">
<p>А вот список основных реализаций <code>Buffer</code> в Java NIO:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ByteBuffer</code></p>
</li>
<li>
<p><code>CharBuffer</code></p>
</li>
<li>
<p><code>DoubleBuffer</code></p>
</li>
<li>
<p><code>FloatBuffer</code></p>
</li>
<li>
<p><code>IntBuffer</code></p>
</li>
<li>
<p><code>LongBuffer</code></p>
</li>
<li>
<p><code>ShortBuffer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Они <code>Buffer</code> охватывают основные типы данных, которые вы можете отправлять через IO:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>char</code></p>
</li>
<li>
<p><code>byte</code></p>
</li>
<li>
<p><code>short</code></p>
</li>
<li>
<p><code>int</code></p>
</li>
<li>
<p><code>long</code></p>
</li>
<li>
<p><code>float</code></p>
</li>
<li>
<p><code>double</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Java NIO также имеет, <code>MappedByteBuffer</code> который используется для работы с отображением файлов в оперативной памяти.</p>
</div>
</div>
<div class="sect4">
<h5 id="_селекторы">Селекторы</h5>
<div class="paragraph">
<p><code>Selector</code> позволяет одному потоку обрабатывать несколько <code>Channel</code>. Это удобно, если в вашем приложении открыто много соединений (каналов), но каждое соединении имеет небольшой трафик. Например: сервер для чата.</p>
</div>
<div class="paragraph">
<p>Ниже приведенно изображение, того как <code>Thread</code> использует <code>Selector</code> для обработки 3 <code>Channel</code>:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/assets/img/java/core/nio/selectors.png" alt="Java NIO: селекторы"></span></p>
</div>
<div class="paragraph">
<p>Чтобы использовать, <code>Selector</code> необходимо зарегистрировать <code>Channel</code> с ним. Для этого используеют вызов метода <code>select()</code>. Этот метод будет заблокирован, пока не произойдет событие для одного из зарегистрированных каналов. Как только метод разблокируется, поток может обработать события. Примерами событий являются: входящее соединение, полученные данные и т.д.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_channel">5.13.2. <code>Channel</code></h4>
<div class="paragraph">
<p>Каналы Java NIO похожи на потоки с некоторыми отличиями:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>можно читать/писать из/в каналы, а потоки обычно односторонние (чтение/запись)</p>
</li>
<li>
<p>каналы могут быть прочитаны/записаны асинхронно</p>
</li>
<li>
<p>каналы всегда читают/записывают из/в буфер</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_реализация_channel">Реализация <code>Channel</code></h5>
<div class="paragraph">
<p>Вот наиболее важные реализации <code>Channel</code> в Java NIO:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FileChannel</code> - считывает данные из/в файла</p>
</li>
<li>
<p><code>DatagramChannel</code> - считывает/записывает данные по сети через <strong>UDP</strong></p>
</li>
<li>
<p><code>SocketChannel</code> - считывает/записывает данные по сети через <strong>TCP</strong></p>
</li>
<li>
<p><code>ServerSocketChannel</code> - прослушивает входящие соединения <strong>TCP</strong>, как это делает web-server, т.е. для каждого входящего соединения создается <code>SocketChannel</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_пример_основного_канала">Пример основного канала</h5>
<div class="paragraph">
<p>Вот базовый пример, в котором используется <code>FileChannel</code> для чтения некоторых данных в <code>Buffer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw");
FileChannel inChannel = aFile.getChannel();

ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf);
while (bytesRead != -1) {
    System.out.println("Read " + bytesRead);
    buf.flip();

    while(buf.hasRemaining()) {
        System.out.print((char) buf.get());
    }

    buf.clear();
    bytesRead = inChannel.read(buf);
}
aFile.close();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание на вызов <code>buf.flip()</code>. Сначала из канала считывают в буфер. Затем буфер переворачивают. После чего считывают из буффера.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buffers">5.13.3. Buffers</h4>
<div class="paragraph">
<p>Буферы используются при взаимодействии с каналами.</p>
</div>
<div class="paragraph">
<p>Буфер - это, по сути, блок памяти, в который можно записывать данные, которые затем можно снова прочитать. Этот блок памяти обернут в объект <code>Buffer</code>, который предоставляет набор методов, облегчающих работу с блоком памяти.</p>
</div>
<div class="sect4">
<h5 id="_основное_использование_буфера">Основное использование буфера</h5>
<div class="paragraph">
<p>Использование <code>Buffer</code> для чтения и записи данных обычно состоит из четырех шагов:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Записать данные в буфер</p>
</li>
<li>
<p>Вызов метода <code>buffer.flip()</code></p>
</li>
<li>
<p>Чтение данных из буфера</p>
</li>
<li>
<p>Вызов одного из методов <code>buffer.clear()</code> или <code>buffer.compact()</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Когда данные записывают в буфер, буфер отслеживает, сколько данных записано. Когда нужно прочитать данные, тогда нужно переключить буфер из режима записи в режим чтения с помощью вызова метода <code>flip()</code>. В режиме чтения буфер позволяет читать все данные, записанные в буфер.</p>
</div>
<div class="paragraph">
<p>После того, как все данные были прочитаны, необходимо очистить буфер, чтобы он снова был готов к записи. Это можно сделать вызвав один из двух методов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>clear()</code> - метод очищает весь буфер</p>
</li>
<li>
<p><code>compact()</code> - метод удаляет только те данные, которые уже прочитали. Любые непрочитанные данные перемещаются в начало буфера, и теперь новые данные будут записываться в буфер после непрочитанных данных</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw");
FileChannel inChannel = aFile.getChannel();

//create buffer with capacity of 48 bytes
ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf); //read into buffer.
while (bytesRead != -1) {
    buf.flip();  //make buffer ready for read

    while(buf.hasRemaining()){
        System.out.print((char) buf.get()); // read 1 byte at a time
    }

    buf.clear(); //make buffer ready for writing
    bytesRead = inChannel.read(buf);
}
aFile.close();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_capacity_position_и_limit_для_буфера">Capacity, position и limit для буфера</h5>
<div class="paragraph">
<p>У <code>Buffer</code> есть три поля, с которыми нужно ознакомиться, чтобы понять, как <code>Buffer</code> работает:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>capacity</code></p>
</li>
<li>
<p><code>position</code></p>
</li>
<li>
<p><code>limit</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Значение <code>position</code> и <code>limit</code> зависит от того, <code>Buffer</code> находится ли режим чтения или записи. Емкость всегда означает одно и то же, независимо от режима буфера.</p>
</div>
<div class="paragraph">
<p>Вот иллюстрация емкости, положения и ограничения в режимах записи и чтения. Объяснение следует в разделах после иллюстрации.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/assets/img/java/core/nio/buffers-modes.png" alt="Java NIO: capacity" width="position" height="limit для буфера в режиме записи и чтения"></span></p>
</div>
<div class="sect5">
<h6 id="_capacity">Capacity</h6>
<div class="paragraph">
<p>Будучи блоком памяти, a <code>Buffer</code> имеет определенный фиксированный размер, в который можно записывать только байты, символы и т.д. Когда буфер заполнен, тогда нужно его очистить (прочитать или очистить данные), прежде чем иметь возможность записать в него больше данных.</p>
</div>
</div>
<div class="sect5">
<h6 id="_position">Position</h6>
<div class="paragraph">
<p>Когда данные записываются в <code>Buffer</code>, то это происходит с текущей <code>position</code>. Первоначально позиция равна <code>0</code>. Когда происходит запись одного байта, символа и т.д. в <code>Buffer</code> в текущую <code>position</code>, то она перемещается вперед, чтобы указывать на следующую ячейку в буфере, куда в дальнейшем будут записываться данные. Максимальное значение <code>position</code> может быть <code>capacity - 1</code>.</p>
</div>
<div class="paragraph">
<p>Когда данные из <code>Buffer</code> читаются, то это можно делать с текущей <code>position</code>. Когда <code>Buffer</code> переключается из режима записи в режим чтения, <code>position</code> сбрасывается обратно на <code>0</code>. При чтении данных из <code>Buffer</code>, они читаются с <code>position</code> и значение <code>position</code> изменяется на следующее.</p>
</div>
</div>
<div class="sect5">
<h6 id="_limit">Limit</h6>
<div class="paragraph">
<p>В режиме записи <code>limit</code> для <code>Buffer</code> - это предел того, сколько данных можно записать в буфер. В режиме записи ограничение равно <code>capacity</code> для <code>Buffer</code>.</p>
</div>
<div class="paragraph">
<p>При переключении <code>Buffer</code> в режим чтения, <code>limit</code> означает предел того, сколько данных можно прочитать. Следовательно, при переключении <code>Buffer</code> в режим чтения <code>limit</code> задается равным <code>position</code> в режиме записи. Другими словами, можно прочитать столько байтов, сколько было записано.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_типы_буфера">Типы буфера</h5>
<div class="paragraph">
<p>Java NIO содержит следующие типы буферов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ByteBuffer</code></p>
</li>
<li>
<p><code>MappedByteBuffer</code></p>
</li>
<li>
<p><code>CharBuffer</code></p>
</li>
<li>
<p><code>DoubleBuffer</code></p>
</li>
<li>
<p><code>FloatBuffer</code></p>
</li>
<li>
<p><code>IntBuffer</code></p>
</li>
<li>
<p><code>LongBuffer</code></p>
</li>
<li>
<p><code>ShortBuffer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Эти типы <code>Buffer</code> представляют разные типы данных. Другими словами, они позволяют работать с байтами в буфере как <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code> или <code>double</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_создание_буфера">Создание буфера</h5>
<div class="paragraph">
<p>У каждого <code>Buffer</code> класса есть <code>allocate()</code> метод, который создает объект <code>Buffer</code>. Например, создание <code>ByteBuffer</code> с <code>capacity</code> 48 байт:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ByteBuffer buf = ByteBuffer.allocate(48);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например, создание <code>CharBuffer</code> с <code>capacity</code> для размещения 1024 символов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">CharBuffer buf = CharBuffer.allocate(1024);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_запись_данных_в_буфер">Запись данных в буфер</h5>
<div class="paragraph">
<p>Данные в буфер можно записать двумя способами:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>из <code>Channel</code> в <code>Buffer</code></p>
</li>
<li>
<p>используя <code>put()</code> методы класса <code>Buffer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример, как с помощью <code>Channel</code> можно записывать данные в <code>Buffer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int bytesRead = inChannel.read(buf); // read into buffer</code></pre>
</div>
</div>
<div class="paragraph">
<p>Пример, как с помощью метода <code>put()</code> класса <code>Buffer</code> можно записывать данные в него:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">buf.put (127);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Существует много других версий метода <code>put()</code>, позволяющих записывать данные в <code>Buffer</code> различными способами. Например, запись в определенные позиции или запись массива байтов в буфер. Все это, можно посмотреть в <strong>JavaDoc</strong> для конкретной реализации буфера.</p>
</div>
</div>
<div class="sect4">
<h5 id="_flip"><code>flip()</code></h5>
<div class="paragraph">
<p>Метод <code>flip()</code> переключает <code>Buffer</code> из режима записи в режиме чтения. Вызов метода <code>flip()</code> устанавливает <code>position</code> обратно в <code>0</code> и устанавливает <code>limit</code> значение недавного <code>position</code>.</p>
</div>
<div class="paragraph">
<p>Другими словами, <code>position</code> теперь указывает на позицию чтения, а  <code>limit</code> показывает, сколько байт, символов и т.д. было записано в буфер.</p>
</div>
</div>
<div class="sect4">
<h5 id="_чтение_данных_из_буфера">Чтение данных из буфера</h5>
<div class="paragraph">
<p>Есть два способа чтения данных из <code>Buffer</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>из <code>Buffer</code> в <code>Channel</code></p>
</li>
<li>
<p>используя <code>get()</code> методы класса <code>Buffer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример, как с помощью <code>Channel</code> можно читать данные из <code>Buffer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">//read from buffer into channel.
int bytesWritten = inChannel.write(buf);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Пример, как с помощью метода <code>get()</code> класса <code>Buffer</code> можно читать данные из него:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">byte aByte = buf.get();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Существует много других версий метода <code>get()</code>, позволяющих считывать данные из <code>Buffer</code> различными способами. Например, чтение из определенных позиций или чтение массива байт из буфера. Все это, можно посмотреть в <strong>JavaDoc</strong> для конкретной реализации буфера.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rewind"><code>rewind()</code></h5>
<div class="paragraph">
<p><code>Buffer.rewind()</code> устанавливает в <code>position</code> значение <code>0</code>, так что можно было перечитать все данные в буфере. При этом <code>limit</code> не изменяется.</p>
</div>
</div>
<div class="sect4">
<h5 id="_clear_и_compact"><code>clear()</code> и <code>compact()</code></h5>
<div class="paragraph">
<p>После прочтения данных из <code>Buffer</code>, его необходимо снова подготовиться к записи. Это можно сделать, вызвав методы <code>clear()</code> или <code>compact()</code>.</p>
</div>
<div class="paragraph">
<p>Если вызвать метод <code>clear()</code>, то <code>limit</code> станет равен значению <code>capacity</code>, a <code>position</code> станет <code>0</code>. Другими словами, <code>Buffer</code> очищается, но данные из него не удалены.</p>
</div>
<div class="paragraph">
<p>Если в момент вызова <code>clear()</code> были непрочитанные данные, то нельзя больше установить какие из них были прочитаны, а какие нет.</p>
</div>
<div class="paragraph">
<p>Если в <code>Buffer</code> все еще есть непрочитанные данные, и их необходимо прочитать позже, но перед этим нужно что-то еще записать в <code>Buffer</code>, тогда используют <code>compact()</code> вместо <code>clear()</code>.</p>
</div>
<div class="paragraph">
<p>Метод <code>compact()</code> копирует все непрочитанные данные в начало <code>Buffer</code>, а затем <code>position</code> устанавливается  сразу после последнего непрочитанного элемента. Для <code>limit</code> задается значение <code>capacity</code>, так же, как и для <code>clear()</code>. Теперь <code>Buffer</code> готов к записи и непрочитанные данные не будет перезаписываться.</p>
</div>
</div>
<div class="sect4">
<h5 id="_mark_и_reset"><code>mark()</code> и <code>reset()</code></h5>
<div class="paragraph">
<p>Можно пометить данную позицию в <code>Buffer</code>, вызвав метод <code>Buffer.mark()</code>. Затем можно сбросить <code>position</code> обратно в помеченную позицию, вызвав метод <code>Buffer.reset()</code>. Вот пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">buffer.mark();
//call buffer.get() a couple of times, e.g. during parsing.
buffer.reset();  //set position back to mark.</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_equals_и_compareto"><code>equals()</code> и <code>compareTo()</code></h5>
<div class="paragraph">
<p>Можно сравнить два буфера, используя <code>equals()</code> и <code>compareTo()</code>.</p>
</div>
<div class="sect5">
<h6 id="_equals"><code>equals()</code></h6>
<div class="paragraph">
<p>Два буфера равны, если:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Они одного типа (байт, символ, int и т. Д.)</p>
</li>
<li>
<p>Они имеют одинаковое количество оставшихся байтов, символов и т. Д. В буфере.</p>
</li>
<li>
<p>Все остальные байты, символы и т. Д. Равны.</p>
</li>
<li>
<p>Как вы можете видеть, функция equals сравнивает только часть `Buffer, а не каждый отдельный элемент. На самом деле, он просто сравнивает остальные элементы в `Buffer.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_compareto"><code>compareTo()</code></h6>
<div class="paragraph">
<p>Метод <code>compareTo()</code> сравнивает остальные элементы (байты, символы и т.д.) из двух буферов, для использования, например, в подпрограммах сортировки. Буфер считается «меньшим», чем другой буфер, если:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>найден элемент, который отличается от соответствующего элемента из другого буфера, и он меньше его</p>
</li>
<li>
<p>все элементы равны, но в первом буфере количество элементов меньше, чем во втором</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_java_memory_management">5.14. Java Memory Management</h3>
<div class="sect3">
<h4 id="_почему_необходимо_заботиться_об_управлении_памятью">5.14.1. Почему необходимо заботиться об управлении памятью?</h4>
<div class="paragraph">
<p>Многие разработчики не заботятся об управлении памятью, так как в Java ж е есть <strong>Garbage Collection</strong> (<strong>GC</strong>/<strong>Сборка мусора</strong>). <strong>Garbage Collection</strong> - это процесс, с помощью которого Java программы выполняют автоматическое управление памятью. По сути, код, который пишется на Java (и других языках для JVM), компилируется в byte-код (файл <code>.class</code>) и запускается на <strong>JVM</strong> (<strong>виртуальной машине Java</strong>). Когда приложение работает на <strong>JVM</strong>, большинство объектов создается в <strong>HEAP</strong> (<strong>Куча</strong>). В процессе работы, некоторые объекты больше не понадобятся (недоступные/неиспользуемые объекты). <strong>Garbage Collector</strong> (<strong>Сборщик мусора</strong>) освободит неиспользуемую память, чтобы вернуть память для программы, других приложений и операционной системы.</p>
</div>
<div class="quoteblock">
<blockquote>
Memory management is the process of allocating new objects and removing unused objects to make space for those new object allocations
</blockquote>
<div class="attribution">
&#8212; oracle.com
</div>
</div>
<div class="paragraph">
<p>В некоторых языках, таких как C, необходимо управлять памятью вручную. Таким образом, написать приложение на C очень сложно. Мы должны тщательно выделять/освобождать переменные и объекты, потому что это может привести к <strong>memory leak</strong> (<strong>утечке памяти</strong>).</p>
</div>
<div class="paragraph">
<p>Проще говоря когда в <strong>HEAP</strong> выделена память для объекта, он не используется и эта память не может освободиться, в этом случае это <strong>memory leak</strong>. <strong>Memory leak</strong> следует избегать, потому что они приводят к <em>падению</em> приложения или заставляют его работать медленно.</p>
</div>
<div class="paragraph">
<p>Предположим, нам нужно получить метаданные изображения, когда у нас есть URL-адрес этого файла. Для простоты можно использовать файл на локальном компьютере.</p>
</div>
<div class="paragraph">
<p>Основная программа:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">package com.rakovets.jmm.main;

import com.rakovets.jmm.entity.Metadata;
import com.rakovets.jmm.utils.ImageMetadataUtils;

public class ImageMetadataExample {
    public static void main(String[] args) {
        try {
            final String url = "/home/rakovets/pics/2000x2000px_keepcalm.jpg";
            for (int i = 0; i &lt; 2000; i ++) {
                Metadata metadata = ImageMetadataUtils.getMetadataLocalFile(url);
                System.out.println(String.format("Count %d URL: %s, metadata: %s", i, url, metadata.toString()));
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>MetadataUtils</code> класс:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">package com.rakovets.jmm.utils;

import java.awt.image.BufferedImage;
import java.io.File;
import java.util.Map;
import java.util.Set;

import javax.imageio.ImageIO;
import com.rakovets.jmm.entity.Metadata;

import lombok.experimental.UtilityClass;

@UtilityClass
public class ImageMetadataUtils {
    public static Metadata getMetadataLocalFile(String url) {
        try {
            final File outputFile = new File(url);
            final BufferedImage buf = ImageIO.read(outputFile);
            final int width = buf.getWidth();
            final int height = buf.getHeight();
            final long fileSize = outputFile.length();
            return new Metadata(url, width, height, fileSize);
        } catch (Exception e) {
            e.printStackTrace();
            System.out.printf("[ERROR] Get metadata from url %s: %s\n", url, e.getMessage());
            return null;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Класс <code>Metadata</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">package com.rakovets.jmm.entity;

public class Metadata {
    private String url;
    private Integer width;
    private Integer height;
    private Long fileSizeInBytes;

    public Metadata(String url, Integer width, Integer height, Long fileSizeInBytes) {
        this.url = url;
        this.width = width;
        this.height = height;
        this.fileSizeInBytes = fileSizeInBytes;
    }

    public String toString() {
        return new StringBuilder()
                .append("Width ").append(width)
                .append(", Height: ").append(height)
                .append(", Size: ").append(fileSizeInBytes)
                .toString();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Есть ли в вышеприведенном коде какие-то проблемы? Как определить что в программе есть проблемы с памятью? Для этого можно использовать специализированные инструменты для мониторинга Java-приложений. Один из которых и будет далее использоваться: <strong>JVisualVM</strong>.</p>
</div>
<div class="paragraph">
<div class="title">Tab Heap</div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/j-visual-vm-1.png" alt="Tab Heap"></span></p>
</div>
<div class="paragraph">
<p>В раздел <strong>HEAP</strong> можно увидеть что небольшая программа потребляет <code>1 044 839 312</code> byte  (~ 1Gb) памяти в <strong>HEAP</strong>.</p>
</div>
<div class="paragraph">
<p>Почему?</p>
</div>
<div class="paragraph">
<p>Посмотрим <strong>Heap Dump</strong>.</p>
</div>
<div class="paragraph">
<div class="title">Object <code>BufferImage</code></div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/j-visual-vm-2.png" alt="Object <code>BufferImage</code>"></span></p>
</div>
<div class="paragraph">
<p>Объект <code>BufferImage</code> очень большой и занимает 12Mb в <strong>HEAP</strong>. Поскольку один пиксель занимает 3 байта памяти, а используется изображение размером 2000x2000 пикселей (3 * 2000 * 2000 = 12Mb).</p>
</div>
<div class="paragraph">
<p>Проблема обнаружена, соответственно можно выработать решение для данной проблемы.</p>
</div>
<div class="paragraph">
<p>Используем класс <code>com.drew.imaging.ImageMetadataReader</code> в библиотеке <a href="https://jar-download.com/artifacts/com.drewnoakes/metadata-extractor/2.11.0/source-code">metadata-extractor</a> для получения метаданных изображения.</p>
</div>
<div class="paragraph">
<p>Обновленный код для класса <code>ImageMetadataUtils</code> и основной программы будет выглядеть следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">package com.rakovets.jmm.utils;

import java.awt.image.BufferedImage;
import java.io.File;
import java.util.Map;
import java.util.Set;

import javax.imageio.ImageIO;

import com.drew.metadata.Directory;
import com.drew.metadata.bmp.BmpHeaderDirectory;
import com.drew.metadata.exif.ExifIFD0Directory;
import com.drew.metadata.gif.GifHeaderDirectory;
import com.drew.metadata.jpeg.JpegDirectory;
import com.drew.metadata.png.PngDirectory;
import com.google.common.collect.ImmutableMap;
import com.rakovets.jmm.entity.Metadata;
import com.drew.imaging.ImageMetadataReader;

import lombok.Builder;
import lombok.Data;
import lombok.experimental.UtilityClass;

@UtilityClass
public class ImageMetadataUtils {
    @Data
    @Builder
    private static class NeededImageTag {
        private int height;
        private int width;
    }
    private static final Map&lt;Class&lt;? extends Directory&gt;, NeededImageTag&gt; SUPPORTED_TYPES_MAP
            = new ImmutableMap.Builder&lt;Class&lt;? extends Directory&gt;, NeededImageTag&gt;()
            .put(JpegDirectory.class, NeededImageTag.builder().height(JpegDirectory.TAG_IMAGE_HEIGHT).width(JpegDirectory.TAG_IMAGE_WIDTH).build())
            .put(PngDirectory.class, NeededImageTag.builder().height(PngDirectory.TAG_IMAGE_HEIGHT).width(PngDirectory.TAG_IMAGE_WIDTH).build())
            .put(GifHeaderDirectory.class, NeededImageTag.builder().height(GifHeaderDirectory.TAG_IMAGE_HEIGHT).width(GifHeaderDirectory.TAG_IMAGE_WIDTH).build())
            .put(BmpHeaderDirectory.class, NeededImageTag.builder().height(BmpHeaderDirectory.TAG_IMAGE_HEIGHT).width(BmpHeaderDirectory.TAG_IMAGE_WIDTH).build())
            .put(ExifIFD0Directory.class, NeededImageTag.builder().height(ExifIFD0Directory.TAG_IMAGE_HEIGHT).width(ExifIFD0Directory.TAG_IMAGE_WIDTH).build())
            .build();
    private static final Set&lt;Class&lt;? extends Directory&gt;&gt; SUPPORTED_TYPES = SUPPORTED_TYPES_MAP.keySet();

    public static Metadata getMetadata(String url) {
        try {
            final File outputFile = new File(url);
            final long fileSize = outputFile.length();
            final com.drew.metadata.Metadata metadata = ImageMetadataReader.readMetadata(outputFile);
            for (final Class&lt;? extends Directory&gt; type : SUPPORTED_TYPES) {
                if (metadata.containsDirectoryOfType(type)) {
                    final Directory directory = metadata.getFirstDirectoryOfType(type);
                    final NeededImageTag tag = SUPPORTED_TYPES_MAP.get(type);
                    return new Metadata(url, directory.getInt(tag.width), directory.getInt(tag.height), fileSize);
                }
            }
            return null;
        } catch (Exception e) {
            e.printStackTrace();
            System.out.printf("[ERROR] Get metadata from url %s: %s\n", url, e.getMessage());
            return null;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Основная программа:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">package com.rakovets.jmm.main;

import com.rakovets.jmm.entity.Metadata;
import com.rakovets.jmm.utils.ImageMetadataUtils;

public class ImageMetadataExample {

    public static void main(String[] args) {
        try {
            // This application runs very fast and difficult to monitor so, I will sleep in 10 seconds.
            System.out.println("Sleep in 10 seconds");
            Thread.sleep(10000);
            final String url = "/Users/daudm/Desktop/2000x2000px_keepcalm.jpg";
            for (int i = 0; i &lt; 2000; i ++) {
                Metadata metadata = ImageMetadataUtils.getMetadata(url);
                System.out.printf("Count %d URL: %s, metadata: %s\n", i, url, metadata.toString());
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>После этого можно запустить приложение и отследить его с помощью <strong>JVisualVM</strong>:</p>
</div>
<div class="paragraph">
<div class="title">Tab Heap</div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/j-visual-vm-3.png" alt="Tab Heap"></span></p>
</div>
<div class="paragraph">
<p>Приложение работает очень быстро и потребляет всего 21Mb в <strong>HEAP</strong>.</p>
</div>
<div class="paragraph">
<p>Умение управление памятью очень важно для каждого разработчика. Это не зависит от языка программирования: Java, C и т.д. Более глубокое понимание управления памятью поможет написать приложение с высокой производительностью, которое может работать на маломощных машинах. По сути, приложение написанное на Java будет работать на <strong>JVM</strong>. Для того что бы управлять памятью в Java, необходимо сначала понять архитектуру <strong>JVM</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_архитектура_виртуальной_машины_java_архитектура_jvm">5.14.2. Архитектура виртуальной машины Java (архитектура JVM)</h4>
<div class="paragraph">
<p><strong>JVM</strong> - это всего лишь спецификация, и она имеет множество различных реализаций. Можно провести аналогию с интерфейсом и несколькими реализациями в Java программе. Чтобы узнать информацию о JVM, можно воспользоваться командой <code>java -version</code> в терминале.</p>
</div>
<div class="paragraph">
<p>Если установлена <strong>AdoptOpenJDK</strong>, то отобразится следующая информация:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>openjdk 11.0.7 2020-04-14
OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.7+10)
OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.7+10, mixed mode)</pre>
</div>
</div>
<div class="paragraph">
<p>Как же выглядит архитектура <strong>JVM</strong>?</p>
</div>
<div class="paragraph">
<div class="title"><strong>Java Virtual Machine</strong> Architecture</div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/jvm-architecture.png" alt="JVM Architecture"></span></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Class Loader Subsystem</strong> (<strong>Система загрузчиков классов</strong>): <strong>JVM</strong> работает с <strong>RAM</strong>. Во время выполнения с использованием <strong>Class Loader Subsystem</strong> файлы классов переносятся в <strong>RAM</strong>. Эта функция называется динамической загрузкой классов в Java. Она загружает, связывает и инициализирует <code>.class</code>-файлы, когда идет первое обращение к классу во время выполнения. В конце будет выполнена логика инициализации каждого загруженного класса (например, вызов конструктора класса), всем статическим переменным будут присвоены исходные значения, и будет выполнен статический блок.</p>
</li>
<li>
<p><strong>Runtime Data Area</strong> (<strong>Область данных времени выполнения</strong>): области памяти, которая выдается JVM при запуске программы в ОС.</p>
<div class="ulist">
<ul>
<li>
<p><strong>Method Area</strong> (<strong>Область метода</strong>) общая для потоков. Хранит все данные уровня класса (пул констант времени выполнения, статические переменные, данные полей, методы (данные, код)). Только один <strong>Method Area</strong> на <strong>JVM</strong>.</p>
</li>
<li>
<p><strong>Heap Area</strong> (<strong>Область кучи</strong>) общая для потоков: здесь будут храниться все переменные, объекты, массивы. Один <strong>Heap</strong> на каждую JVM. За <strong>Heap Area</strong> и его очистку от неиспользуемых объектов отвечает <strong>GC</strong>.</p>
</li>
<li>
<p><strong>Stack Area</strong> (<strong>Область стека</strong>) для каждого <strong>thread</strong> (<strong>потока</strong>) своя: для каждого потока в <strong>runtime</strong> будет создан новый <strong>stack area</strong>, для каждого вызова метода в стек будет добавлена одна запись, называемая <strong>stack frame</strong>. Каждый <strong>stack frame</strong> имеет ссылку на массив локальных переменных, стек операндов и пул констант времени выполнения класса, к которому принадлежит выполняемый метод.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Execution Engine</strong> (<strong>Механизм выполнения</strong>): будет выполнять <strong>byte</strong>-код, описанный в программе.</p>
<div class="ulist">
<ul>
<li>
<p><strong>Interpreter</strong> (<strong>Интерпретатор</strong>): быстро интерпретирует <strong>byte</strong>-код, но медленно выполняет его. Недостатком является то, что когда один метод вызывается несколько раз, каждый раз требуется новая интерпретация и более медленное выполнение.</p>
</li>
<li>
<p><strong>JIT Compiler</strong> (<strong>JIT-компилятор</strong>): устраняет недостатки <strong>interpreter</strong>, когда он обнаруживает повторяющийся код, он использует <strong>JIT Compiler</strong>. Он скомпилирует <strong>byte</strong>-код в машинный код. Код хранится в кеше, а не интерпретируется, поэтому скомпилированный код можно выполнить быстрее.</p>
</li>
<li>
<p><strong>Garbage Collector</strong> (<strong>Сборщик мусора</strong>): собирает и удаляет объекты, которые не используются (т.е. на которые нет ссылок). Пока на объект ссылаются, <strong>JVM</strong> считает его живым. Когда на объект больше не ссылаются и, следовательно, он недоступен для кода приложения, <strong>Garbage Collector</strong> удаляет его и освобождает неиспользуемую память. В общем, <strong>Garbage Collector</strong> - это автоматический процесс. Однако его можно запустить, вызвав метод <code>System.gc()</code> или <code>Runtime.getRuntime().gc()</code>. Но выполнение не гарантируется, поэтому следует вызвать <code>Thread.sleep(1000)</code> и дождаться завершения GC.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_модель_памяти_heap_без_heap_другая_память">5.14.3. Модель памяти (HEAP, без HEAP, другая память)</h4>
<div class="paragraph">
<p><strong>JVM</strong> использует доступное пространство памяти в операционной системе. <strong>JVM</strong> включает области памяти:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>HEAP</strong></p>
</li>
<li>
<p><strong>Non-HEAP</strong></p>
</li>
<li>
<p><strong>Other Memory</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">JVM Memory Model</div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/jvm-memory-model.png" alt="JVM Memory Model"></span></p>
</div>
<div class="sect4">
<h5 id="_heap">HEAP</h5>
<div class="paragraph">
<p>HEAP состоит из двух частей:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Young Generation</strong> (<strong>Young Gen</strong>/<strong>Молодое поколение</strong>)</p>
</li>
<li>
<p><strong>Old Generation</strong> (<strong>Old Gen</strong>/<strong>Старое поколение</strong>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title"><strong>JVM</strong> Heap Model</div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/jvm-heap-model.png" alt="JVM Heap Model"></span></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Young Generation</strong>: здесь создаются все новые объекты. Когда <strong>Young Generation</strong> заполнено, выполняется сборщик мусора (<strong>Minor GC</strong>). Он разделен на три части: одно <strong>Eden Space</strong> и два <strong>Survivor Spaces</strong> (<strong>S0</strong>, <strong>S1</strong>). Некоторые тонкости:</p>
<div class="ulist">
<ul>
<li>
<p>Большинство только что созданных объектов находится в <strong>Eden Space</strong>.</p>
</li>
<li>
<p>Если <strong>Eden Space</strong> заполнен объектами, <strong>Minor GC</strong> будет выполнен, и все выжившие объекты перемещается к одному из оставшихся в <strong>Survivor Spaces</strong>.</p>
</li>
<li>
<p>Объекты, уцелевшие после многих циклов <strong>Minor GC</strong>, перемещаются в пространство <strong>Old Generation space</strong>. Обычно это делается путем установления порога возраста объектов <strong>Young Generation</strong>, прежде чем они станут подходящими для продвижения к <strong>Old Generation</strong>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Old Generation</strong>: зарезервировано для содержания долгоживущие объектов, которые выживают после многих раундов в <strong>Minor GC</strong>. Когда <strong>Old Generation</strong> полно, будет выполнен <strong>Major GC</strong>, но как правило, он занимает больше времени.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_non_heap">Non-HEAP</h5>
<div class="paragraph">
<p><strong>Non-HEAP</strong> (<strong>Off-HEAP</strong>): иногда называют <strong>Off-HEAP</strong>. В Java 7 и более ранних версиях это пространство называется <strong>Permanent Generation</strong> (<strong>Perm Gen</strong>). Начиная с Java 8, <strong>Perm Gen</strong> заменяется <strong>Metaspace</strong>.</p>
</div>
<div class="paragraph">
<p><strong>Metaspace</strong> хранит структуры для каждого класса, такие как пул констант времени выполнения, данные полей и методов, а также код методов и конструкторов, а также интернированные строки.</p>
</div>
<div class="paragraph">
<p><strong>Metaspace</strong> по умолчанию автоматически увеличивает свой размер (до того, что предоставляет базовая ОС), в то время как <strong>Perm Gen</strong> всегда имеет фиксированный максимальный размер. Для установки размера метапространства можно использовать два новых флага: <code>-XX:MetaspaceSize</code> и <code>-XX:MaxMetaspaceSize</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_other_memory">Other memory</h5>
<div class="ulist">
<ul>
<li>
<p><strong>CodeCache</strong> содержит <strong>complied</strong>-код (т.е. <strong>native</strong>-код), созданный <strong>JIT-компилятором</strong>, внутренние структуры <strong>JVM</strong>, загруженный код агента профилировщика, данные и т.д.</p>
</li>
<li>
<p><strong>Thread Stacks</strong> относятся к интерпретируемым, скомпилированным и собственным <strong>stack frames</strong>.</p>
</li>
<li>
<p><strong>Direct Memory</strong> используется для выделения прямого буфера (например, <strong>NIO Buffer/ByteBuffer</strong>)</p>
</li>
<li>
<p><strong>C-Heap</strong> используется, например, <strong>JIT-компилятором</strong> или <strong>GC</strong> для выделения памяти для внутренних структур данных.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_garbage_collection">5.14.4. Garbage Collection</h4>
<div class="paragraph">
<p><strong>GC</strong> помогает разработчикам писать код без выделения/освобождения памяти и позволяет не заботиться о проблемах с памятью. Однако в реальном проекте иногда имеются проблем с памятью. Они заставляют приложение работать с неэффективно и очень медленно.</p>
</div>
<div class="paragraph">
<p>Таким образом, мы должны понять, как работает <strong>GC</strong>. Все объекты размещаются в <strong>HEAP</strong>, управляемой <strong>JVM</strong>. Пока на объект ссылаются, <strong>JVM</strong> считает его живым. Когда на объект больше не ссылаются и, следовательно, он недоступен для кода приложения, <strong>garbage collector</strong> удаляет его и освобождает неиспользуемую память.</p>
</div>
<div class="paragraph">
<p>Как <strong>GC</strong> управляет объектами в <strong>HEAP</strong>? Ответ заключается в том, что он строит <strong>Tree</strong> (<strong>дерево</strong>), называемое <strong>Garbage Collection Roots</strong> (<strong>GC roots</strong>/<strong>корни сборки мусора</strong>). Он содержит множество ссылок между кодом приложения и объектами в <strong>HEAP</strong>.</p>
</div>
<div class="paragraph">
<p>Существует четыре типа <strong>Garbage Collection Roots</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Local variables</strong> (<strong>локальные переменные</strong>)</p>
</li>
<li>
<p><strong>Active threads</strong> (<strong>активные потоки</strong>)</p>
</li>
<li>
<p><strong>Static variables</strong> (<strong>статические переменные</strong>)</p>
</li>
<li>
<p><strong>JNI references</strong> (<strong>JNI ссылки</strong>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пока на наш объект прямо или косвенно ссылается один из этих корней GC, а корень GC остается живым, наш объект можно рассматривать как достижимый объект. В тот момент, когда объект теряет ссылку на <strong>Garbage Collection Root</strong>, он становится недоступным, следовательно, может быть удален когда произойдет <strong>GC</strong>.</p>
</div>
<div class="paragraph">
<div class="title">Garbage Collection</div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/gc.png" alt="Garbage Collection"></span></p>
</div>
<div class="paragraph">
<p><strong>Garbage Collection Roots</strong> - это объекты, на которые сама <strong>JVM</strong> ссылается и, таким образом, предотвращает сборку мусора для всех остальных объектов.</p>
</div>
<div class="sect4">
<h5 id="_mark_and_sweep_model">Mark and Sweep Model</h5>
<div class="paragraph">
<p>Чтобы определить, какие объекты больше не используются, <strong>JVM</strong> использует алгоритм <strong>mark-and-sweep</strong>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Алгоритм просматривает все ссылки на объекты, начиная с <strong>Garbage Collection Roots</strong>, и отмечает каждый найденный объект как <em>живой</em>.</p>
</li>
<li>
<p>Требуется вся память *HEAP, которая не занятая отмеченными объектами.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Возможны случаи, когда есть неиспользуемые объекты, но которые все еще доступны для приложения, потому что разработчики просто забыли разыменовать их. В этом случае происходит <strong>memory-leak</strong> (<strong>утечка памяти</strong>). Поэтому следует отслеживать/анализировать приложение, чтобы определить проблему.</p>
</div>
<div class="paragraph">
<div class="title">GC: Mark adn Sweep</div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/gc-mark-and-sweep.png" alt="GC: Mark adn Sweep"></span></p>
</div>
<div class="paragraph">
<p>Когда на объекты больше не ссылается прямо или косвенно корень сборщика мусора, они будут удалены.</p>
</div>
</div>
<div class="sect4">
<h5 id="_stop_the_world_event">Stop the World Event</h5>
<div class="paragraph">
<p>При выполнении <strong>GC</strong> все потоки приложений останавливаются до завершения операции. Поскольку <strong>Young Generation</strong> хранит недолговечные объекты, <strong>Minor GC</strong> работает очень быстро, и это не влияет на приложение. Однако <strong>Major GC</strong> занимает много времени, потому что он проверяет все живые объекты. Количество <strong>Major GC</strong> следует свести к минимуму, поскольку он приведет к тому, что приложение не будет отвечать на все время <strong>GC</strong>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_мониторинг_и_настройка_gc">5.14.5. Мониторинг и настройка <strong>GC</strong></h4>
<div class="paragraph">
<p>Можно отслеживать приложение Java с помощью командной строки и различных инструментов. На самом деле существует множество инструментов: <strong>JVisualVM</strong>, <strong>JProfile</strong>, <strong>Eclipse MAT</strong>, <strong>JetBrains JVM Debugger</strong>, <strong>Netbeans Profiler</strong>, &#8230;&#8203; Рекомендуется использовать <strong>JVisualVM</strong>, который встроен в <strong>JDK</strong>. Этого достаточно для мониторинга приложения.</p>
</div>
<div class="sect4">
<h5 id="_jstat"><code>jstat</code></h5>
<div class="paragraph">
<p><code>jstat</code> - <strong>Java Virtual Machine Statistics Monitoring Tool</strong>. <code>jstat</code> можно использовать для мониторинга памяти <strong>JVM</strong> и активности <strong>GC</strong>. Например, можно печать потребление памяти и данных <strong>GC</strong> каждую секунду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="shell script">jstat -gc &lt;pid&gt; 1000</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Пример с командой <code>jstat</code></div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/jstat.png" alt="Пример с командой <code>jstat</code>"></span></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. <code>jstat</code> abbreviations</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Column</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>S0C</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current survivor space 0 capacity (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>S1C</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current survivor space 1 capacity (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>S0U</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Survivor space 0 utilization (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>S1U</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Survivor space 1 utilization (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>EC</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current eden space capacity (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>EU</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Eden space utilization (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>OC</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current old space capacity (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>OU</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Old space utilization (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>PC</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current permanent space capacity (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>PU</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Permanent space utilization (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>YGC</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of young generation GC Events.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>YGCT</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Young generation garbage collection time.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>FGC</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of full GC events.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>FGCT</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Full garbage collection time.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>GCT</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Total garbage collection time.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Если не получается запустить команду или выдает ошибку: <em>Не удалось подключиться к &lt;pid&gt;</em>, тогда следует запустить команду от имени <code>root</code> пользователя.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_jvisualvm">JVisualVM</h5>
<div class="paragraph">
<p>Можно открыть <strong>GUI Tool</strong> через <strong>terminal</strong> с помощью команды <code>jvisualvm</code>. Этот инструмент, использовался в начале. Рекомендую использовать <strong>JVisualVM</strong> для мониторинга/настройки <strong>GC</strong> перед релизом каких-либо функций в <strong>testing</strong>/<strong>staging</strong>/<strong>production</strong> <strong>environment</strong>. Необходимо проверять, есть ли проблемы с памятью, чтобы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>гарантировать, что приложение потребляет мало памяти</p>
</li>
<li>
<p>гарантировать, что приложение работает очень быстро и не имеет проблем с <strong>memory-leak</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Важно, что приложение может использовать <strong>native memory</strong> (<strong>Metaspace</strong>, <strong>Direct Memory</strong>), которая не управляется <strong>GC</strong>. В этом случае необходимо выделить/освободить память вручную. Когда используются сторонние библиотеки, необходимо внимательно проверять их перед использованием.</p>
</div>
<div class="paragraph">
<p>Иногда, используя сторонние библиотеки, можно ожидать что они будут использовать <strong>HEAP</strong> и создавать в нем объекты, но на самом деле, они могут использовать <strong>native memory</strong> (<code>ByteBuffer</code>). Когда приложение будет тестироваться, то все будет работать нормально, только тестирование производительности (например с помощью <strong>Jmeter</strong>) выявит проблему с недостатком памяти.</p>
</div>
</div>
<div class="sect4">
<h5 id="_java_non_standard_options">Java Non-Standard Options</h5>
<div class="paragraph">
<p>Для повышения производительности приложения можно проверить и установить нестандартные параметры для <strong>JVM</strong>. Их можно просмотреть через командную строку с помощью команды:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="shell script">java -X</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>    -Xbatch           disable background compilation
    -Xbootclasspath/a:&lt;directories and zip/jar files separated by :&gt;
                      append to end of bootstrap class path
    -Xcheck:jni       perform additional checks for JNI functions
    -Xcomp            forces compilation of methods on first invocation
    -Xdebug           provided for backward compatibility
    -Xdiag            show additional diagnostic messages
    -Xfuture          enable strictest checks, anticipating future default
    -Xint             interpreted mode execution only
    -Xinternalversion
                      displays more detailed JVM version information than the
                      -version option
    -Xloggc:&lt;file&gt;    log GC status to a file with time stamps
    -Xmixed           mixed mode execution (default)
    -Xmn&lt;size&gt;        sets the initial and maximum size (in bytes) of the heap
                      for the young generation (nursery)
    -Xms&lt;size&gt;        set initial Java heap size
    -Xmx&lt;size&gt;        set maximum Java heap size
    -Xnoclassgc       disable class garbage collection
    -Xrs              reduce use of OS signals by Java/VM (see documentation)
    -Xshare:auto      use shared class data if possible (default)
    -Xshare:off       do not attempt to use shared class data
    -Xshare:on        require using shared class data, otherwise fail.
    -XshowSettings    show all settings and continue
    -XshowSettings:all
                      show all settings and continue
    -XshowSettings:locale
                      show all locale related settings and continue
    -XshowSettings:properties
                      show all property settings and continue
    -XshowSettings:vm
                      show all vm related settings and continue
    -XshowSettings:system
                      (Linux Only) show host system or container
                      configuration and continue
    -Xss&lt;size&gt;        set java thread stack size
    -Xverify          sets the mode of the bytecode verifier
    --add-reads &lt;module&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*
                      updates &lt;module&gt; to read &lt;target-module&gt;, regardless
                      of module declaration.
                      &lt;target-module&gt; can be ALL-UNNAMED to read all unnamed
                      modules.
    --add-exports &lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*
                      updates &lt;module&gt; to export &lt;package&gt; to &lt;target-module&gt;,
                      regardless of module declaration.
                      &lt;target-module&gt; can be ALL-UNNAMED to export to all
                      unnamed modules.
    --add-opens &lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*
                      updates &lt;module&gt; to open &lt;package&gt; to
                      &lt;target-module&gt;, regardless of module declaration.
    --illegal-access=&lt;value&gt;
                      permit or deny access to members of types in named modules
                      by code in unnamed modules.
                      &lt;value&gt; is one of "deny", "permit", "warn", or "debug"
                      This option will be removed in a future release.
    --limit-modules &lt;module name&gt;[,&lt;module name&gt;...]
                      limit the universe of observable modules
    --patch-module &lt;module&gt;=&lt;file&gt;(:&lt;file&gt;)*
                      override or augment a module with classes and resources
                      in JAR files or directories.
    --disable-@files  disable further argument file expansion
    --source &lt;version&gt;
                      set the version of the source in source-file mode.

These extra options are subject to change without notice.</pre>
</div>
</div>
<div class="paragraph">
<p>В некоторых вариантах часто используются:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-Xms &lt;size&gt;[unit]</code> (<code>g</code> для <strong>GB</strong>, <code>m</code> для <strong>MB</strong> и <code>k</code> для <strong>KB</strong>): для установки начального размера кучи при запуске JVM. По умолчанию: начальный размер кучи 1/64 физической памяти до 1 <strong>GB</strong>.</p>
</li>
<li>
<p><code>-Xmx &lt;size&gt;[unit]</code> (<code>g</code> для <strong>GB</strong>, <code>m</code> для <strong>MB</strong> и <code>k</code> для <strong>KB</strong>): для установки максимального размера кучи. По умолчанию: максимальный размер кучи составляет 1/4 физической памяти до 1 <strong>GB</strong>.</p>
</li>
<li>
<p><code>-Xss &lt;size&gt;[unit]</code> (<code>g</code> для <strong>GB</strong>, <code>m</code> для <strong>MB</strong> и <code>k</code> для <strong>KB</strong>): установить размер стека потока Java. Значение по умолчанию зависит от ОС. Это можно проверить через командную строку:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="bash">java -XX: + PrintFlagsFinal -version | grep ThreadStackSize</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>     intx CompilerThreadStackSize                  = 1024                                   {pd product} {default}
     intx ThreadStackSize                          = 1024                                   {pd product} {default}
     intx VMThreadStackSize                        = 1024                                   {pd product} {default}
openjdk version "11.0.7" 2020-04-14
OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.7+10)
OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.7+10, mixed mode)</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_советы_для_повышения_производительности_при_разработке_веб_приложения">5.14.6. Советы для повышения производительности при разработке веб-приложения</h4>
<div class="ulist">
<ul>
<li>
<p>Следует ограничить, создание новых объектов и как можно скорее освободить память.</p>
</li>
<li>
<p>Использовать <strong>JVisualVM</strong> для мониторинга приложения перед релизом приложения на <strong>testing</strong>/<strong>staging</strong>/<strong>production</strong> <strong>environment</strong>.</p>
</li>
<li>
<p>Внимательно проверить сторонние библиотеки, перед использованием.</p>
</li>
<li>
<p>Изучить и применять лучшие практики борьбы с <strong>memory-leak</strong>: изменяемые статические поля и коллекции, локальные переменные потока, <strong>Circular and Complex Bi-Directional References</strong>, <code>ByteBuffer</code>, <code>BufferImage</code>, незакрытый поток, незакрытое соединение, &#8230;&#8203;</p>
</li>
<li>
<p>Внимательно проверять код.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_модульность_since_java_9">5.15. Модульность (@since Java 9)</h3>
<div class="paragraph">
<p>С выходом Java 9 появился новый уровень абстракции над пакетами, формально известный как <strong>Java Platform Module System</strong> (<strong>JPMS</strong>), или сокращенно <strong>Modules</strong>.</p>
</div>
<div class="sect3">
<h4 id="_что_такое_модуль">5.15.1. Что такое модуль?</h4>
<div class="paragraph">
<p>Прежде всего, нам нужно понять, что такое модуль, прежде чем его использовать.</p>
</div>
<div class="paragraph">
<p><strong>Модуль</strong> - это группа тесно связанных <strong>пакетов</strong> и <strong>ресурсов</strong> вместе с новым типом файла <strong>дескриптор модуля</strong> (<strong>module descriptor</strong>).</p>
</div>
<div class="paragraph">
<p>Другими словами, это абстракция <strong>пакет с Java-пакетами</strong>, которая позволяет сделать наш код более пригодным для повторного использования.</p>
</div>
<div class="sect4">
<h5 id="_пакеты_2">Пакеты</h5>
<div class="paragraph">
<p>Пакеты внутри модуля идентичны пакетам Java, которые Java поддерживает с момента создания.</p>
</div>
<div class="paragraph">
<p>Когда создается модуль (фактически: проект), то <strong>код внутри организуется по пакетам, в зависимости от предназначения классов и связей между ними</strong>.</p>
</div>
<div class="paragraph">
<p>Помимо организации нашего кода, пакеты используются для определения того, какой код является общедоступным за пределами модуля, т.е. определяется <strong>API</strong> для данного модуля.</p>
</div>
</div>
<div class="sect4">
<h5 id="_ресурсы">Ресурсы</h5>
<div class="paragraph">
<p><strong>Каждый модуль отвечает за свои ресурсы</strong>, такие как медиа или конфигурационные файлы.</p>
</div>
<div class="paragraph">
<p>Ранешь их помещали в корневой уровень проекта и вручную управляли тем, какие ресурсы и к каким частям приложения относились.</p>
</div>
<div class="paragraph">
<p>С помощью модулей можно поставлять необходимые ресурсы вместе с тем модулем, которому они необходимые. Это значительно упрощает управление проектами.</p>
</div>
</div>
<div class="sect4">
<h5 id="_дескриптор_модуля">Дескриптор модуля</h5>
<div class="paragraph">
<p>При создании модуля в него включается <strong>файл дескриптора</strong>(<strong>descriptor file</strong>), который определяет несколько аспектов нового модуля:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Name</strong> - название модуля</p>
</li>
<li>
<p><strong>Dependencies</strong>  - список модулей, от которых зависит этот модуль</p>
</li>
<li>
<p><strong>Public Packages</strong> - список всех пакетов, которые можно получить вне этого модуля</p>
</li>
<li>
<p><strong>Services Offered</strong> - предоставляет реализацию услуг (<strong>implementation of service</strong>), для использования другими модулями</p>
</li>
<li>
<p><strong>Services Consumed</strong> - использует реализацию услуг из другого модуля</p>
</li>
<li>
<p><strong>Reflection Permissions</strong> - позволяет другим классам использовать <strong>Reflection API</strong> для доступа к <code>private</code> членам данного модуля</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Правила именования модулей похожи на правила именования пакетов (точки разрешены, а тире нет). Обычно используют имена в стиле:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>проекта (<code>my.module</code>)</p>
</li>
<li>
<p><code>Reverse-DNS</code> (<code>com.rakovets.mymodule</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Необходимо помнить, что нужно перечислить все пакеты:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>которые будут общедоступными, потому что по умолчанию все пакеты являются <strong>module private</strong></p>
</li>
<li>
<p>для которых будет доступна <strong>Reflection API</strong>, по тому что по умолчанию нельзя использовать рефлексию для классов, которые импортируются из другого модуля</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_типы_модулей">Типы модулей</h5>
<div class="paragraph">
<p>В новой модульной системе есть четыре типа модулей:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>System Modules</strong>  - это модули Java SE и JDK, которые можно увидеть с помощью команды <code>java --list-modules</code></p>
</li>
<li>
<p><strong>Application Modules</strong> - эти модули, которые необходимо использовать в текущем модуле. Они определены в скомпилированном  файле <code>module-info.class</code>, включенном в собранный JAR-file.</p>
</li>
<li>
<p><strong>Automatic Modules</strong> - это модули, которые включены в текущий неофициально, т.е. добавлением существующих JAR-файлов в путь к модулю. Название модуля будет производным от имени JAR-file. Эти модули будут иметь полный доступ для чтения ко всем аналогичным модулям</p>
</li>
<li>
<p><strong>Unnamed Module</strong>   - это универсальный модуль для обеспечения обратной совместимости с ранее написанным кодом Java. Он содержит классы или JAR-файлы загруженные в путь к классу, но не в путь к модулю</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_распространение_модуля">Распространение модуля</h5>
<div class="paragraph">
<p>Модули, как и любой другой Java-проект, можно распространять в виде:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JAR-файла</p>
</li>
<li>
<p>«скомпонованного» скомпилированного проекта</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Можно создавать многомодульные проекты, которые состоят из «основного приложения» и нескольких библиотечных модулей, но необходимо быть осторожны, потому что в JAR/project может быть только один модуль. Поэтому при настройке сборки (<strong>build</strong>), необходимо убедиться, что каждый модуль проекта упакован в отдельный JAR-файл.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_модули_по_умолчанию">5.15.2. Модули по умолчанию</h4>
<div class="paragraph">
<p>Когда мы устанавливаем Java 9, мы видим, что JDK теперь имеет новую структуру.</p>
</div>
<div class="paragraph">
<p>Они взяли все оригинальные пакеты и перенесли их в новую систему модулей.</p>
</div>
<div class="paragraph">
<p>Мы можем увидеть, что это за модули, набрав в командной строке:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="sh">java --list-modules</code></pre>
</div>
</div>
<div class="paragraph">
<p>Эти модули разделены на четыре основные группы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java</code> - содержит модули являются классами реализации для основной спецификации языка SE</p>
</li>
<li>
<p><code>javafx</code> - содержит библиотеки пользовательского интерфейса FX</p>
</li>
<li>
<p><code>jdk</code> - содержит все, что необходимо JDK</p>
</li>
<li>
<p><code>oracle</code> - содержит проприетарный функционал от Oracle</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_объявления_модуля">5.15.3. Объявления модуля</h4>
<div class="paragraph">
<p>Чтобы создать модуль, нам нужно поместить специальный файл (<strong>дескриптор модуля</strong>/<strong>module descriptor</strong>) в корень наших пакетов с именем <code>module-info.java</code>. Он содержит всю информацию необходимую для построения и использования данного модуля.</p>
</div>
<div class="paragraph">
<p>Создание модуля с объявлением, тело которого либо пусто, либо содержит директивы модуля выглядит следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">module myModuleName {
    // all directives are optional
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Объявление модуля начинается с ключевого слова <code>module</code>, далее указывается имя модуля. Этого достаточно для работы данного модуля, но обычно необходимо использовать другие модули и для этого существую <strong>директивы</strong>(<strong>directives</strong>) модуля.</p>
</div>
<div class="sect4">
<h5 id="_директива_requires">Директива <code>requires</code></h5>
<div class="paragraph">
<p>Директива модуля <code>requires</code> позволяет объявлять зависимости модуля:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">module my.module {
    requires module.name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь <code>my.module</code> имеет доступ во время кампиляции (<strong>Compile-time</strong>) и выполнение (<strong>Runtime</strong>) к зависимому модулю <code>module.name</code>. Все <code>public</code> типы из зависимого модуля, доступны в текущем модуле, благодаря использованию директивы <code>requires</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_директива_requires_static">Директива <code>requires static</code></h5>
<div class="paragraph">
<p>Иногда созданный модуль ссылается на другой модуль, но пользователи нашей библиотеки не хотят его использовать.</p>
</div>
<div class="paragraph">
<p>Например, написана служебная функция, которая красиво печатает внутреннее состояние наших объектов, когда есть зависимость от какого-то модуля логирования. Но не каждый потребитель нашей библиотеки захочет эту функциональность, и они не хотят включать дополнительную библиотеку логирорования.</p>
</div>
<div class="paragraph">
<p>В этих случаях можно использовать необязательную зависимость. Используя директиву <code>require static</code>, создается зависимость только во время компиляции:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">module my.module {
    requires static module.name;
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_директива_requires_transitive">Директива <code>requires transitive</code></h5>
<div class="paragraph">
<p>В разработке часто используют сторонние библиотеки, чтобы сделать разработку проще. Но тогда нужно убедиться, что любой модуль, который будет использовать текущий модуль, также внесет эти дополнительные «транзитивные» зависимости, иначе модуль не будет работать.</p>
</div>
<div class="paragraph">
<p>Для этого можно использовать директиву <code>requires transitive</code>, чтобы заставить любых последующих потребителей использовать требуемые для текущего модуля зависимости:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">module my.module {
    requires transitive module.name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь, когда кому-то необходим модуль <code>my.module</code>, то не требуется добавлять и <code>module.name</code> в зависимости для того, чтобы все работало корректно.</p>
</div>
</div>
<div class="sect4">
<h5 id="_директива_exports">Директива <code>exports</code></h5>
<div class="paragraph">
<p>По умолчанию, модуль не предоставляет API другим модулям. Эта <strong>сильная инкапсуляция</strong>(<strong>strong encapsulation</strong>) являлась одним из ключевых факторов для создания модульной системы и это делает код значительно более безопасным, но теперь нужно явно открывать API для потребителей.</p>
</div>
<div class="paragraph">
<p>Что бы открыть API из конкретного пакета используется директива <code>exports</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">module my.module {
    exports com.my.package.name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь у потребителей <code>my.module</code>, будет доступ к <code>public</code> типам из пакета <code>com.my.package.name</code>, но не из любого другом.</p>
</div>
</div>
<div class="sect4">
<h5 id="_директива_export_to">Директива <code>export &#8230;&#8203; to</code></h5>
<div class="paragraph">
<p>С помощью директивы <code>export</code> можно открыть API для потребителя, но что, если нужно, чтобы не все имели доступ к нашему API?</p>
</div>
<div class="paragraph">
<p>Можно ограничить то, какие модули имеют доступ к API. Для этого используется директива <code>export &#8230;&#8203; to</code>.</p>
</div>
<div class="paragraph">
<p>Подобно директиве <code>export</code>, объявляется какой пакет экспортировать, но так же перечисляется, каким модулям разрешаем импортировать этот пакет:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">module my.module {
    export com.my.package.name to com.specific.package;
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_директива_uses">Директива <code>uses</code></h5>
<div class="paragraph">
<p><strong>Сервис</strong> обычно является реализацией определенного интерфейса или абстрактного класса, который может использоваться другими классами. Для обозначения сервисов, которые использует модуль, используется директива <code>uses</code>. Стоит обратить внимание, что в качестве имени класса мы используем интерфейс или абстрактный класс, который реализует <strong>service</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">module my.module {
    uses class.name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следует отметить, что существует разница между директивой <code>requires</code> и директивой <code>uses</code>.Когда в модуле содержится сервис, который необходимо использовать, но этот сервис реализует интерфейс или абстрактный класс одной из своих транзитивных зависимостей, тогда вместо использования директивы <code>requires</code> для всех транзитивных зависимостей, используется директива <code>uses</code> для добавления необходимого интерфейса или абстрактного класса к модулю.</p>
</div>
</div>
<div class="sect4">
<h5 id="_директива_provides_with">Директива <code>provides &#8230;&#8203; with</code></h5>
<div class="paragraph">
<p>Модуль может быть поставщиком сервиса, который могут использовать другие модули. Для данного случая применяют директиву <code>provides &#8230;&#8203; with</code></p>
</div>
<div class="paragraph">
<p>Директива содержит ключевое слово <code>provides</code>, после чего указывается имя интерфейса или абстрактного класса. Далее следует <code>with</code>, после которого указывается имя класса реализации для интерфейса, либо наследника для абстрактного класса.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">module my.module {
    provides MyInterface with MyInterfaceImpl;
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_директива_open">Директива <code>open</code></h5>
<div class="paragraph">
<p>До Java 9 было возможно использовать <strong>Reflection API</strong> по отношению к любым классам, полям и методам, даже когда они имели модификатор доступа <code>private</code>, т.е. фактически реальной инкапсуляции небыло.</p>
</div>
<div class="paragraph">
<p>Поскольку Java 9 обеспечивает строгую инкапсуляцию, то теперь необходимо явно указать разрешение другим модулям использовать <strong>Reflection API</strong> по отношению к содержимому данного модулю.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">open module my.module {
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_директива_opens">Директива <code>opens</code></h5>
<div class="paragraph">
<p>Если необходимо разрешить использовать <strong>Reflection API</strong>, но не для всего модуля, то используется директивa <code>opens</code>, которая предоставит эту возможность к определенному пакету.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">module my.module {
  opens com.my.package;
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_директива_opens_to">Директива <code>opens &#8230;&#8203; to</code></h5>
<div class="paragraph">
<p>Если необходима более сильная инкапсуляция, то можно выборочно открывать пакеты для указанных модулей. Для этого используют  директиву <code>opens &#8230;&#8203; to</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">module my.module {
    opens com.my.package to moduleOne, moduleTwo, etc.;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_параметры_командной_строки">5.15.4. Параметры командной строки</h4>
<div class="paragraph">
<p>В настоящее времени поддержка модулей Java 9 была добавлена ​​в <strong>Maven</strong> и <strong>Gradle</strong>, поэтому нет необходимости делать много ручной работы для сборки проектов. Однако полезно знать, как использовать систему модулей из командной строки. Для этого используют следующие параметры при работе в командной строке:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>module-path</code> - используется для указания пути к модулю. Список из одного или нескольких директорий, которые содержат необходимые модули</p>
</li>
<li>
<p><code>add-reads</code> - объявляет зависимость от модуля (аналогично директиве <code>requires</code>)</p>
</li>
<li>
<p><code>add-exports</code> - предоставляет доступ к API (аналогично директиве <code>exports</code>)</p>
</li>
<li>
<p><code>add-opens</code> - разрешает прмменение <strong>Reflection API</strong> (аналогично директиве <code>open</code>)</p>
</li>
<li>
<p><code>add-modules</code> - добавляет список модулей в набор модулей по умолчанию</p>
</li>
<li>
<p><code>list-modules</code> - выводит список всех модулей и их версий</p>
</li>
<li>
<p><code>patch-module</code> - добавляет или переопределяет классы в модулях</p>
</li>
<li>
<p><code>illegal-access=permit|warn|deny</code> - либо ослабляет сильную инкапсуляцию показывая одно глобальное предупреждение, либо показывает каждое предупреждение, либо выдает ошибку (по умолчанию <code>permit</code>)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_видимость">5.15.5. Видимость</h4>
<div class="paragraph">
<p>Многие библиотеки, что бы работать, зависят от возможности использования <strong>Reflection API</strong>, например: <strong>JUnit</strong> и <strong>Spring</strong>.</p>
</div>
<div class="paragraph">
<p>По умолчанию в Java 9 доступ предоставляется только к <code>public</code> классам, методам и полям в экспортируемых пакетах. Даже если использовать <strong>reflection</strong>, чтобы получить доступ к <code>private</code> членам с вызовом <code>setAccessible(true)</code>, то нельзя получить доступ к этим членам.</p>
</div>
<div class="paragraph">
<p>В таком случае можно использовать директивы <code>open</code>, <code>opens</code>, и <code>opens &#8230;&#8203; to</code> для предоставления доступа использовать <strong>reflection</strong> в <strong>Runtime</strong>. Однако не в <strong>compile-time</strong>.</p>
</div>
<div class="paragraph">
<p>Для этого у нас должен быть доступ к модулю. Когда же доступа к модулю нет (т.е. это сторонний модуль), тогда можно использовать параметр <code>-add-opens</code> в командной строке для предоставления доступа собственных модулей к инкапсулированному модулю в <strong>Runtime</strong>. Но необходимо помнить, что нужно иметь доступ к аргументам командной строки, которые используются для запуска модуля.</p>
</div>
</div>
<div class="sect3">
<h4 id="_создание_модуля_с_помощью_cli">5.15.6. Создание модуля с помощью CLI</h4>
<div class="sect4">
<h5 id="_создание_структуры_проекта">Создание структуры проекта</h5>
<div class="paragraph">
<p>Создадим несколько каталогов для организации файлов.</p>
</div>
<div class="paragraph">
<p>Создадим директорию с проектом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="sh">mkdir module-project
cd module-project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это <strong>root</strong> директория проекта, поэтому она будет содержать в дальнейшем файлы сборки <strong>Maven</strong> или <strong>Gradle</strong>, другие <strong>source</strong> и <strong>resource</strong> директории.</p>
</div>
<div class="paragraph">
<p>Мы также поместили каталог для хранения всех модулей нашего проекта.</p>
</div>
<div class="paragraph">
<p>Далее создадим каталог модуля:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="sh">mkdir simple-modules</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вот как будет выглядеть структура проекта:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">module-project
|- // src if we use the default package
|- // build files also go at this level
+- simple-modules
  +- hello.modules
    +- com
      +- rakovets
        +- modules
          +- hello
  +- main.app
    +- com
      +- rakovets
        +- modules
          +- main</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_первый_модуль">Первый модуль</h5>
<div class="paragraph">
<p>Когда есть базовая структура, можно добавить первый модуль.</p>
</div>
<div class="paragraph">
<p>В директории <code>simple-modules</code> создадим новую директорию с именем <code>hello.modules</code> .</p>
</div>
<div class="paragraph">
<p>Ее можно назвать как угодно, но необходимо следовать правилам именования пакетов (т.е. точки для разделения пакетов и т.д.). Можно использовать имя основного пакета в качестве имени модуля, если необходимо, но обычно придерживаются того же имени, которое необходимо использовать при создании JAR-файла этого модуля.</p>
</div>
<div class="paragraph">
<p>В новом модуле можно создавать нужные пакеты. В текущем случае создим следующую структуру пакета:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">com.rakovets.modules.hello</code></pre>
</div>
</div>
<div class="paragraph">
<p>Затем в этом пакете создадим новый класс с именем <code>HelloModules.java</code>. Этот клас будет содержать очень простой код:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">package com.rakovets.modules.hello;

public class HelloModules {
    public static void doSomething() {
        System.out.println("Hello, Modules!");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Затем в корневой директори <code>hello.modules</code> добавим дескриптор модуля <code>module-info.java</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">module hello.modules {
    exports com.rakovets.modules.hello;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для простоты только экспортируем все открытые члены пакета <code>com.rakovets.modules.hello</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_второй_модуль">Второй модуль</h5>
<div class="paragraph">
<p>Первый самостоятельно ничего не делает. Создадим второй модуль, который будет использовать функционал первого.</p>
</div>
<div class="paragraph">
<p>В директории <code>simple-modules</code> создадим еще одну директорию для модуля с именем <code>main.app</code> и добавим дескриптор модуля:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">module main.app {
    requires hello.modules;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Второй модуль не будет предоставлять API, он только будет использовать первый модуль.</p>
</div>
<div class="paragraph">
<p>Для этого создадим новую структуру пакетов <code>com.rakovets.modules.main</code>.</p>
</div>
<div class="paragraph">
<p>Затем создадим новый файл класса с именем <code>MainApp.java</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">package com.rakovets.modules.main;

import com.rakovets.modules.hello.HelloModules;

public class MainApp {
    public static void main(String[] args) {
        HelloModules.doSomething();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это продемонстрирует принцип создания модулей.</p>
</div>
</div>
<div class="sect4">
<h5 id="_сборка_модулей">Сборка модулей</h5>
<div class="paragraph">
<p>Что бы сделать <code>build</code> проекта, можно создать bash-скрипт и поместить его в корень проекта.</p>
</div>
<div class="paragraph">
<p>Создадим файл с именем <code>compile-simple-modules.sh</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="sh">#!/usr/bin/env bash
javac -d outDir --module-source-path simple-modules $(find simple-modules -name "*.java")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Команда состоит из двух команд:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>javac</code> - компилирует все java-файлы, которые были найдены с помощью команды <code>find</code></p>
</li>
<li>
<p><code>find</code> - выводит список всех java-файлов в директории <code>simple-modules</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Единственное отличие от более старых версий Java, это необходимость предоставить параметр <code>module-source-path</code>, чтобы сообщить компилятору о том, что он делает <code>build</code> модулей.</p>
</div>
<div class="paragraph">
<p>Как только команда будет запущена, появится директория <code>outDir</code> с двумя скомпилированными модулями внутри.</p>
</div>
</div>
<div class="sect4">
<h5 id="_запуск_2">Запуск</h5>
<div class="paragraph">
<p>Что бы проверить работоспособность модулей необходимо запусти проект.</p>
</div>
<div class="paragraph">
<p>Создадим bash-скрипт в корне проекта `run-simple-module-app.sh:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="sh">#!/usr/bin/env bash
java --module-path outDir -m main.app/com.rakovets.modules.main.MainApp</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы запустить модуль, необходимо указать путь к модулю и основному классу. Запустим и если все верно, то увидим:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="sh">./run-simple-module-app.sh
Hello, Modules!</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_добавление_сервиса">Добавление сервиса</h5>
<div class="paragraph">
<p>Усложним проект, добавив в него <code>service</code>. Для этого используем директивы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>provides…with</code></p>
</li>
<li>
<p><code>uses</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Определим новый файл в модуле <code>hello.modules</code> с именем <code>HelloInterface.java</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public interface HelloInterface {
    void sayHello();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Реализуем интерфейс в существующем классе <code>HelloModules.java</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class HelloModules implements HelloInterface {
    public static void doSomething() {
        System.out.println("Hello, Modules!");
    }

    public void sayHello() {
        System.out.println("Hello!");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Необходимый <code>service</code> создан. Теперь необходимо указать что модуль предоставляет этот <code>service</code>. Для этого добавим в <code>module-info.java</code> следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">provides com.rakovets.modules.hello.HelloInterface with com.rakovets.modules.hello.HelloModules;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Т.е. объявили интерфейс и класс, который его реализует.</p>
</div>
<div class="paragraph">
<p>В модуле <code>main.app</code>, для использования этого <code>service</code> нужно добавить следующее в <code>module-info.java</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">uses com.rakovets.modules.hello.HelloInterface;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперо в <code>main</code> методе можно использовать этот <code>service</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">HelloModules module = new HelloModules();
module.sayHello();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Компилируем и запускаем:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="sh">./run-simple-module-app.sh
Hello, Modules!
Hello!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так же можно поместить реализацию в приватный пакет, а интерфейс в публичный пакет. Это сделает наш код более безопасным при минимальных усилиях.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_добавление_модулей_в_unnamed_module">5.15.7. Добавление модулей в <strong>Unnamed Module</strong></h4>
<div class="paragraph">
<p>Концепция <strong>Unnamed Module</strong> похожа на пакет по умолчанию, поэтому его не следует считать реальным модулем, но можно рассматриваться как модуль по умолчанию.</p>
</div>
<div class="paragraph">
<p>Если класс не является членом других типов модулей, то он будет автоматически рассматриваться как часть <strong>Unnamed Module</strong>.</p>
</div>
<div class="paragraph">
<p>Иногда, чтобы обеспечить наличие определенных модулей платформы, библиотеки или поставщика услуг в графе модулей, нужно добавить модули в набор по умолчанию. Например, когда пытаемся работать с программами на Java 8 используя компилятор Java 9, тогда может потребоваться добавить модули.</p>
</div>
<div class="paragraph">
<p>Возможность добавления именованных модулей в набор корневых модулей по умолчанию выглядит  <code>-add-modules &lt;module&gt;, &#8230;&#8203;, &lt;module&gt;</code>,  где <code>&lt;module&gt;</code> - это имя модуля.</p>
</div>
<div class="paragraph">
<p>Например, чтобы обеспечить доступ всех модулей к модулю <code>java.xml.bind</code>, синтаксис должен быть следующим:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="sh">--add-modules java.xml.bind</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы использовать это с помощью <strong>Maven</strong>, необходимо добавит это в конфигурацию для <code>maven-compiler-plugin</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.8.0&lt;/version&gt;
    &lt;configuration&gt;
        &lt;source&gt;9&lt;/source&gt;
        &lt;target&gt;9&lt;/target&gt;
        &lt;compilerArgs&gt;
            &lt;arg&gt;--add-modules&lt;/arg&gt;
            &lt;arg&gt;java.xml.bind&lt;/arg&gt;
        &lt;/compilerArgs&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_обработка_исключений">6. Обработка исключений</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Нередко в процессе выполнения программы могут возникать ошибки, при том необязательно по вине разработчика. Некоторые из них трудно предусмотреть или предвидеть, а иногда и вовсе невозможно. Так, например, может неожиданно оборваться сетевое подключение при передаче файла. Подобные ситуации называются <strong>исключениями</strong>.
<strong>Исключение</strong> - объект, который описывает исключительную (ошибочную) ситуацию, возникающую в программе.</p>
</div>
<div class="sect2">
<h3 id="_обработка_исключений_2">6.1. Обработка исключений</h3>
<div class="paragraph">
<p>В языке <strong>Java</strong> предусмотрены специальные средства для обработки подобных ситуаций. Одним из таких средств является конструкция <code>try&#8230;&#8203;catch&#8230;&#8203;finally</code>. При возникновении исключения в блоке <code>try</code> управление переходит в блок <code>catch</code>, который может обработать данное исключение. Если такого блока не найдено, то пользователю отображается сообщение о необработанном исключении, а дальнейшее выполнение программы останавливается. И чтобы подобной остановки не произошло, и надо использовать блок <code>try&#8230;&#8203;catch</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int[] numbers = new int[3];
numbers[4] = 45;
System.out.println(numbers[4]);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так как у нас массив <code>numbers</code> может содержать только <code>3</code> элемента, то при выполнении инструкции <code>numbers[4] = 45</code> консоль отобразит исключение, и выполнение программы будет завершено. Теперь попробуем обработать это исключение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">try {
    int[] numbers = new int[3];
    numbers[4] = 45;
    System.out.println(numbers[4]);
} catch (Exception ex) {
    ex.printStackTrace();
}
System.out.println("Программа завершена");</code></pre>
</div>
</div>
<div class="paragraph">
<p>При использовании блока <code>try&#8230;&#8203;catch</code> вначале выполняются все инструкции между операторами <code>try</code> и <code>catch</code>. Если в блоке <code>try</code> вдруг возникает исключение, то обычный порядок выполнения останавливается и переходит к инструкции <code>сatch</code>. Поэтому когда выполнение программы дойдет до строки <code>numbers[4] = 45;</code>, программа остановится и перейдет к блоку <code>catch</code>.</p>
</div>
<div class="paragraph">
<p>Выражение <code>catch</code> имеет следующий синтаксис: <code>catch (тип_исключения имя_переменной)</code>. В данном случае объявляется переменная <code>ex</code>, которая имеет тип <code>Exception</code>. Но если возникшее исключение не является исключением типа, указанного в инструкции <code>сatch</code>, то оно не обрабатывается, а программа просто зависает или выбрасывает сообщение об ошибке.</p>
</div>
<div class="paragraph">
<p>Но так как тип <code>Exception</code> является базовым классом для всех исключений, то выражение <code>catch (Exception ex)</code> будет обрабатывать практически все исключения. Обработка же исключения в данном случае сводится к выводу на консоль стека трассировки ошибки с помощью метода <code>printStackTrace()</code>, определенного в классе <code>Exception</code>.</p>
</div>
<div class="paragraph">
<p>После завершения выполнения блока <code>catch</code> программа продолжает свою работу, выполняя все остальные инструкции после блока <code>catch</code>.</p>
</div>
<div class="paragraph">
<p>Конструкция <code>try&#8230;&#8203;catch</code> также может иметь блок <code>finally</code>. Однако этот блок необязательный, и его можно при обработке исключений опускать. Блок <code>finally</code> выполняется в любом случае, возникло ли исключение в блоке <code>try</code> или нет:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">try {
    int[] numbers = new int[3];
    numbers[4] = 45;
    System.out.println(numbers[4]);
} catch (Exception ex) {
    ex.printStackTrace();
} finally {
    System.out.println("Блок finally");
}
System.out.println("Программа завершена");</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_обработка_нескольких_исключений">6.2. Обработка нескольких исключений</h3>
<div class="paragraph">
<p>В Java имеется множество различных типов исключений, и мы можем разграничить их обработку, включив дополнительные блоки <code>catch</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int[] numbers = new int[3];
try {
    numbers[6] = 45;
    numbers[6] = Integer.parseInt("gfd");
} catch (ArrayIndexOutOfBoundsException ex) {
    System.out.println("Выход за пределы массива");
} catch (NumberFormatException ex) {
    System.out.println("Ошибка преобразования из строки в число");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если у нас возникает исключение определенного типа, то оно переходит к соответствующему блоку <code>catch</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_оператор_throw">6.3. Оператор <code>throw</code></h3>
<div class="paragraph">
<p>Чтобы сообщить о выполнении исключительных ситуаций в программе, можно использовать оператор <code>throw</code>. То есть с помощью этого оператора мы сами можем создать исключение и вызвать его в процессе выполнения. Например, в нашей программе происходит ввод числа, и мы хотим, чтобы, если число больше <code>30</code>, то возникало исключение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">package firstapp;

import java.util.Scanner;
public class FirstApp {
    public static void main(String[] args) {
        try {
            Scanner in = new Scanner(System.in);
            int x = in.nextInt();
            if (x &gt;= 30) {
                throw new Exception("Число х должно быть меньше 30");
            }
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        System.out.println("Программа завершена");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь для создания объекта исключения используется конструктор класса <code>Exception</code>, в который передается сообщение об исключении. И если число <code>х</code> окажется больше <code>29</code>, то будет выброшено исключение и управление перейдет к блоку <code>catch</code>.</p>
</div>
<div class="paragraph">
<p>В блоке <code>catch</code> мы можем получить сообщение об исключении с помощью метода <code>getMessage()</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_оператор_throws">6.4. Оператор <code>throws</code></h3>
<div class="paragraph">
<p>Иногда метод, в котором может генерироваться исключение, сам не обрабатывает это исключение. В этом случае в объявлении метода используется оператор <code>throws</code>, который надо обработать при вызове этого метода.</p>
</div>
<div class="paragraph">
<p>Например, у нас имеется метод вычисления факториала, и нам надо обработать ситуацию, если в метод передается число меньше <code>1</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static int getFactorial(int num) throws Exception {
    if (num &lt; 1) {
        throw new Exception("The number is less than 1");
    }
    int result = 1;
    for (int i = 1; i &lt;= num; i++) {
        result *= i;
    }
    return result;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>С помощью оператора <code>throw</code> по условию выбрасывается исключение. В то же время метод сам это исключение не обрабатывает с помощью <code>try&#8230;&#8203;catch</code>, поэтому в определении метода используется выражение <code>throws Exception</code>.</p>
</div>
<div class="paragraph">
<p>Теперь при вызове этого метода нам обязательно надо обработать выбрасываемое исключение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static void main(String[] args) {
    try {
        int result = getFactorial(-6);
        System.out.println(result);
    } catch (Exception ex) {
        System.out.println(ex.getMessage());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Без обработки исключение у нас возникнет ошибка компиляции, и мы не сможем скомпилировать программу.</p>
</div>
<div class="paragraph">
<p>В качестве альтернативы мы могли бы и не использовать оператор <code>throws</code>, а обработать исключение прямо в методе:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static int getFactorial(int num) {
    int result = 1;
    try {
        if (num &lt; 1) {
            throw new Exception("The number is less than 1");
        }
        for (int i = 1; i &lt;= num; i++) {
            result *= i;
        }
    } catch (Exception ex) {
        System.out.println(ex.getMessage());
        result = num;
    }
    return result;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_классы_исключений">6.5. Классы исключений</h3>
<div class="paragraph">
<p>Базовым классом для всех исключений является класс <code>Throwable</code>. От него уже наследуются два класса: <code>Error</code> и <code>Exception</code>. Все остальные классы являются производными от этих двух классов.</p>
</div>
<div class="paragraph">
<p>Класс <code>Error</code> описывает внутренние ошибки в исполняющей среде <strong>Java</strong>. Программист имеет очень ограниченные возможности для обработки подобных ошибок.</p>
</div>
<div class="paragraph">
<p>Собственно исключения наследуются от класса <code>Exception</code>. Среди этих исключений следует выделить класс <code>RuntimeException</code>. <code>RuntimeException</code> является базовым классом для так называемой группы <strong>непроверяемых исключений</strong> (<code>unchecked exceptions</code>) - компилятор не проверяет факт обработки таких исключений и их можно не указывать вместе с оператором <code>throws</code> в объявлении метода. Такие исключения являются следствием ошибок разработчика, например, неверное преобразование типов или выход за пределы массива.</p>
</div>
<div class="paragraph">
<p>Некоторые из классов непроверяемых исключений:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ArithmeticException</code>: исключение, возникающее при делении на ноль</p>
</li>
<li>
<p><code>IndexOutOfBoundException</code>: индекс вне границ массива</p>
</li>
<li>
<p><code>IllegalArgumentException</code>: использование неверного аргумента при вызове метода</p>
</li>
<li>
<p><code>NullPointerException</code>: использование пустой ссылки</p>
</li>
<li>
<p><code>NumberFormatException</code>: ошибка преобразования строки в число</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Все остальные классы, образованные от класса <code>Exception</code>, называются <strong>проверяемыми исключениями</strong> (<code>checked exceptions</code>).</p>
</div>
<div class="paragraph">
<p>Некоторые из классов проверяемых исключений:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CloneNotSupportedException</code>: класс, для объекта которого вызывается клонирование, не реализует интерфейс <code>Clonable</code></p>
</li>
<li>
<p><code>InterruptedException</code>: поток прерван другим потоком</p>
</li>
<li>
<p><code>ClassNotFoundException</code>: невозможно найти класс</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Подобные исключения обрабатываются с помощью конструкции <code>try..catch</code>. Либо можно передать обработку методу, который будет вызывать данный метод, указав исключения после оператора <code>throws</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public Person clone() throws CloneNotSupportedException {
    Person p = (Person) super.clone();
    return p;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В итоге получается следующая иерархия исключений:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/assets/img/java/core/exceptions.png" alt="Exceptions"></span></p>
</div>
<div class="paragraph">
<p>Поскольку все классы исключений наследуются от класса <code>Exception</code>, то все они наследуют ряд его методов, которые позволяют получить информацию о характере исключения. Среди этих методов отметим наиболее важные:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getMessage()</code> возвращает сообщение об исключении</p>
</li>
<li>
<p><code>getStackTrace()</code> возвращает массив, содержащий трассировку стека исключения</p>
</li>
<li>
<p><code>printStackTrace()</code> отображает трассировку стека</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">try {
    int x = 6 / 0;
} catch (Exception ex) {
    ex.printStackTrace();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_создание_своих_классов_исключений">6.6. Создание своих классов исключений</h3>
<div class="paragraph">
<p>Хотя имеющиеся в стандартной библиотеке классов <strong>Java</strong> классы исключений описывают большинство исключительных ситуаций, которые могут возникнуть при выполнении программы, все таки иногда требуется создать свои собственные классы исключений со своей логикой.</p>
</div>
<div class="paragraph">
<p>Чтобы создать свой класс исключений, надо унаследовать его от класса <code>Exception</code>. Например, у нас есть класс, вычисляющий факториал, и нам надо выбрасывать специальное исключение, если число, передаваемое в метод, меньше <code>1</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Factorial {
    public static int getFactorial(int num) throws FactorialException {
        int result = 1;
        if (num &lt; 1) {
            throw new FactorialException("The number is less than 1", num);
        }
        for (int i = 1; i &lt;= num; i++) {
            result *= i;
        }
        return result;
    }
}

class FactorialException extends Exception {
    private int number;

    public int getNumber() {
        return number;
    }

    public FactorialException(String message, int num) {
        super(message);
        number = num;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь для определения ошибки, связанной с вычислением факториала, определен класс <code>FactorialException</code>, который наследуется от <code>Exception</code> и который содержит всю информацию о вычислении. В конструкторе <code>FactorialException</code> в конструктор базового класса <code>Exception</code> передается сообщение об ошибке: <code>super(message)</code>. Кроме того, отдельное поле предназначено для хранения числа, факториал которого вычисляется.</p>
</div>
<div class="paragraph">
<p>Для генерации исключения в методе вычисления факториала выбрасывается исключение с помощью оператора <code>throw</code>: <code>throw new FactorialException("Число не может быть меньше 1", num)</code>. Кроме того, так как это исключение не обрабатывается с помощью <code>try&#8230;&#8203;catch</code>, то мы передаем обработку вызывающему методу, используя оператор <code>throws: public static int getFactorial(int num) throws FactorialException</code></p>
</div>
<div class="paragraph">
<p>Теперь используем класс в методе <code>main</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static void main(String[] args) {
    try {
        int result = Factorial.getFactorial(6);
        System.out.println(result);
    } catch (FactorialException ex) {
        System.out.println(ex.getMessage());
        System.out.println(ex.getNumber());
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_generics_jsr_14">7. Generics (JSR-14)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_обобщения_generics">7.1. Обобщения (Generics)</h3>
<div class="paragraph">
<p><strong>Обобщения</strong> или <strong>generics</strong> (обобщенные типы и методы) позволяют нам уйти от жесткого определения используемых типов. Рассмотрим проблему, в которой они нам могут понадобиться.</p>
</div>
<div class="paragraph">
<p>Допустим, мы определяем класс для представления банковского счета. К примеру, он мог бы выглядеть следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Account {
    private int id;
    private int sum;

    Account(int id, int sum) {
        this.id = id;
        this.sum = sum;
    }

    public int getId() {
        return id;
    }

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Класс <code>Account</code> имеет два поля: <code>id</code> - уникальный идентификатор счета и <code>sum</code> - сумма на счете.</p>
</div>
<div class="paragraph">
<p>В данном случае идентификатор задан как целочисленное значение, например: 1, 2, 3, 4 и так далее. Однако также нередко для идентификатора используются и строковые значения (например <strong>UUID</strong>). И числовые, и строковые значения имеют свои плюсы и минусы. И на момент написания класса мы можем точно не знать, что лучше выбрать для хранения идентификатора - строки или числа. Либо, возможно, этот класс будет использоваться другими разработчиками, которые могут иметь свое мнение по данной проблеме. Например, в качестве типа <code>id</code> они захотят исподльзовать какой-то свой класс.</p>
</div>
<div class="paragraph">
<p>И на первый взгляд мы можем решить данную проблему следующим образом: задать <code>id</code> как поле типа <code>Object</code>, который является универсальным и базовым суперклассом для всех остальных типов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Account acc1 = new Account(2334, 5000); // id - число
        int acc1Id = (int) acc1.getId();
        System.out.println(acc1Id);

        Account acc2 = new Account("sid5523", 5000);    // id - строка
        System.out.println(acc2.getId());
    }
}

class Account {
    private Object id;
    private int sum;

    Account(Object id, int sum) {
        this.id = id;
        this.sum = sum;
    }

    public Object getId() {
        return id;
    }

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае все замечательно работает. Однако в данном случае мы салкиваемся с проблемой безопасности типов. Например, в следующем случае мы получим ошибку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Account acc1 = new Account("2345", 5000);
int acc1Id = (int) acc1.getId(); // java.lang.ClassCastException
System.out.println(acc1Id);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Проблема может показаться искуственной, так как в данном случае мы видим, что в конструктор передается строка, поэтому вряд ли будет пытаться преобразовать к типу <code>int</code>. Однако в процессе разработки мы можем не знать, какий именно тип представляет значение в <code>id</code>, и при попытке получить число в данном случае мы столкнемся с исключением <code>java.lang.ClassCastException</code>.</p>
</div>
<div class="paragraph">
<p>Писать для каждого отдельного типа свою версию класса <code>Account</code> тоже не является хорошим решением, так как в этом случае мы вынуждены повторяться.</p>
</div>
<div class="paragraph">
<p>Эти проблемы были призваны устранить <strong>обобщения</strong> или <strong>generics</strong>. Обобщения позволяют не указывать конкретный тип, который будет использоваться. Поэтому определим класс <code>Account</code> как обобщенный:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Account&lt;T&gt; {
    private T id;
    private int sum;

    Account(T id, int sum) {
        this.id = id;
        this.sum = sum;
    }

    public T getId() {
        return id;
    }

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>С помощью буквы <code>T</code> в определении класса <code>class Account&lt;T&gt;</code> мы указываем, что данный тип <code>T</code> будет использоваться этим классом. Параметр <code>T</code> в угловых скобках называется универсальным параметром, так как вместо него можно подставить любой тип. При этом пока мы не знаем, какой именно это будет тип: <code>String</code>, <code>Integer</code> или какой-то другой ссылочный тип. Причем буква <code>T</code> выбрана условна, это может и любая другая буква или набор символов.</p>
</div>
<div class="paragraph">
<p>После объявления класса мы можем применить универсальный параметр <code>T</code>: так далее в классе объявляется переменная этого типа, которой затем присваивается значение в конструкторе.</p>
</div>
<div class="paragraph">
<p>Метод <code>getId()</code> возвращает значение переменной <code>id</code>, но так как данная переменная представляет тип <code>T</code>, то данный метод также возвращает объект типа <code>T</code>: <code>public T getId()</code>.</p>
</div>
<div class="paragraph">
<p>Используем данный класс:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Account&lt;String&gt; acc1 = new Account&lt;String&gt;("2345", 5000);
        String acc1Id = acc1.getId();
        System.out.println(acc1Id);

        Account&lt;Integer&gt; acc2 = new Account&lt;Integer&gt;(2345, 5000);
        Integer acc2Id = acc2.getId();
        System.out.println(acc2Id);
    }
}

class Account&lt;T&gt; {
    private T id;
    private int sum;

    Account(T id, int sum) {
        this.id = id;
        this.sum = sum;
    }

    public T getId() {
        return id;
    }

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>При определении переменной даннного класса и создании объекта после имени класса в угловых скобках нужно указать, какой именно тип будет использоваться вместо универсального параметра. При этом надо учитывать, что они работают только с объектами, но не работают с примитивными типами. То есть мы можем написать <code>Account&lt;Integer&gt;</code>, но не можем использовать тип <code>int</code> или <code>double</code>, например, <code>Account&lt;int&gt;</code>. Вместо примитивных типов надо использовать классы-обертки: <code>Integer</code> вместо <code>int</code>, <code>Double</code> вместо <code>double</code> и т.д.</p>
</div>
<div class="paragraph">
<p>Например, первый объект будет использовать тип <code>String</code>, то есть вместо <code>T</code> будет подставляться <code>String</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Account&lt;String&gt; acc1 = new Account&lt;String&gt;("2345", 5000);</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом случае в качестве первого параметра в конструктор передается строка.</p>
</div>
<div class="paragraph">
<p>А второй объект использует тип <code>int (Integer)</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Account&lt;Integer&gt; acc2 = new Account&lt;Integer&gt;(2345, 5000);</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_обобщенные_интерфейсы">7.1.1. Обобщенные интерфейсы</h4>
<div class="paragraph">
<p>Интерфейсы, как и классы, также могут быть обобщенными. Создадим обобщенный интерфейс <code>Accountable</code> и используем его в программе:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Accountable&lt;String&gt; acc1 = new Account("1235rwr", 5000);
        Account acc2 = new Account("2373", 4300);
        System.out.println(acc1.getId());
        System.out.println(acc2.getId());
    }
}

interface Accountable&lt;T&gt; {
    T getId();

    int getSum();

    void setSum(int sum);
}

class Account implements Accountable&lt;String&gt; {
    private String id;
    private int sum;

    Account(String id, int sum) {
        this.id = id;
        this.sum = sum;
    }

    public String getId() {
        return id;
    }

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>При реализации подобного интерфейса есть две стратегии:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>когда при реализации для универсального параметра интерфейса задается конкретный тип (пример выше),тогда класс, реализующий интерфейс, жестко привязан к этому типу</p>
</li>
<li>
<p>определение обобщенного класса, который также использует тот же универсальный параметр (пример ниже)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Account&lt;String&gt; acc1 = new Account&lt;String&gt;("1235rwr", 5000);
        Account&lt;String&gt; acc2 = new Account&lt;String&gt;("2373", 4300);
        System.out.println(acc1.getId());
        System.out.println(acc2.getId());
    }
}

interface Accountable&lt;T&gt; {
    T getId();

    int getSum();

    void setSum(int sum);
}

class Account&lt;T&gt; implements Accountable&lt;T&gt; {
    private T id;
    private int sum;

    Account(T id, int sum) {
        this.id = id;
        this.sum = sum;
    }

    public T getId() {
        return id;
    }

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_обобщенные_методы">7.1.2. Обобщенные методы</h4>
<div class="paragraph">
<p>Кроме обобщенных типов можно также создавать обобщенные методы, которые точно также будут использовать универсальные параметры. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Printer printer = new Printer();
        String[] people = {"Tom", "Alice", "Sam", "Kate", "Bob", "Helen"};
        Integer[] numbers = {23, 4, 5, 2, 13, 456, 4};
        printer.&lt;String&gt;print(people);
        printer.&lt;Integer&gt;print(numbers);
    }
}

class Printer {
    public &lt;T&gt; void print(T[] items) {
        for (T item : items) {
            System.out.println(item);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Особенностью обобщенного метода является использование универсального параметра в объявлении метода после всех модификаторов и перед типом возвращаемого значения.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public &lt;T&gt; void print(T[] items)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Затем внутри метода все значения типа <code>T</code> будут представлять данный универсальный параметр.</p>
</div>
<div class="paragraph">
<p>При вызове подобного метода перед его именем в угловых скобках указывается, какой тип будет передаваться на место универсального параметра:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">printer.&lt;String&gt;print(people);
printer.&lt;Integer&gt;print(numbers);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_использование_нескольких_универсальных_параметров">7.1.3. Использование нескольких универсальных параметров</h4>
<div class="paragraph">
<p>Мы можем также задать сразу несколько универсальных параметров:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Account&lt;String, Double&gt; acc1 = new Account&lt;String, Double&gt;("354", 5000.87);
        String id = acc1.getId();
        Double sum = acc1.getSum();
        System.out.printf("Id: %s  Sum: %f \n", id, sum);
    }
}

class Account&lt;T, S&gt; {
    private T id;
    private S sum;

    Account(T id, S sum) {
        this.id = id;
        this.sum = sum;
    }

    public T getId() {
        return id;
    }

    public S getSum() {
        return sum;
    }

    public void setSum(S sum) {
        this.sum = sum;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае тип <code>String</code> будет передаваться на место параметра <code>T</code>, а тип <code>Double</code> - на место параметра <code>S</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_обобщенные_конструкторы">7.1.4. Обобщенные конструкторы</h4>
<div class="paragraph">
<p>Конструкторы как и методы также могут быть обобщенными. В этом случае перед конструктором также указываются в угловых скобках универсальные параметры:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Account acc1 = new Account("cid2373", 5000);
        Account acc2 = new Account(53757, 4000);
        System.out.println(acc1.getId());
        System.out.println(acc2.getId());
    }
}

class Account {
    private String id;
    private int sum;

    &lt;T&gt; Account(T id, int sum) {
        this.id = id.toString();
        this.sum = sum;
    }

    public String getId() {
        return id;
    }

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае конструктор принимает параметр <code>id</code>, который представляет тип <code>T</code>. В конструкторе его значение превращается в строку и сохраняется в локальную переменную.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ограничения_обобщений">7.2. Ограничения обобщений</h3>
<div class="paragraph">
<p>Когда мы указываем универсальный параметр у обобщений, то по умолчанию он может представлять любой тип. Однако иногда необходимо, чтобы параметр соответствовал только некоторому ограниченному набору типов. В этом случае применяются ограничения, которые позволяют указать базовый класс, которому должен соответствовать параметр.</p>
</div>
<div class="paragraph">
<p>Для установки ограничения после универсального параметра ставится слово <code>extends</code>, после которого указывается базовый класс ограничения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Account {
}

class Transaction&lt;T extends Account&gt; {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>К примеру, в данном случае для параметра <code>T</code> в <code>Transaction</code> ограничением является класс <code>Account</code>. То есть на место параметра <code>T</code> мы можем передать либо класс <code>Account</code>, либо один из его классов-наследников.</p>
</div>
<div class="paragraph">
<p>Например, рассмотрим следующюю программу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Account acc1 = new Account("1876", 4500);
        Account acc2 = new Account("3476", 1500);

        Transaction&lt;Account&gt; tran1 = new Transaction&lt;Account&gt;(acc1, acc2, 4000);
        tran1.execute();
        tran1 = new Transaction&lt;Account&gt;(acc1, acc2, 4000);
        tran1.execute();
    }
}

class Transaction&lt;T extends Account&gt; {
    private T from; // с какого счета перевод
    private T to; // на какой счет перевод
    private int sum; // сумма перевода

    Transaction(T from, T to, int sum) {
        this.from = from;
        this.to = to;
        this.sum = sum;
    }

    public void execute() {
        if (from.getSum() &gt; sum) {
            from.setSum(from.getSum() - sum);
            to.setSum(to.getSum() + sum);
            System.out.printf("Account %s: %d \nAccount %s: %d \n", from.getId(), from.getSum(), to.getId(), to.getSum());
        } else {
            System.out.printf("Operation is invalid");
        }
    }
}

class Account {
    private String id;
    private int sum;

    Account(String id, int sum) {
        this.id = id;
        this.sum = sum;
    }

    public String getId() {
        return id;
    }

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае класс <code>Transaction</code>, который представляет операцию перевода средств между двумя счетами, типизирован параметром <code>T</code>, у котрого в качестве ограничения установлен класс <code>Account</code>. При создании объекта <code>Transaction</code> в его конструктор передаются два объекта <code>Account</code> - два счета, между которыми надо осуществить перевод, и сумма перевода.</p>
</div>
<div class="paragraph">
<p>При этом важно понимать, что поскольку мы установили подобное ограничение, то компилятор будет распознавать объекты типа <code>T</code> как объекты типа <code>Account</code>. И в этом случае мы можем вызывать у объектов типа <code>T</code> методы класса <code>Account</code>. И мы бы не смогли бы это сделать, если бы мы не задали подобного ограничения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Transaction&lt;T&gt; {
    // остальное содержимое
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом случае была бы ошибка.</p>
</div>
<div class="sect3">
<h4 id="_обобщенные_типы_в_качестве_ограничений">7.2.1. Обобщенные типы в качестве ограничений</h4>
<div class="paragraph">
<p>В качестве ограничений могут выступать и другие обобщения, которые сами могут иметь ограничения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Account&lt;String&gt; acc1 = new Account&lt;String&gt;("1876", 4500);
        Account&lt;String&gt; acc2 = new Account&lt;String&gt;("3476", 1500);

        Transaction&lt;Account&lt;String&gt;&gt; tran1 = new Transaction&lt;Account&lt;String&gt;&gt;(acc1, acc2, 4000);
        tran1.execute();
        tran1 = new Transaction&lt;Account&lt;String&gt;&gt;(acc1, acc2, 4000);
        tran1.execute();
    }
}

class Transaction&lt;T extends Account&lt;String&gt;&gt; {
    private T from; // с какого счета перевод
    private T to; // на какой счет перевод
    private int sum; // сумма перевода

    Transaction(T from, T to, int sum) {
        this.from = from;
        this.to = to;
        this.sum = sum;
    }

    public void execute() {
        if (from.getSum() &gt; sum) {
            from.setSum(from.getSum() - sum);
            to.setSum(to.getSum() + sum);
            System.out.printf("Account %s: %d \nAccount %s: %d \n", from.getId(), from.getSum(), to.getId(), to.getSum());
        } else {
            System.out.printf("Operation is invalid");
        }
    }
}

class Account&lt;T&gt; {
    private T id;
    private int sum;

    Account(T id, int sum) {
        this.id = id;
        this.sum = sum;
    }

    public T getId() {
        return id;
    }

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае ограничением для <code>Transaction</code> является тип <code>Account</code>, который типизирован типом <code>String</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_интерфейсы_в_качестве_ограничений">7.2.2. Интерфейсы в качестве ограничений</h4>
<div class="paragraph">
<p>В качестве ограничений могут выступать также интерфейсы. В этом случае передаваемый на место универсального параметра тип должен реализовать данный интерфейс:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Account acc1 = new Account("1235rwr", 5000);
        Account acc2 = new Account("2373", 4300);
        Transaction&lt;Account&gt; tran1 = new Transaction&lt;Account&gt;(acc1, acc2, 1560);
        tran1.execute();
    }
}

interface Accountable {
    String getId();

    int getSum();

    void setSum(int sum);
}

class Account implements Accountable {
    private String id;
    private int sum;

    Account(String id, int sum) {
        this.id = id;
        this.sum = sum;
    }

    public String getId() {
        return id;
    }

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }
}

class Transaction&lt;T extends Accountable&gt; {
    private T from; // с какого счета перевод
    private T to; // на какой счет перевод
    private int sum; // сумма перевода

    Transaction(T from, T to, int sum) {
        this.from = from;
        this.to = to;
        this.sum = sum;
    }

    public void execute() {
        if (from.getSum() &gt; sum) {
            from.setSum(from.getSum() - sum);
            to.setSum(to.getSum() + sum);
            System.out.printf("Account %s: %d \nAccount %s: %d \n",
                    from.getId(), from.getSum(), to.getId(), to.getSum());
        } else {
            System.out.printf("Operation is invalid");
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_множественные_ограничения">7.2.3. Множественные ограничения</h4>
<div class="paragraph">
<p>Также можно установить сразу несколько ограничений. Например, пусть класс <code>Transaction</code> может работать только с объектами, одновременно реализуют интерфейс <code>IAccount</code> и являются наследниками класса <code>Person</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person {
}

interface Accountable {
}

class Transaction&lt;T extends Person &amp; Accountable&gt; {
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_наследование_и_обобщения">7.3. Наследование и обобщения</h3>
<div class="paragraph">
<p>Обобщенные классы могут участвовать в иерархии наследования: могут наследоваться от других, либо выполнять роль базовых классов. Рассмотрим различные ситуации.</p>
</div>
<div class="sect3">
<h4 id="_базовый_обобщенный_класс">7.3.1. Базовый обобщенный класс</h4>
<div class="paragraph">
<p>При наследовании от обобщенного класса класс-наследник должен передавать данные о типе в конструкции базового класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Account&lt;T&gt; {
    private T id;

    public T getId() {
        return this.id;
    }

    public Account(T id) {
        this.id = id;
    }
}

class DepositAccount&lt;T&gt; extends Account&lt;T&gt; {
    public DepositAccount(T id) {
        super(id);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В конструкторе <code>DepositAccount()</code> идет обращение к конструктору базового класса, в который передаются данные о типе.</p>
</div>
<div class="paragraph">
<p>Варианты использования классов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">DepositAccount dAccount1 = new DepositAccount(20);
System.out.println(dAccount1.getId());

DepositAccount dAccount2 = new DepositAccount("12345");
System.out.println(dAccount2.getId());</code></pre>
</div>
</div>
<div class="paragraph">
<p>При этом класс-наследник может добавлять и использовать какие-то свои параметры типов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Account&lt;T&gt; {
    private T id;

    public T getId() {
        return this.id;
    }

    public Account(T id) {
        this.id = id;
    }
}

class DepositAccount&lt;T, S&gt; extends Account&lt;T&gt; {
    private S name;

    public S getName() {
        return this.name;
    }

    public DepositAccount(T id, S name) {
        super(id);
        this.name = name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Варианты использования:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">DepositAccount&lt;Integer, String&gt; dAccount1 = new DepositAccount(20, "Tom");
System.out.println(dAccount1.getId() + " : " + dAccount1.getName());

DepositAccount&lt;String, Integer&gt; dAccount2 = new DepositAccount("12345", 23456);
System.out.println(dAccount2.getId() + " : " + dAccount2.getName());</code></pre>
</div>
</div>
<div class="paragraph">
<p>И еще одна ситуация - класс-наследник вообще может не быть обобщенным:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Account&lt;T&gt; {
    private T id;

    public T getId() {
        return this.id;
    }

    public Account(T id) {
        this.id = id;
    }
}

class DepositAccount extends Account&lt;Integer&gt; {
    public DepositAccount() {
        super(5);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь при наследовании явным образом указывается тип, который будет использоваться конструкциями базового класса, то есть тип <code>Integer</code>. Затем в конструктор базового класса передается значение именно этого типа - в данном случае число <code>5</code>.</p>
</div>
<div class="paragraph">
<p>Вариант использования:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">DepositAccount dAccount1 = new DepositAccount();
System.out.println(dAccount1.getId());</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_обобщенный_класс_наследник">7.3.2. Обобщенный класс-наследник</h4>
<div class="paragraph">
<p>Также может быть ситуация, когда базовый класс является обычным необобщенным классом. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Account {
    private String name;

    public String getName() {
        return this.name;
    }

    public Account(String name) {
        this.name = name;
    }
}

class DepositAccount&lt;T&gt; extends Account {
    private T id;

    public T getId() {
        return this.id;
    }

    public DepositAccount(String name, T id) {
        super(name);
        this.id = id;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом случае использование конструкций базового класса в наследнике происходит как обычно.</p>
</div>
</div>
<div class="sect3">
<h4 id="_преобразование_обобщенных_типов">7.3.3. Преобразование обобщенных типов</h4>
<div class="paragraph">
<p>Объект одного обобщенного типа можно привести к другому типу, если они используют один и тот же тип. Рассмотрим преобразование типов на примере следующих двух обобщенных классов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Account&lt;T&gt; {
    private T id;

    T getId() {
        return this.id;
    }

    Account(T id) {
        this.id = id;
    }
}

class DepositAccount&lt;T&gt; extends Account&lt;T&gt; {
    DepositAccount(T id) {
        super(id);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Мы можем привести объект <code>DepositAccount&lt;Integer&gt;</code> к <code>Account&lt;Integer&gt;</code> или <code>DepositAccount&lt;String&gt;</code> к <code>Account&lt;String&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">DepositAccount&lt;Integer&gt; depAccount = new DepositAccount(10);
Account&lt;Integer&gt; account = (Account&lt;Integer&gt;) depAccount;
System.out.println(account.getId());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Но сделать то же самое с разнотипными объектами мы не можем. Например, следующий код не будет работать:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">DepositAccount&lt;Integer&gt; depAccount = new DepositAccount(10);
Account&lt;String&gt; account = (Account&lt;String&gt;) depAccount;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_java_collection_framework">8. Java Collection Framework</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_типы_коллекций">8.1. Типы коллекций</h3>
<div class="paragraph">
<p>Для хранения наборов данных в Java предназначены массивы. Однако их не всегда удобно использовать, прежде всего потому, что они имеют фиксированную длину. Эту проблему в Java решают коллекции. Однако суть не только в гибких по размеру наборах объектов, но в и том, что классы коллекций реализуют различные алгоритмы и структуры данных, например, такие как стек, очередь, дерево и ряд других.</p>
</div>
<div class="paragraph">
<p>Классы коллекций располагаются в пакете <code>java.util</code>, поэтому перед применением коллекций следует подключить данный пакет.</p>
</div>
<div class="paragraph">
<p>Хотя в Java существует множество коллекций, но все они образуют стройную и логичную систему. Во-первых, в основе всех коллекций лежит применение того или иного интерфейса, который определяет базовый функционал. Среди этих интерфейсов можно выделить следующие:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Collection</code> базовый интерфейс для всех коллекций и других интерфейсов коллекций</p>
</li>
<li>
<p><code>Queue</code>: наследует интерфейс <code>Collection</code> и представляет функционал для структур данных в виде очереди</p>
</li>
<li>
<p><code>Deque</code>: наследует интерфейс <code>Queue</code> и представляет функционал для двунаправленных очередей</p>
</li>
<li>
<p><code>List</code>: наследует интерфейс <code>Collection</code> и представляет функциональность простых списков</p>
</li>
<li>
<p><code>Set</code>: также расширяет интерфейс <code>Collection</code> и используется для хранения множеств уникальных объектов</p>
</li>
<li>
<p><code>SortedSet</code>: расширяет интерфейс Set для создания сортированных коллекций</p>
</li>
<li>
<p><code>NavigableSet</code>: расширяет интерфейс SortedSet для создания коллекций, в которых можно осуществлять поиск по соответствию</p>
</li>
<li>
<p><code>Map</code>: предназначен для созданий структур данных в виде словаря, где каждый элемент имеет определенный ключ и значение. В отличие от других интерфейсов коллекций не наследуется от интерфейса <code>Collection</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Эти интерфейсы частично реализуются абстрактными классами:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AbstractCollection</code>: базовый абстрактный класс для других коллекций, который применяет интерфейс <code>Collection</code></p>
</li>
<li>
<p><code>AbstractList</code>: расширяет класс <code>AbstractCollection</code> и применяет интерфейс <code>List</code>, предназначен для создания коллекций в виде списков</p>
</li>
<li>
<p><code>AbstractSet</code>: расширяет класс <code>AbstractCollection</code> и применяет интерфейс <code>Set</code> для создания коллекций в виде множеств</p>
</li>
<li>
<p><code>AbstractQueue</code>: расширяет класс <code>AbstractCollection</code> и применяет интерфейс <code>Queue</code>, предназначен для создания коллекций в виде очередей и стеков</p>
</li>
<li>
<p><code>AbstractSequentialList</code>: также расширяет класс <code>AbstractList</code> и реализует интерфейс <code>List</code>. Используется для создания связанных списков</p>
</li>
<li>
<p><code>AbstractMap</code>: применяет интерфейс <code>Map</code>, предназначен для создания наборов по типу словаря с объектами в виде пары <code>key</code>-<code>value</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>С помощью применения вышеописанных интерфейсов и абстрактных классов в Java реализуется широкая палитра классов коллекций - списки, множества, очереди, отображения и другие, среди которых можно выделить следующие:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ArrayList</code>: простой список объектов</p>
</li>
<li>
<p><code>LinkedList</code>: представляет связанный список</p>
</li>
<li>
<p><code>ArrayDeque</code>: класс двунаправленной очереди, в которой мы можем произвести вставку и удаление как в начале коллекции, так и в ее конце</p>
</li>
<li>
<p><code>HashSet</code>: набор объектов или хеш-множество, где каждый элемент имеет ключ - уникальный хеш-код</p>
</li>
<li>
<p><code>TreeSet</code>: набор отсортированных объектов в виде дерева</p>
</li>
<li>
<p><code>LinkedHashSet</code>: связанное хеш-множество</p>
</li>
<li>
<p><code>PriorityQueue</code>: очередь приоритетов</p>
</li>
<li>
<p><code>HashMap</code>: структура данных в виде словаря, в котором каждый объект имеет уникальный ключ и некоторое значение</p>
</li>
<li>
<p><code>TreeMap</code>: структура данных в виде дерева, где каждый элемент имеет уникальный ключ и некоторое значение</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Схематично всю систему можно представить следующим образом:
<span class="image"><img src="/assets/img/java/core/collections/java-collection-hierarchy.png" alt="Java Collection Hierarchy"></span></p>
</div>
<div class="paragraph">
<p>Следует отметить, что в отличие от других интерфейсов, которые представляют коллекции, интерфейс <code>Map</code> <strong>НЕ расширяет</strong> интерфейс <code>Collection</code>.
<span class="image"><img src="/assets/img/java/core/collections/java-map-hierarchy.png" alt="Java Map Hierarchy"></span></p>
</div>
<div class="sect3">
<h4 id="_interface_collection">8.1.1. Interface <code>Collection</code></h4>
<div class="paragraph">
<p>Интерфейс <code>Collection</code> является базовым для всех коллекций, определяя основной функционал:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;{
    // определения методов
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Интерфейс <code>Collection</code> является обобщенным и расширяет интерфейс <code>Iterable</code>, поэтому все объекты коллекций можно перебирать в цикле по типу <code>for-each</code>.</p>
</div>
<div class="paragraph">
<p>Среди методов интерфейса <code>Collection</code> можно выделить следующие:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boolean add(E item)</code>: добавляет в коллекцию объект <code>item</code>. При удачном добавлении возвращает <code>true</code>, при неудачном - <code>false</code></p>
</li>
<li>
<p><code>boolean addAll(Collection&lt;? extends E&gt; col)</code>: добавляет в коллекцию все элементы из коллекции <code>col</code>. При удачном добавлении возвращает <code>true</code>, при неудачном - <code>false</code></p>
</li>
<li>
<p><code>void clear()</code>: удаляет все элементы из коллекции</p>
</li>
<li>
<p><code>boolean contains(Object item)</code>: возвращает <code>true</code>, если объект <code>item</code> содержится в коллекции, иначе возвращает <code>false</code></p>
</li>
<li>
<p><code>boolean isEmpty()</code>: возвращает <code>true</code>, если коллекция пуста, иначе возвращает <code>false</code></p>
</li>
<li>
<p><code>Iterator&lt;E&gt; iterator()</code>: возвращает объект Iterator для обхода элементов коллекции</p>
</li>
<li>
<p><code>boolean remove(Object item)</code>: возвращает <code>true</code>, если объект <code>item</code> удачно удален из коллекции, иначе возвращается <code>false</code></p>
</li>
<li>
<p><code>boolean removeAll(Collection&lt;?&gt; col)</code>: удаляет все объекты коллекции <code>col</code> из текущей коллекции. Если текущая коллекция изменилась, возвращает <code>true</code>, иначе возвращается <code>false</code></p>
</li>
<li>
<p><code>boolean retainAll(Collection&lt;?&gt; col)</code>: удаляет все объекты из текущей коллекции, кроме тех, которые содержатся в коллекции <code>col</code>. Если текущая коллекция после удаления изменилась, возвращает <code>true</code>, иначе возвращается <code>false</code></p>
</li>
<li>
<p><code>int size()</code>: возвращает число элементов в коллекции</p>
</li>
<li>
<p><code>Object[] toArray()</code>: возвращает массив, содержащий все элементы коллекции</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Все эти и остальные методы, которые имеются в интерфейсе <code>Collection</code>, реализуются всеми коллекциями, поэтому в целом общие принципы работы с коллекциями будут одни и те же. Единообразный интерфейс упрощает понимание и работу с различными типами коллекций. Так, добавление элемента будет производиться с помощью метода <code>add()</code>, который принимает добавляемый элемент в качестве параметра. Для удаления вызывается метод <code>remove()</code>. Метод <code>clear()</code> будет очищать коллекцию, а метод <code>size()</code> возвращать количество элементов в коллекции.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interface_iterator">8.2. Interface <code>Iterator</code></h3>
<div class="paragraph">
<p>Одним из ключевых методов интерфейса <code>Collection</code>, который он унаследовал от интерфейса <code>Iterable</code> является метод <code>Iterator&lt;E&gt; iterator()</code>. Он возвращает <strong>итератор</strong> - то есть объект, реализующий интерфейс <code>Iterator</code>.</p>
</div>
<div class="paragraph">
<p>Интерфейс <code>Iterator</code> имеет следующее определение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public interface Iterator &lt;E&gt; {
    E next();

    boolean hasNext();

    void remove();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Реализация интерфейса предполагает, что с помощью вызова метода <code>next()</code> можно получить следующий элемент. С помощью метода <code>hasNext()</code> можно узнать, есть ли следующий элемент, и не достигнут ли конец коллекции. И если элементы еще имеются, то <code>hasNext()</code> вернет значение <code>true</code>. Метод <code>hasNext()</code> следует вызывать перед методом <code>next()</code>, так как при достижении конца коллекции метод <code>next()</code> выбрасывает исключение <code>NoSuchElementException</code>. И метод <code>remove()</code> удаляет текущий элемент, который был получен последним вызовом <code>next()</code>.</p>
</div>
<div class="paragraph">
<p>Используем итератор для перебора коллекции <code>ArrayList</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.ArrayList;
import java.util.Iterator;

public class Program {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; states = new ArrayList&lt;String&gt;();
        states.add("Germany");
        states.add("France");
        states.add("Italy");
        states.add("Spain");

        Iterator&lt;String&gt; iter = states.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next());
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interface_list">8.3. Interface <code>List</code></h3>
<div class="paragraph">
<p>Для создания простых списков применяется интерфейс <code>List</code>, который расширяет функцональность интерфейса <code>Collection</code>. Некоторые наиболее часто используемые методы интерфейса <code>List</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void add(int index, E obj)</code> добавляет в список по индексу <code>index</code> объект <code>obj</code></p>
</li>
<li>
<p><code>boolean addAll(int index, Collection&lt;? extends E&gt; col)</code> добавляет в список по индексу <code>index</code> все элементы коллекции <code>col</code>. Если в результате добавления список был изменен, то возвращается <code>true</code>, иначе возвращается <code>false</code></p>
</li>
<li>
<p><code>E get(int index)</code> возвращает объект из списка по индексу <code>index</code></p>
</li>
<li>
<p><code>int indexOf(Object obj)</code> возвращает индекс первого вхождения объекта <code>obj</code> в список. Если объект не найден, то возвращается <code>-1</code></p>
</li>
<li>
<p><code>int lastIndexOf(Object obj)</code> возвращает индекс последнего вхождения объекта <code>obj</code> в список. Если объект не найден, то возвращается <code>-1</code></p>
</li>
<li>
<p><code>ListIterator&lt;E&gt; listIterator ()</code> возвращает объект <code>ListIterator</code> для обхода элементов списка</p>
</li>
<li>
<p><code>static &lt;E&gt; List&lt;E&gt; of(Object &#8230;&#8203;)</code> создает из набора элементов объект <code>List</code></p>
</li>
<li>
<p><code>E remove(int index)</code> удаляет объект из списка по индексу <code>index</code>, возвращая при этом удаленный объект</p>
</li>
<li>
<p><code>E set(int index, E obj)</code> присваивает значение объекта <code>obj</code> элементу, который находится по индексу <code>index</code></p>
</li>
<li>
<p><code>void sort(Comparator&lt;? super E&gt; comp)</code> сортирует список с помощью компаратора <code>comp</code></p>
</li>
<li>
<p><code>List&lt;E&gt; subList(int start, int end)</code> получает набор элементов, которые находятся в списке между индексами <code>start</code> и <code>end</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_class_arraylist">8.3.1. Class <code>ArrayList</code></h4>
<div class="paragraph">
<p>По умолчанию в Java есть встроенная реализация этого интерфейса - класс <code>ArrayList</code>. Класс <code>ArrayList</code> представляет обобщенную коллекцию, которая наследует свою функциональность от класса <code>AbstractList</code> и применяет интерфейс <code>List</code>. Проще говоря, <code>ArrayList</code> представляет простой список, аналогичный массиву, за тем исключением, что количество элементов в нем не фиксировано.</p>
</div>
<div class="paragraph">
<p><code>ArrayList</code> имеет следующие конструкторы`:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ArrayList()</code> создает пустой список</p>
</li>
<li>
<p><code>ArrayList(Collection &lt;? extends E&gt; col)</code> создает список, в который добавляются все элементы коллекции <code>col</code></p>
</li>
<li>
<p><code>ArrayList (int capacity)</code> создает список, который имеет начальную емкость <code>capacity</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Емкость в <code>ArrayList</code> представляет размер массива, который будет использоваться для хранения объектов. При добавлении элементов фактически происходит перераспределение памяти - создание нового массива и копирование в него элементов из старого массива. Изначальное задание емкости <code>ArrayList</code> позволяет снизить подобные перераспределения памяти, тем самым повышая производительность.</p>
</div>
<div class="paragraph">
<p>Используем класс <code>ArrayList</code> и некоторые его методы в программе:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.ArrayList;

public class Program {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; people = new ArrayList&lt;String&gt;();
        // добавим в список ряд элементов
        people.add("Tom");
        people.add("Alice");
        people.add("Kate");
        people.add("Sam");
        people.add(1, "Bob"); // добавляем элемент по индексу 1

        System.out.println(people.get(1));// получаем 2-й объект
        people.set(1, "Robert"); // установка нового значения для 2-го объекта

        System.out.printf("ArrayList has %d elements \n", people.size());
        for (String person : people) {
            System.out.println(person);
        }
        // проверяем наличие элемента
        if (people.contains("Tom")) {
            System.out.println("ArrayList contains Tom");
        }

        // удалим несколько объектов
        // удаление конкретного элемента
        people.remove("Robert");
        // удаление по индексу
        people.remove(0);

        Object[] peopleArray = people.toArray();
        for (Object person : peopleArray) {
            System.out.println(person);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь объект <code>ArrayList</code> типизируется классом <code>String</code>, поэтому список будет хранить только строки. Поскольку класс <code>ArrayList</code> применяет интерфейс <code>Collection&lt;E&gt;</code>, то мы можем использовать методы данного интерфейса для управления объектами в списке.</p>
</div>
<div class="paragraph">
<p>Для добавления вызывается метод <code>add()</code>. С его помощью мы можем добавлять объект в конец списка. Также мы можем добавить объект на определенное место в списке. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">people.add("Tom") // добавит элемент в конец списка
people.add(1, "Bob") // добавит элемент на 1 позицию в списке</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>size()</code> позволяет узнать количество объектов в коллекции.</p>
</div>
<div class="paragraph">
<p>Проверку на наличие элемента в коллекции производится с помощью метода <code>contains()</code>. А удаление с помощью метода <code>remove()</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">people.remove("Tom") // удаление элемента с данным значением из списка
people.remove(0) // удаление элемента на 0 позиции в списке</code></pre>
</div>
</div>
<div class="paragraph">
<p>Получить определенный элемент по индексу мы можем с помощью метода <code>get()</code>, а установить элемент по индексу с помощью метода <code>set</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String person = people.get(1);
people.set(1, "Robert");</code></pre>
</div>
</div>
<div class="paragraph">
<p>С помощью метода <code>toArray()</code> мы можем преобразовать список в массив объектов.</p>
</div>
<div class="paragraph">
<p>И поскольку класс <code>ArrayList</code> реализует интерфейс <code>Iterable</code>, то мы можем пробежаться по списку в цикле типа <code>for-each</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">for(String person : people) {
    // some opeartors
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Хотя мы можем свободно добавлять в объект <code>ArrayList</code> дополнительные объекты, в отличие от массива, однако в реальности <code>ArrayList</code> использует для хранения объектов опять же массив. По умолчанию данный массив предназначен для 10 объектов. Если в процессе программы добавляется гораздо больше, то создается новый массив, который может вместить в себя все количество. Подобные перераспределения памяти <strong>уменьшают производительность</strong>. Поэтому если мы точно знаем, что у нас список не будет содержать больше определенного количества элементов, например, 25, то мы можем сразу же явным образом установить это количество, либо в конструкторе: <code>ArrayList&lt;String&gt; people = new ArrayList&lt;String&gt;(25);</code>, либо с помощью метода <code>ensureCapacity</code>: <code>people.ensureCapacity(25);</code></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interface_listiterator">8.4. Interface <code>ListIterator</code></h3>
<div class="paragraph">
<p>Интерфейс <code>Iterator</code> предоставляет ограниченный функционал. Гораздо больший набор методов предоставляет другой итератор - интерфейс <code>ListIterator</code>. Данный итератор используется классами, реализующими интерфейс <code>List</code>, то есть классами <code>LinkedList</code>, <code>ArrayList</code> и др.</p>
</div>
<div class="paragraph">
<p>Интерфейс <code>ListIterator</code> расширяет интерфейс <code>Iterator</code> и определяет ряд дополнительных методов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void add(E obj)</code> вставляет объект <code>obj</code> перед элементом, который должен быть возвращен следующим вызовом <code>next()</code></p>
</li>
<li>
<p><code>boolean hasNext()</code> возвращает <code>true</code>, если в коллекции имеется следующий элемент, иначе возвращает <code>false</code></p>
</li>
<li>
<p><code>boolean hasPrevious()</code> возвращает <code>true</code>, если в коллекции имеется предыдущий элемент, иначе возвращает <code>false</code></p>
</li>
<li>
<p><code>E next()</code> возвращает текущий элемент и переходит к следующему, если такого нет, то генерируется исключение <code>NoSuchElementException</code></p>
</li>
<li>
<p><code>E previous()</code> возвращает текущий элемент и переходит к предыдущему, если такого нет, то генерируется исключение <code>NoSuchElementException</code></p>
</li>
<li>
<p><code>int nextIndex()</code> возвращает индекс следующего элемента. Если такого нет, то возвращается размер списка</p>
</li>
<li>
<p><code>int previousIndex()</code> возвращает индекс предыдущего элемента. Если такого нет, то возвращается число <code>-1</code></p>
</li>
<li>
<p><code>void remove()</code> удаляет текущий элемент из списка. Таким образом, этот метод должен быть вызван после методов <code>next()</code> или <code>previous()</code>, иначе будет сгенерировано исключение <code>IllegalStateException</code></p>
</li>
<li>
<p><code>void set(E obj)</code> присваивает текущему элементу, выбранному вызовом методов <code>next()</code> или <code>previous()</code>, ссылку на объект <code>obj</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Используем <code>ListIterator</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.ArrayList;
import java.util.ListIterator;

public class Program {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; states = new ArrayList&lt;String&gt;();
        states.add("Germany");
        states.add("France");
        states.add("Italy");
        states.add("Spain");

        ListIterator&lt;String&gt; listIter = states.listIterator();

        while (listIter.hasNext()) {
            System.out.println(listIter.next());
        }
        // сейчас текущий элемент - Испания
        // изменим значение этого элемента
        listIter.set("Португалия");
        // пройдемся по элементам в обратном порядке
        while (listIter.hasPrevious()) {
            System.out.println(listIter.previous());
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interface_comparable">8.5. Interface <code>Comparable</code></h3>
<div class="paragraph">
<p>Рассмотрим коллекции <code>TreeSet</code>, типизированную объектами <code>String</code>. При добавлении новых элементов объект <code>TreeSet</code> автоматически проводит сортировку, помещая новый объект на правильное для него место. Что если бы использовались не строки, а классы, например, следующий класс <code>Person</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person {
    private String name;

    Person(String name) {
        this.name = name;
    }

    String getName() {
        return name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Объект <code>TreeSet</code> нельзя типизировать данным классом, поскольку в случае добавления объектов <code>TreeSet</code> не будет знать, как их сравнивать, и следующий код не будет работать:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">TreeSet&lt;Person&gt; people = new TreeSet&lt;Person&gt;();
people.add(new Person("Tom"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>При выполнении этого кода возникнет ошибка, которая скажет, что объект <code>Person</code> не может быть преобразован к типу <code>java.lang.Comparable</code>.</p>
</div>
<div class="paragraph">
<p>Для того, чтобы объекты <code>Person</code> можно было сравнить и сортировать, они должны применять интерфейс <code>Comparable&lt;E&gt;</code>. При применении интерфейса он типизируется текущим классом. Применим его к классу <code>Person</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person implements Comparable&lt;Person&gt; {
    private String name;

    Person(String name) {
        this.name = name;
    }

    String getName() {
        return name;
    }

    public int compareTo(Person p) {
        return name.compareTo(p.getName());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Интерфейс <code>Comparable</code> содержит один единственный метод <code>int compareTo(E item)</code>, который сравнивает текущий объект с объектом, переданным в качестве параметра. Если этот метод возвращает отрицательное число, то текущий объект будет располагаться перед тем, который передается через параметр. Если метод вернет положительное число, то, наоборот, после второго объекта. Если метод возвратит <code>0</code>, значит, оба объекта равны.</p>
</div>
<div class="paragraph">
<p>В данном случае мы не возвращаем явным образом никакое число, а полагаемся на встроенный механизм сравнения, который есть у класса <code>String</code>. Но мы также можем определить и свою логику, например, сравнивать по длине имени:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public int compareTo(Person p) {
    return name.length() - p.getName().length();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь можно типизировать <code>TreeSet</code> типом <code>Person</code> и добавлять в дерево соответствующие объекты:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">TreeSet&lt;Person&gt; people = new TreeSet&lt;Person&gt;();
people.add(new Person("Tom"));</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_interface_comparator">8.5.1. Interface <code>Comparator</code></h4>
<div class="paragraph">
<p>Однако перед нами может возникнуть проблема, что если разработчик не реализовал в своем классе, который мы хотим использовать, интерфейс <code>Comparable</code>, либо реализовал, но нас не устраивает его функциональность, и мы хотим ее переопределить? На этот случай есть еще более гибкий способ, предполагающий применение интерфейса <code>Comparator&lt;E&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Интерфейс <code>Comparator</code> содержит ряд методов, ключевым из которых является метод <code>compare()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public interface Comparator&lt;E&gt; {
    int compare(T a, T b);
    // остальные методы
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>compare()</code> также возвращает числовое значение - если оно отрицательное, то объект <code>a</code> предшествует объекту <code>b</code>, иначе - наоборот. А если метод возвращает <code>0</code>, то объекты равны. Для применения интерфейса нам вначале надо создать класс компаратора, который реализует этот интерфейс:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class PersonComparator implements Comparator&lt;Person&gt; {
    public int compare(Person a, Person b) {
        return a.getName().compareTo(b.getName());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь опять же проводим сравнение по строкам. Теперь используем класс компаратора для создания объекта <code>TreeSet</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">PersonComparator pcomp = new PersonComparator();
TreeSet&lt;Person&gt; people = new TreeSet&lt;Person&gt;(pcomp);
people.add(new Person("Tom"));
people.add(new Person("Nick"));
people.add(new Person("Alice"));
people.add(new Person("Bill"));
for (Person p : people) {
    System.out.println(p.getName());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для создания <code>TreeSet</code> здесь используется одна из версий конструктора, которая в качестве параметра принимает компаратор. Теперь вне зависимости от того, реализован ли в классе <code>Person</code> интерфейс <code>Comparable</code>, логика сравнения и сортировки будет использоваться та, которая определена в классе компаратора.</p>
</div>
</div>
<div class="sect3">
<h4 id="_сортировка_по_нескольким_критериям">8.5.2. Сортировка по нескольким критериям</h4>
<div class="paragraph">
<p>Начиная с JDK 8 в механизм работы компараторов были внесены некоторые дополнения. В частности, теперь мы можем применять сразу несколько компараторов по принципу приоритета. Например, изменим класс <code>Person</code> следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    String getName() {
        return this.name;
    }

    int getAge() {
        return this.age;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь добавлено поле для хранения возраста пользователя. И, допустим, нам надо отсортировать пользователей по имени и по возрасту. Для этого определим два компаратора:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class PersonNameComparator implements Comparator&lt;Person&gt; {
    public int compare(Person a, Person b) {
        return a.getName().compareTo(b.getName());
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class PersonAgeComparator implements Comparator&lt;Person&gt; {
    public int compare(Person a, Person b) {
        int result = 0;
        if (a.getAge() &gt; b.getAge()) {
            result = 1;
        } else if (a.getAge() &lt; b.getAge()) {
            result = -1;
        }
        return result;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Интерфейс компаратора определяет специальный метод по умолчанию <code>thenComparing()</code>, который позволяет использовать цепочки компараторов для сортировки набора:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Comparator&lt;Person&gt; pcomp = new PersonNameComparator().thenComparing(new PersonAgeComparator());
TreeSet&lt;Person&gt; people = new TreeSet(pcomp);
people.add(new Person("Tom", 23));
people.add(new Person("Nick", 34));
people.add(new Person("Tom", 10));
people.add(new Person("Bill", 14));

for (Person p : people) {
    System.out.println(p.getName() + " " + p.getAge());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае сначала применяется сортировка по имени, а потом по возрасту.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interface_queue">8.6. Interface <code>Queue</code></h3>
<div class="paragraph">
<p>Очереди представляют структуру данных, работающую по принципу <strong>FIFO (first in - first out)</strong>. То есть чем раньше был добавлен элемент в коллекцию, тем раньше он из нее удаляется. Это стандартная модель однонаправленной очереди. Однако бывают и двунаправленные - то есть такие, в которых мы можем добавить элемент не только в начала, но и в конец. И соответственно удалить элемент не только из конца, но и из начала.</p>
</div>
<div class="paragraph">
<p>Особенностью классов очередей является то, что они реализуют специальные интерфейсы <code>Queue</code> или <code>Deque</code>.</p>
</div>
<div class="paragraph">
<p>Обобщенный интерфейс <code>Queue&lt;E&gt;</code> расширяет базовый интерфейс <code>Collection</code> и определяет поведение класса в качестве однонаправленной очереди. Свою функциональность он раскрывает через следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>E element()</code>: возвращает, но не удаляет, элемент из начала очереди. Если очередь пуста, генерирует исключение <code>NoSuchElementException</code></p>
</li>
<li>
<p><code>boolean offer(E obj)</code>: добавляет элемент <code>obj</code> в конец очереди. Если элемент удачно добавлен, возвращает <code>true</code>, иначе - <code>false</code></p>
</li>
<li>
<p><code>E peek()</code>: возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение <code>null</code></p>
</li>
<li>
<p><code>E poll()</code>: возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение <code>null</code></p>
</li>
<li>
<p><code>E remove()</code>: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение <code>NoSuchElementException</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Таким образом, у всех классов, которые реализуют данный интерфейс, будет метод <code>offer</code> для добавления в очередь, метод <code>poll</code> для извлечения элемента из головы очереди, и методы <code>peek</code> и <code>element</code>, позволяющие просто получить элемент из головы очереди.</p>
</div>
<div class="sect3">
<h4 id="_interface_deque">8.6.1. Interface <code>Deque</code></h4>
<div class="paragraph">
<p>Интерфейс <code>Deque</code> расширяет вышеописанный интерфейс Queue и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, либо как стек, действующий по принципу <strong>LIFO (последний вошел - первый вышел)</strong>.</p>
</div>
<div class="paragraph">
<p>Интерфейс <code>Deque</code> определяет следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void addFirst(E obj)</code>: добавляет элемент в начало очереди</p>
</li>
<li>
<p><code>void addLast(E obj)</code>: добавляет элемент <code>obj</code> в конец очереди</p>
</li>
<li>
<p><code>E getFirst()</code>: возвращает без удаления элемент из головы очереди. Если очередь пуста, генерирует исключение <code>NoSuchElementException</code></p>
</li>
<li>
<p><code>E getLast()</code>: возвращает без удаления последний элемент очереди. Если очередь пуста, генерирует исключение <code>NoSuchElementException</code></p>
</li>
<li>
<p><code>boolean offerFirst(E obj)</code>: добавляет элемент <code>obj</code> в самое начало очереди. Если элемент удачно добавлен, возвращает <code>true</code>, иначе - <code>false</code></p>
</li>
<li>
<p><code>boolean offerLast(E obj)</code>: добавляет элемент <code>obj</code> в конец очереди. Если элемент удачно добавлен, возвращает <code>true</code>, иначе - <code>false</code></p>
</li>
<li>
<p><code>E peekFirst()</code>: возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение <code>null</code></p>
</li>
<li>
<p><code>E peekLast()</code>: возвращает без удаления последний элемент очереди. Если очередь пуста, возвращает значение <code>null</code></p>
</li>
<li>
<p><code>E pollFirst()</code>: возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение <code>null</code></p>
</li>
<li>
<p><code>E pollLast()</code>: возвращает с удалением последний элемент очереди. Если очередь пуста, возвращает значение <code>null</code></p>
</li>
<li>
<p><code>E pop()</code>: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение <code>NoSuchElementException</code></p>
</li>
<li>
<p><code>void push(E element)</code>: добавляет элемент в самое начало очереди</p>
</li>
<li>
<p><code>E removeFirst()</code>: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение <code>NoSuchElementException</code></p>
</li>
<li>
<p><code>E removeLast()</code>: возвращает с удалением элемент из конца очереди. Если очередь пуста, генерирует исключение <code>NoSuchElementException</code></p>
</li>
<li>
<p><code>boolean removeFirstOccurrence(Object obj)</code>: удаляет первый встреченный элемент <code>obj</code> из очереди. Если удаление произшло, то возвращает <code>true</code>, иначе возвращает <code>false</code>.</p>
</li>
<li>
<p><code>boolean removeLastOccurrence(Object obj)</code>: удаляет последний встреченный элемент <code>obj</code> из очереди. Если удаление произшло, то возвращает <code>true</code>, иначе возвращает <code>false</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Таким образом, наличие методов <code>pop</code> и <code>push</code> позволяет классам, реализующим этот элемент, действовать в качестве стека. В тоже время имеющийся функционал также позволяет создавать двунаправленные очереди, что делает классы, применяющие данный интерфейс, довольно гибкими.</p>
</div>
</div>
<div class="sect3">
<h4 id="_arraydeque">8.6.2. <code>ArrayDeque</code></h4>
<div class="paragraph">
<p>В Java очереди представлены рядом классов. Одни из низ - класс <code>ArrayDeque&lt;E&gt;</code>. Этот класс представляют обобщенную двунаправленную очередь, наследуя функционал от класса <code>AbstractCollection</code> и применяя интерфейс <code>Deque</code>.</p>
</div>
<div class="paragraph">
<p>В классе <code>ArrayDeque</code> определены следующие конструкторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ArrayDeque()</code>: создает пустую очередь</p>
</li>
<li>
<p><code>ArrayDeque(Collection&lt;? extends E&gt; col)</code>: создает очередь, наполненную элементами из коллекции <code>col</code></p>
</li>
<li>
<p><code>ArrayDeque(int capacity)</code>: создает очередь с начальной емкостью <code>capacity</code>. Если мы явно не указываем начальную емкость, то <strong>емкость по умолчанию будет равна 16</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример использования класса`:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.ArrayDeque;

public class Program {
    public static void main(String[] args) {
        ArrayDeque&lt;String&gt; states = new ArrayDeque&lt;String&gt;();
        // стандартное добавление элементов
        states.add("Germany");
        states.addFirst("France"); // добавляем элемент в самое начало
        states.push("Great Britain"); // добавляем элемент в самое начало
        states.addLast("Spain"); // добавляем элемент в конец коллекции
        states.add("Italy");

        // получаем первый элемент без удаления
        String sFirst = states.getFirst();
        System.out.println(sFirst);     // Great Britain
        // получаем последний элемент без удаления
        String sLast = states.getLast();
        System.out.println(sLast);      // Italy

        System.out.printf("Queue size: %d \n", states.size());  // 5

        // перебор коллекции
        while (states.peek() != null) {
            // извлечение c начала
            System.out.println(states.pop());
        }

        // очередь из объектов Person
        ArrayDeque&lt;Person&gt; people = new ArrayDeque&lt;Person&gt;();
        people.addFirst(new Person("Tom"));
        people.addLast(new Person("Nick"));
        // перебор без извлечения
        for (Person p : people) {
            System.out.println(p.getName());
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person {
    private String name;

    public Person(String value) {

        name = value;
    }

    String getName() {
        return name;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_linkedlist">8.7. LinkedList</h3>
<div class="paragraph">
<p>Обобщенный класс <code>LinkedList&lt;E&gt;</code> представляет структуру данных в виде связанного списка. Он наследуется от класса <code>AbstractSequentialList</code> и реализует интерфейсы <code>List</code>, <code>Dequeue</code> и <code>Queue</code>. То есть он соединяет функциональность работы со списком и фукциональность очереди.</p>
</div>
<div class="paragraph">
<p>Класс <code>LinkedList</code> имеет следующие конструкторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>LinkedList()</code>: создает пустой список</p>
</li>
<li>
<p><code>LinkedList(Collection&lt;? extends E&gt; col)</code>: создает список, в который добавляет все элементы коллекции <code>col</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>LinkedList</code> содержит все те методы, которые определены в интерфейсах <code>List</code>, <code>Queue</code>, <code>Deque</code>. Некоторые из них:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>addFirst() / offerFirst()</code> добавляет элемент в начало списка</p>
</li>
<li>
<p><code>addLast() / offerLast()</code> добавляет элемент в конец списка</p>
</li>
<li>
<p><code>removeFirst() / pollFirst()</code> удаляет первый элемент из начала списка</p>
</li>
<li>
<p><code>removeLast() / pollLast()</code> удаляет последний элемент из конца списка</p>
</li>
<li>
<p><code>getFirst() / peekFirst()</code> получает первый элемент</p>
</li>
<li>
<p><code>getLast() / peekLast()</code> получает последний элемент</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Рассмотрим применение связанного списка:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.LinkedList;

public class Program {
    public static void main(String[] args) {
        LinkedList&lt;String&gt; states = new LinkedList&lt;String&gt;();
        // добавим в список ряд элементов
        states.add("Germany");
        states.add("France");
        states.addLast("Great Britain"); // добавляем на последнее место
        states.addFirst("Spain"); // добавляем на первое место
        states.add(1, "Italy"); // добавляем элемент по индексу 1

        System.out.printf("List has %d elements \n", states.size());
        System.out.println(states.get(1));
        states.set(1, "Portugal");
        for (String state : states) {
            System.out.println(state);
        }
        // проверка на наличие элемента в списке
        if (states.contains("Germany")) {
            System.out.println("List contains Germany");
        }

        states.remove("Germany");
        states.removeFirst(); // удаление первого элемента
        states.removeLast(); // удаление последнего элемента

        LinkedList&lt;Person&gt; people = new LinkedList&lt;Person&gt;();
        people.add(new Person("Mike"));
        people.addFirst(new Person("Tom"));
        people.addLast(new Person("Nick"));
        people.remove(1); // удаление второго элемента

        for (Person p : people) {
            System.out.println(p.getName());
        }
        Person first = people.getFirst();
        System.out.println(first.getName()); // вывод первого элемента
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person {
    private String name;

    public Person(String value) {

        name = value;
    }

    String getName() {
        return name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь создаются и используются два списка: для строк и для объектов класса <code>Person</code>. При этом в дополнение к методам <code>addFirst()</code>, <code>removeLast()</code> и т.д., нам также доступны стандартные методы, определенные в интерфейсе <code>Collection</code>: <code>add()</code>, <code>remove()</code>, <code>contains()</code>, <code>size()</code> и другие. Поэтому мы можем использовать разные методы для одного и того же действия. Например, добавление в самое начало списка можно сделать так: <code>states.addFirst("Spain");</code>, а можно сделать так: <code>states.add(0, "Spain");</code></p>
</div>
</div>
<div class="sect2">
<h3 id="_interface_set">8.8. Interface <code>Set</code></h3>
<div class="paragraph">
<p>Интерфейс <code>Set</code> расширяет интерфейс <code>Collection</code> и представляет набор уникальных элементов. <code>Set</code> не добавляет новых методов, только вносит изменения в унаследованные. В частности, метод <code>add()</code> добавляет элемент в коллекцию и возвращает <code>true</code>, если в коллекции еще нет такого элемента.</p>
</div>
<div class="sect3">
<h4 id="_hashset">8.8.1. HashSet</h4>
<div class="paragraph">
<p>Обобщенный класс <code>HashSet</code> представляет <strong>хеш-таблицу</strong>. Он наследует свой функционал от класса <code>AbstractSet</code>, а также реализует интерфейс <code>Set</code>.</p>
</div>
<div class="paragraph">
<p><strong>Хеш-таблица</strong> представляет такую структуру данных, в которой все объекты имеют уникальный ключ или <strong>хеш-код</strong>. Данный ключ позволяет уникально идентифицировать объект в таблице.</p>
</div>
<div class="paragraph">
<p>Для создания объекта <code>HashSet</code> можно воспользоваться одним из следующих конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>HashSet()</code> создает пустой список</p>
</li>
<li>
<p><code>HashSet(Collection&lt;? extends E&gt; col)</code> создает хеш-таблицу, в которую добавляет все элементы коллекции <code>col</code></p>
</li>
<li>
<p><code>HashSet(int capacity)</code> параметр <code>capacity</code> указывает начальную емкость таблицы, которая <strong>по умолчанию равна 16</strong></p>
</li>
<li>
<p><code>HashSet(int capacity, float koef)</code> параметр <code>koef</code> или <strong>коэффициент заполнения</strong>, значение которого должно быть в пределах от <code>0.0</code> до <code>1.0</code>, указывает, насколько должна быть заполнена емкость объектами прежде чем произойдет ее расширение.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Класс <code>HashSet</code> не добавляет новых методов, реализуя лишь те, что объявлены в родительских классах и применяемых интерфейсах:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.HashSet;

public class Program {
    public static void main(String[] args) {
        HashSet&lt;String&gt; states = new HashSet&lt;String&gt;();

        // добавим в список ряд элементов
        states.add("Germany");
        states.add("France");
        states.add("Italy");
        // пытаемся добавить элемент, который уже есть в коллекции
        boolean isAdded = states.add("Germany");
        System.out.println(isAdded);    // false

        System.out.printf("Set contains %d elements \n", states.size());    // 3

        for (String state : states) {
            System.out.println(state);
        }
        // удаление элемента
        states.remove("Germany");

        // хеш-таблица объектов Person
        HashSet&lt;Person&gt; people = new HashSet&lt;Person&gt;();
        people.add(new Person("Mike"));
        people.add(new Person("Tom"));
        people.add(new Person("Nick"));
        for (Person p : people) {
            System.out.println(p.getName());
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    String getName() {
        return this.name;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interface_sortedset">8.9. Interface <code>SortedSet</code></h3>
<div class="paragraph">
<p>Интерфейс <code>SortedSet</code> предназначен для создания коллекций, который хранят элементы в отсортированном виде (<strong>сортировка по возрастанию</strong>). <code>SortedSet</code> расширяет интерфейс <code>Set</code>, поэтому такая коллекция опять же хранит только уникальные значения. <code>SortedSet</code> предоставляет следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>E first()</code> возвращает первый элемент набора</p>
</li>
<li>
<p><code>E last()</code> возвращает последний элемент набора</p>
</li>
<li>
<p><code>SortedSet&lt;E&gt; headSet(E end)</code> возвращает объект <code>SortedSet</code>, который содержит все элементы первичного набора до элемента <code>end</code></p>
</li>
<li>
<p><code>SortedSet&lt;E&gt; subSet(E start, E end)</code> возвращает объект <code>SortedSet</code>, который содержит все элементы первичного набора между элементами <code>start</code> и <code>end</code></p>
</li>
<li>
<p><code>SortedSet&lt;E&gt; tailSet(E start)</code> возвращает объект <code>SortedSet</code>, который содержит все элементы первичного набора, начиная с элемента <code>start</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_interface_navigableset">8.9.1. Interface <code>NavigableSet</code></h4>
<div class="paragraph">
<p>Интерфейс <code>NavigableSet</code> расширяет интерфейс <code>SortedSet</code> и позволяет извлекать элементы на основании их значений. <code>NavigableSet</code> определяет следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>E ceiling(E obj)</code> ищет в наборе наименьший элемент <code>e</code>, который больше либо равен элементу <code>obj</code> (<code>e &gt;= obj</code>). Если такой элемент найден, то он возвращается в качестве результата. Иначе возвращается <code>null</code>.</p>
</li>
<li>
<p><code>E floor(E obj)</code> ищет в наборе наибольший элемент <code>e</code>, который меньше либо равен элементу <code>obj</code> (<code>e &#8656; obj</code>). Если такой элемент найден, то он возвращается в качестве результата. Иначе возвращается <code>null</code>.</p>
</li>
<li>
<p><code>E higher(E obj)</code> ищет в наборе наименьший элемент <code>e</code>, который больше элемента <code>obj</code> (<code>e &gt; obj</code>). Если такой элемент найден, то он возвращается в качестве результата. Иначе возвращается <code>null</code>.</p>
</li>
<li>
<p><code>E lower(E obj)</code> ищет в наборе наибольший элемент <code>e</code>, который меньше элемента <code>obj</code> (<code>e &lt; obj</code>). Если такой элемент найден, то он возвращается в качестве результата. Иначе возвращается <code>null</code>.</p>
</li>
<li>
<p><code>E pollFirst()</code> возвращает первый элемент</p>
</li>
<li>
<p><code>E pollLast()</code> возвращает последний элемент</p>
</li>
<li>
<p><code>NavigableSet&lt;E&gt; descendingSet()</code> возвращает объект <code>NavigableSet</code>, который содержит все элементы первичного набора <code>NavigableSet</code> в обратном порядке</p>
</li>
<li>
<p><code>NavigableSet&lt;E&gt; headSet(E upperBound, boolean incl)</code>: возвращает объект <code>NavigableSet</code>, который содержит все элементы первичного набора <code>NavigableSet</code> до <code>upperBound</code>. Параметр <code>incl</code> при значении <code>true</code>, позволяет включить в выходной набор элемент <code>upperBound</code></p>
</li>
<li>
<p><code>NavigableSet&lt;E&gt; tailSet(E lowerBound, boolean incl)</code> возвращает объект <code>NavigableSet</code>, который содержит все элементы первичного набора <code>NavigableSet</code>, начиная с <code>lowerBound</code>. Параметр <code>incl</code> при значении <code>true</code>, позволяет включить в выходной набор элемент <code>lowerBound</code></p>
</li>
<li>
<p><code>NavigableSet&lt;E&gt; subSet(E lowerBound, boolean lowerIncl, E upperBound, boolean highIncl)</code> возвращает объект <code>NavigableSet</code>, который содержит все элементы первичного набора <code>NavigableSet</code> от <code>lowerBound</code> до <code>upperBound</code>.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_treeset"><code>TreeSet</code></h5>
<div class="paragraph">
<p>Обобщенный класс <code>TreeSet&lt;E&gt;</code> представляет структуру данных в виде <strong>дерева</strong>, в котором все объекты хранятся в <strong>отсортированном виде по возрастанию</strong>. <code>TreeSet</code> является наследником класса <code>AbstractSet</code> и реализует интерфейс <code>NavigableSet</code>, а следовательно, и интерфейс <code>SortedSet</code>.</p>
</div>
<div class="paragraph">
<p>В классе <code>TreeSet</code> определены следующие конструкторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TreeSet()</code> создает пустое дерево</p>
</li>
<li>
<p><code>TreeSet(Collection&lt;? extends E&gt; col)</code> создает дерево, в которое добавляет все элементы коллекции <code>col</code></p>
</li>
<li>
<p><code>TreeSet(SortedSet &lt;E&gt; set)</code> создает дерево, в которое добавляет все элементы сортированного набора <code>set</code></p>
</li>
<li>
<p><code>TreeSet(Comparator&lt;? super E&gt; comparator)</code> создает пустое дерево, где все добавляемые элементы впоследствии будут отсортированы с помощью <code>comparator</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>TreeSet</code> поддерживает все стандартные методы для вставки и удаления элементов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.TreeSet;

public class Program {
    public static void main(String[] args) {
        TreeSet&lt;String&gt; states = new TreeSet&lt;String&gt;();

        // добавим в список ряд элементов
        states.add("Germany");
        states.add("France");
        states.add("Italy");
        states.add("Great Britain");

        System.out.printf("TreeSet contains %d elements \n", states.size());

        // удаление элемента
        states.remove("Germany");
        for (String state : states) {
            System.out.println(state);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>И поскольку при вставке объекты сразу же сортируются по возрастанию, то при выводе в цикле <code>for</code> мы получим отсортированный набор.</p>
</div>
<div class="paragraph">
<p>Так как <code>TreeSet</code> реализует интерфейс <code>NavigableSet</code>, а через него и <code>SortedSet</code>, то мы можем применить к структуре дерева различные методы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.NavigableSet;
import java.util.SortedSet;
import java.util.TreeSet;

public class Program {
    public static void main(String[] args) {
        TreeSet&lt;String&gt; states = new TreeSet&lt;String&gt;();

        // добавим в список ряд элементов
        states.add("Germany");
        states.add("France");
        states.add("Italy");
        states.add("Spain");
        states.add("Great Britain");

        System.out.println(states.first()); // получим первый - самый меньший элемент
        System.out.println(states.last()); // получим последний - самый больший элемент
        // получим поднабор от одного элемента до другого
        SortedSet&lt;String&gt; set = states.subSet("Germany", "Italy");
        System.out.println(set);
        // элемент из набора, который больше текущего
        String greater = states.higher("Germany");
        // элемент из набора, который меньше текущего
        String lower = states.lower("Germany");
        // возвращаем набор в обратном порядке
        NavigableSet&lt;String&gt; navSet = states.descendingSet();
        // возвращаем набор в котором все элементы меньше текущего
        SortedSet&lt;String&gt; setLower = states.headSet("Germany");
        // возвращаем набор в котором все элементы больше текущего
        SortedSet&lt;String&gt; setGreater = states.tailSet("Germany");
        System.out.println(navSet);
        System.out.println(setLower);
        System.out.println(setGreater);
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interface_map">8.10. Interface <code>Map</code></h3>
<div class="paragraph">
<p>Интерфейс <code>Map&lt;K, V&gt;</code> представляет <strong>отображение</strong> или иначе говоря <strong>словарь</strong>, где каждый элемент представляет пару <code>key</code>-<code>value</code>. При этом все ключи уникальные в рамках объекта <code>Map</code>. Такие коллекции облегчают поиск элемента, если нам известен <strong>ключ</strong> - уникальный идентификатор объекта.</p>
</div>
<div class="paragraph">
<p>Следует отметить, что в отличие от других интерфейсов, которые представляют коллекции, интерфейс <code>Map</code> <strong>НЕ расширяет</strong> интерфейс <code>Collection</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/assets/img/java/core/collections/java-map-hierarchy.png" alt="Java Map Hierarchy"></span></p>
</div>
<div class="paragraph">
<p>Среди методов интерфейса <code>Map</code> можно выделить следующие:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void clear()</code> очищает коллекцию</p>
</li>
<li>
<p><code>boolean containsKey(Object k)</code>: возвращает <code>true</code>, если коллекция содержит ключ <code>k</code></p>
</li>
<li>
<p><code>boolean containsValue(Object v)</code>: возвращает <code>true</code>, если коллекция содержит значение <code>v</code></p>
</li>
<li>
<p><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>: возвращает набор элементов коллекции. Все элементы представляют объект <code>Map.Entry</code></p>
</li>
<li>
<p><code>boolean equals(Object obj)</code> возвращает <code>true</code>, если коллекция идентична коллекции, передаваемой через параметр <code>obj</code></p>
</li>
<li>
<p><code>boolean isEmpty</code> возвращает <code>true</code>, если коллекция пуста</p>
</li>
<li>
<p><code>V get(Object k)</code> возвращает значение объекта, ключ которого равен <code>k</code>. Если такого элемента не окажется, то возвращается значение <code>null</code></p>
</li>
<li>
<p><code>V getOrDefault(Object k, V defaultValue)</code> возвращает значение объекта, ключ которого равен <code>k</code>. Если такого элемента не окажется, то возвращается значение <code>defaultVlue</code></p>
</li>
<li>
<p><code>V put(K k, V v)</code> помещает в коллекцию новый объект с ключом <code>k</code> и значением <code>v</code>. Если в коллекции уже есть объект с подобным ключом, то он перезаписывается. После добавления возвращает предыдущее значение для ключа <code>k</code>, если он уже был в коллекции. Если же ключа еще не было в коллекции, то возвращается значение <code>null</code></p>
</li>
<li>
<p><code>V putIfAbsent(K k, V v)</code> помещает в коллекцию новый объект с ключом <code>k</code> и значением <code>v</code>, если в коллекции еще нет элемента с подобным ключом.</p>
</li>
<li>
<p><code>Set&lt;K&gt; keySet()</code> возвращает набор всех ключей отображения</p>
</li>
<li>
<p><code>Collection&lt;V&gt; values()</code> возвращает набор всех значений отображения</p>
</li>
<li>
<p><code>void putAll(Map&lt;? extends K, ? extends V&gt; map)</code> добавляет в коллекцию все объекты из отображения <code>map</code></p>
</li>
<li>
<p><code>V remove(Object k)</code> удаляет объект с ключом <code>k</code></p>
</li>
<li>
<p><code>int size()</code> возвращает количество элементов коллекции</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Чтобы положить объект в коллекцию, используется метод <code>put()</code>, а чтобы получить по ключу - метод <code>get()</code>. Реализация интерфейса <code>Map</code> также позволяет получить наборы как ключей, так и значений. А метод <code>entrySet()</code> возвращает набор всех элементов в виде объектов <code>Map.Entry&lt;K, V&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Обобщенный интерфейс <code>Map.Entry&lt;K, V&gt;</code> представляет объект с ключом типа <code>K</code> и значением типа <code>V</code> и определяет следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boolean equals(Object obj)</code> возвращает <code>true</code>, если объект <code>obj</code>, представляющий интерфейс <code>Map.Entry</code>, идентичен текущему</p>
</li>
<li>
<p><code>K getKey()</code> возвращает ключ объекта отображения</p>
</li>
<li>
<p><code>V getValue()</code> возвращает значение объекта отображения</p>
</li>
<li>
<p><code>Set&lt;K&gt; keySet()</code> возвращает набор всех ключей отображения</p>
</li>
<li>
<p><code>V setValue(V v)</code> устанавливает для текущего объекта значение <code>v</code></p>
</li>
<li>
<p><code>int hashCode()</code> возвращает хеш-код данного объекта</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>При переборе объектов отображения мы будем оперировать этими методами для работы с ключами и значениями объектов.</p>
</div>
<div class="sect3">
<h4 id="_hashmap">8.10.1. <code>HashMap</code></h4>
<div class="paragraph">
<p>Базовым классом для всех отображений является абстрактный класс <code>AbstractMap</code>, который реализует большую часть методов интерфейса <code>Map</code>. Наиболее распространенным классом отображений является <code>HashMap</code>, который реализует интерфейс <code>Map</code> и наследуется от класса <code>AbstractMap</code>.</p>
</div>
<div class="paragraph">
<p>Пример использования класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class Program {
    public static void main(String[] args) {
        Map&lt;Integer, String&gt; states = new HashMap&lt;Integer, String&gt;();
        states.put(1, "Germany");
        states.put(2, "Spain");
        states.put(4, "France");
        states.put(3, "Italy");

        // получим объект по ключу 2
        String first = states.get(2);
        System.out.println(first);
        // получим весь набор ключей
        Set&lt;Integer&gt; keys = states.keySet();
        // получить набор всех значений
        Collection&lt;String&gt; values = states.values();
        //заменить элемент
        states.replace(1, "Poland");
        // удаление элемента по ключу 2
        states.remove(2);
        // перебор элементов
        for (Map.Entry&lt;Integer, String&gt; item : states.entrySet()) {
            System.out.printf("Key: %d  Value: %s \n", item.getKey(), item.getValue());
        }

        Map&lt;String, Person&gt; people = new HashMap&lt;String, Person&gt;();
        people.put("1240i54", new Person("Tom"));
        people.put("1564i55", new Person("Bill"));
        people.put("4540i56", new Person("Nick"));

        for (Map.Entry&lt;String, Person&gt; item : people.entrySet()) {
            System.out.printf("Key: %s  Value: %s \n", item.getKey(), item.getValue().getName());
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    String getName() {
        return this.name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы добавить или заменить элемент, используется метод <code>put()</code>, либо <code>replace()</code>, а чтобы получить его значение по ключу - метод <code>get()</code>. С помощью других методов интерфейса <code>Map</code> также производятся другие манипуляции над элементами:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>перебор</strong></p>
</li>
<li>
<p><strong>получение ключей</strong></p>
</li>
<li>
<p><strong>значений</strong></p>
</li>
<li>
<p><strong>удаление</strong></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interface_sortedmap">8.11. Interface <code>SortedMap</code></h3>
<div class="paragraph">
<p>Интерфейс <code>SortedMap</code> расширяет <code>Map</code> и создает отображение, в котором все элементы отсортированы в порядке возрастания их ключей. <code>SortedMap</code> добавляет ряд методов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>K firstKey()</code> возвращает ключ первого элемента отображения</p>
</li>
<li>
<p><code>K lastKey()</code> возвращает ключ последнего элемента отображения</p>
</li>
<li>
<p><code>SortedMap&lt;K, V&gt; headMap(K end)</code> возвращает отображение <code>SortedMap</code>, которые содержит все элементы оригинального <code>SortedMap</code> вплоть до элемента с ключом <code>end</code></p>
</li>
<li>
<p><code>SortedMap&lt;K, V&gt; tailMap(K start)</code> возвращает отображение <code>SortedMap</code>, которые содержит все элементы оригинального <code>SortedMap</code>, начиная с элемента с ключом <code>start</code></p>
</li>
<li>
<p><code>SortedMap&lt;K, V&gt; subMap(K start, K end)</code> возвращает отображение <code>SortedMap</code>, которые содержит все элементы оригинального <code>SortedMap</code> вплоть от элемента с ключом <code>start</code> до элемента с ключом <code>end</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_interface_navigablemap">8.11.1. Interface <code>NavigableMap</code></h4>
<div class="paragraph">
<p>Интерфейс <code>NavigableMap</code> расширяет интерфейс <code>SortedMap</code> и обеспечивает возможность получения элементов отображения относительно других элементов. Его основные методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Map.Entry&lt;K, V&gt; ceilingEntry(K obj)</code> возвращает элемент с наименьшим ключом <code>k</code>, который больше или равен ключу <code>obj</code> (<code>k</code> &gt;= <code>obj</code>). Если такого ключа нет, то возвращается <code>null</code></p>
</li>
<li>
<p><code>Map.Entry&lt;K, V&gt; floorEntry(K obj)</code> возвращает элемент с наибольшим ключом <code>k</code>, который меньше или равен ключу <code>obj</code> (<code>k</code> &#8656; <code>obj</code>). Если такого ключа нет, то возвращается <code>null</code></p>
</li>
<li>
<p><code>Map.Entry&lt;K, V&gt; higherEntry(K obj)</code> возвращает элемент с наименьшим ключом <code>k</code>, который больше ключа <code>obj</code> (<code>k</code> &gt;`obj`). Если такого ключа нет, то возвращается <code>null</code></p>
</li>
<li>
<p><code>Map.Entry&lt;K, V&gt; lowerEntry(K obj)</code> возвращает элемент с наибольшим ключом <code>k</code>, который меньше ключа <code>obj</code> (<code>k</code> &lt;`obj`). Если такого ключа нет, то возвращается <code>null</code></p>
</li>
<li>
<p><code>Map.Entry&lt;K, V&gt; firstEntry()</code> возвращает первый элемент отображения</p>
</li>
<li>
<p><code>Map.Entry&lt;K, V&gt; lastEntry()</code> возвращает последний элемент отображения</p>
</li>
<li>
<p><code>Map.Entry&lt;K, V&gt; pollFirstEntry()</code> возвращает и одновременно удаляет первый элемент из отображения</p>
</li>
<li>
<p><code>Map.Entry&lt;K, V&gt; pollLastEntry()</code> возвращает и одновременно удаляет последний элемент из отображения</p>
</li>
<li>
<p><code>K ceilingKey(K obj)</code> возвращает наименьший ключ <code>k</code>, который больше или равен ключу <code>obj</code> (<code>k</code> &gt;=<code>obj</code>). Если такого ключа нет, то возвращается <code>null</code></p>
</li>
<li>
<p><code>K floorKey(K obj)</code> возвращает наибольший ключ <code>k</code>, который меньше или равен ключу <code>obj</code> (<code>k</code> &#8656; <code>obj</code>). Если такого ключа нет, то возвращается <code>null</code></p>
</li>
<li>
<p><code>K lowerKey(K obj)</code> возвращает наибольший ключ <code>k</code>, который меньше ключа <code>obj</code> (<code>k</code> &lt;`obj`). Если такого ключа нет, то возвращается <code>null</code></p>
</li>
<li>
<p><code>K higherKey(K obj)</code> возвращает наименьший ключ <code>k</code>, который больше ключа <code>obj</code> (<code>k</code> &gt;`obj`). Если такого ключа нет, то возвращается <code>null</code></p>
</li>
<li>
<p><code>NavigableSet&lt;K&gt; descendingKeySet()</code> возвращает объект <code>NavigableSet</code>, который содержит все ключи отображения в обратном порядке</p>
</li>
<li>
<p><code>NavigableMap&lt;K, V&gt; descendingMap()</code> возвращает отображение <code>NavigableMap</code>, которое содержит все элементы в обратном порядке</p>
</li>
<li>
<p><code>NavigableSet&lt;K&gt; navigableKeySet()</code> возвращает объект <code>NavigableSet</code>, который содержит все ключи отображения</p>
</li>
<li>
<p><code>NavigableMap&lt;K, V&gt; headMap(K upperBound, boolean incl)</code> возвращает отображение <code>NavigableMap</code>, которое содержит все элементы оригинального <code>NavigableMap</code> вплоть от элемента с ключом <code>upperBound</code>. Параметр <code>incl</code> при значении <code>true</code> указывает, что элемент с ключом <code>upperBound</code> также включается в выходной набор.</p>
</li>
<li>
<p><code>NavigableMap&lt;K, V&gt; tailMap(K lowerBound, boolean incl)</code> возвращает отображение <code>NavigableMap</code>, которое содержит все элементы оригинального <code>NavigableMap</code>, начиная с элемента с ключом <code>lowerBound</code>. Параметр <code>incl</code> при значении <code>true</code> указывает, что элемент с ключом <code>lowerBound</code> также включается в выходной набор.</p>
</li>
<li>
<p><code>NavigableMap&lt;K, V&gt; subMap(K lowerBound, boolean lowIncl, K upperBound, boolean highIncl)</code> возвращает отображение <code>NavigableMap</code>, которое содержит все элементы оригинального <code>NavigableMap</code> от элемента с ключом <code>lowerBound</code> до элемента с ключом <code>upperBound</code>. Параметры <code>lowIncl</code> и <code>highIncl</code> при значении <code>true</code> включают в выходной набор элементы с ключами <code>lowerBound</code> и <code>upperBound</code> соответственно</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_treemap">8.11.2. <code>TreeMap</code></h4>
<div class="paragraph">
<p><code>Класс TreeMap&lt;K, V&gt;</code> представляет отображение в виде дерева. Он наследуется от класса <code>AbstractMap</code> и реализует интерфейс <code>NavigableMap</code>, а следовательно, также и интерфейс <code>SortedMap</code>. Поэтому в отличие от коллекции <code>HashMap</code> в <code>TreeMap</code> все объекты автоматически сортируются по возрастанию их ключей.</p>
</div>
<div class="paragraph">
<p>Класс <code>TreeMap</code> имеет следующие конструкторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TreeMap()</code> создает пустое отображение в виде дерева</p>
</li>
<li>
<p><code>TreeMap(Map&lt;K, ? extends V&gt; map)</code> создает дерево, в которое добавляет все элементы из отображения <code>map</code></p>
</li>
<li>
<p><code>TreeMap(SortedMap&lt;K, ? extends V&gt; smap)</code> создает дерево, в которое добавляет все элементы из отображения <code>smap</code></p>
</li>
<li>
<p><code>TreeMap(Comparator&lt;? super K&gt; comparator)</code> создает пустое дерево, где все добавляемые элементы впоследствии будут отсортированы компаратором.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Используем класс в программе:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

public class Program {
    public static void main(String[] args) {
        TreeMap&lt;Integer, String&gt; states = new TreeMap&lt;Integer, String&gt;();
        states.put(10, "Germany");
        states.put(2, "Spain");
        states.put(14, "France");
        states.put(3, "Italy");

        // получим объект по ключу 2
        String first = states.get(2);
        // перебор элементов
        for (Map.Entry&lt;Integer, String&gt; item : states.entrySet()) {
            System.out.printf("Key: %d  Value: %s \n", item.getKey(), item.getValue());
        }
        // получим весь набор ключей
        Set&lt;Integer&gt; keys = states.keySet();
        // получить набор всех значений
        Collection&lt;String&gt; values = states.values();

        // получаем все объекты, которые стоят после объекта с ключом 4
        Map&lt;Integer, String&gt; afterMap = states.tailMap(4);

        // получаем все объекты, которые стоят до объекта с ключом 10
        Map&lt;Integer, String&gt; beforeMap = states.headMap(10);

        // получим последний элемент дерева
        Map.Entry&lt;Integer, String&gt; lastItem = states.lastEntry();

        System.out.printf("Last item has key %d value %s \n", lastItem.getKey(), lastItem.getValue());

        Map&lt;String, Person&gt; people = new TreeMap&lt;String, Person&gt;();
        people.put("1240i54", new Person("Tom"));
        people.put("1564i55", new Person("Bill"));
        people.put("4540i56", new Person("Nick"));

        for (Map.Entry&lt;String, Person&gt; item : people.entrySet()) {
            System.out.printf("Key: %s  Value: %s \n", item.getKey(), item.getValue().getName());
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    String getName() {
        return name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Кроме собственно методов интерфейса <code>Map</code> класс <code>TreeMap</code> реализует методы интерфейса <code>NavigableMap</code>. Например, мы можем получить все объекты до или после определенного ключа с помощью методов <code>headMap()</code> и <code>tailMap()</code>. Также мы можем получить первый и последний элементы и провести ряд дополнительных манипуляций с объектами.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_java_functional_programming_jsr_335">9. Java Functional Programming (JSR 335)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_введение_stream_api">9.1. Введение Stream API</h3>
<div class="paragraph">
<p>Начиная с JDK 8 в Java появился новый API - <strong>Stream API</strong>. Его задача - упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными. Вся основная функциональность данного API сосредоточена в пакете <code>java.util.stream</code>.</p>
</div>
<div class="paragraph">
<p>Ключевым понятием в <strong>Stream API</strong> является <strong>поток данных</strong>. Вообще сам термин "поток" довольно перегружен в программировании в целом и в Java в частности. Применительно к <strong>Stream API</strong> поток представляет канал передачи данных из источника данных. Причем в качестве источника могут выступать как файлы, так и массивы и коллекции.</p>
</div>
<div class="paragraph">
<p>Одной из отличительных черт <strong>Stream API</strong> является применение лямбда-выражений, которые позволяют значительно сократить запись выполняемых действий.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/assets/img/java/core/java-stream.jpg" alt="Java Stream"></span></p>
</div>
<div class="paragraph">
<p>При ближайшем рассмотрении можно найти в других технологиях программирования аналоги подобного <strong>API</strong>. В частности, в языке <strong>C#</strong> некоторым аналогом <strong>Stream API</strong> будет технология <strong>LINQ</strong>.</p>
</div>
<div class="paragraph">
<p>Рассмотрим простейший пример. Допустим, у нас есть задача: найти в массиве количество всех чисел, которые больше <code>0</code>. До JDK 8 мы бы могли написать что-то наподобие следующего:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Test {
    public static void main(String[] args) {
        int[] numbers = {-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5};
        int count = 0;
        for (int i : numbers) {
            if (i &gt; 0) count++;
        }
        System.out.println(count);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь применим Stream API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.stream.IntStream;

public class Test {
    public static void main(String[] args) {
        long count = IntStream.of(-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5)
            .filter(w -&gt; w &gt; 0)
            .count();
        System.out.println(count);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь вместо цикла и кучи условных конструкций, которые мы бы использовали до JDK 8, мы можем записать цепочку методов, которые будут выполнять те же действия.</p>
</div>
<div class="paragraph">
<p>При работе со Stream API важно понимать, что все операции с потоками бывают либо <strong>терминальными</strong> (<strong>terminal</strong>), либо <strong>промежуточными</strong> (<strong>intermediate</strong>). Промежуточные операции возвращают трансформированный поток. Например, выше в примере метод <code>filter</code> принимал поток чисел и возвращал уже преобразованный поток, в котором только числа больше <code>0</code>. К возвращенному потоку также можно применить ряд промежуточных операций.</p>
</div>
<div class="paragraph">
<p>Терминальные операции возвращают конкретный результат. Например, в примере выше метод <code>count()</code> представляет терминальную операцию и возвращает число. После этого никаких промежуточных операций естественно применять нельзя.</p>
</div>
<div class="paragraph">
<p>Все потоки производят вычисления, в том числе в промежуточных операциях, только тогда, когда к ним применяется терминальная операция. То есть в данном случае применяется отложенное выполнение.</p>
</div>
<div class="paragraph">
<p>В основе Stream API лежит интерфейс <code>BaseStream</code>. Его полное определение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">interface BaseStream&lt;T , S extends BaseStream&lt;T , S&gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь параметр <code>T</code> означает тип данных в потоке, а <code>S</code> - тип потока, который наследуется от интерфейса <code>BaseStream</code>.</p>
</div>
<div class="paragraph">
<p><code>BaseStream</code> определяет базовый функционал для работы с потоками, которые реализуется через его методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void close()</code> закрывает поток</p>
</li>
<li>
<p><code>boolean isParallel()</code> возвращает true, если поток является параллельным</p>
</li>
<li>
<p><code>Iterator&lt;Т&gt; iterator()</code> возвращает ссылку на итератор потока</p>
</li>
<li>
<p><code>Spliterator&lt;Т&gt; spliterator()</code> возвращает ссылку на сплитератор потока</p>
</li>
<li>
<p><code>S parallel()</code> возвращает параллельный поток (параллельные потоки могут задействовать несколько ядер процессора в многоядерных архитектурах)</p>
</li>
<li>
<p><code>S sequential()</code> возвращает последовательный поток</p>
</li>
<li>
<p><code>S unordered()</code> возвращает неупорядоченный поток</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>От интерфейса BaseStream наследуется ряд интерфейсов, предназначенных для создания конкретных потоков:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Stream&lt;T&gt;</code> используется для потоков данных, представляющих любой ссылочный тип</p>
</li>
<li>
<p><code>IntStream</code> используется для потоков с типом данных <code>int</code></p>
</li>
<li>
<p><code>DoubleStream</code> используется для потоков с типом данных <code>double</code></p>
</li>
<li>
<p><code>LongStream</code> используется для потоков с типом данных <code>long</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>При работе с потоками, которые представляют определенный примитивный тип - <code>double</code>, <code>int</code>, <code>long</code> проще использовать интерфейсы <code>DoubleStream</code>, <code>IntStream</code>, <code>LongStream</code>. Но в большинстве случаев, как правило, работа происходит с более сложными данными, для которых предназначен интерфейс <code>Stream&lt;T&gt;</code>. Рассмотрим некоторые его методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boolean allMatch(Predicate&lt;? super T&gt; predicate)</code> возвращает <code>true</code>, если все элементы потока удовлетворяют условию в предикате</p>
</li>
<li>
<p><code>boolean anyMatch(Predicate&lt;? super T&gt; predicate)</code> возвращает <code>true</code>, если хоть один элемент потока удовлетворяют условию в предикате</p>
</li>
<li>
<p><code>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)</code> добавляет элементы в неизменяемый контейнер с типом <code>R</code>. <code>T</code> представляет тип данных из вызывающего потока, а <code>A</code> - тип данных в контейнере</p>
</li>
<li>
<p><code>long count()</code> возвращает количество элементов в потоке</p>
</li>
<li>
<p><code>Stream&lt;T&gt; concat|(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code> объединяет два потока</p>
</li>
<li>
<p><code>Stream&lt;T&gt; distinct()</code> возвращает поток, в котором имеются только уникальные данные с типом <code>T</code></p>
</li>
<li>
<p><code>Stream&lt;T&gt; dropWhile​(Predicate&lt;? super T&gt; predicate)</code> пропускает элементы, которые соответствуют условию в <code>predicate</code>, пока не попадется элемент, который не соответствует условию. Выбранные элементы возвращаются в виде потока</p>
</li>
<li>
<p><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code> фильтрует элементы в соответствии с условием в предикате</p>
</li>
<li>
<p><code>Optional&lt;T&gt; findFirst()</code> возвращает первый элемент из потока</p>
</li>
<li>
<p><code>Optional&lt;T&gt; findAny()</code> возвращает первый попавшийся элемент из потока</p>
</li>
<li>
<p><code>void forEach(Consumer&lt;? super T&gt; action)</code> для каждого элемента выполняется действие <code>action</code></p>
</li>
<li>
<p><code>Stream&lt;T&gt; limit(long maxSize)</code> оставляет в потоке только <code>maxSize</code> элементов</p>
</li>
<li>
<p><code>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</code> возвращает максимальный элемент из потока. Для сравнения элементов применяется компаратор comparator</p>
</li>
<li>
<p><code>Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator)</code> возвращает минимальный элемент из потока. Для сравнения элементов применяется компаратор comparator</p>
</li>
<li>
<p><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)</code> преобразует элементы типа <code>T</code> в элементы типа <code>R</code> и возвращает поток с элементами <code>R</code></p>
</li>
<li>
<p><code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</code> позволяет преобразовать элемент типа <code>T</code> в несколько элементов типа <code>R</code> и возвращает поток с элементами <code>R</code></p>
</li>
<li>
<p><code>boolean noneMatch(Predicate&lt;? super T&gt; predicate)</code> возвращает true, если ни один из элементов в потоке не удовлетворяет условию в предикате</p>
</li>
<li>
<p><code>Stream&lt;T&gt; skip(long n)</code> возвращает поток, в котором отсутствуют первые n элементов</p>
</li>
<li>
<p><code>Stream&lt;T&gt; sorted()</code> возвращает отсортированный поток</p>
</li>
<li>
<p><code>Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)</code> возвращает отсортированный в соответствии с компаратором поток</p>
</li>
<li>
<p><code>Stream&lt;T&gt; takeWhile​(Predicate&lt;? super T&gt; predicate)</code> выбирает из потока элементы, пока они соответствуют условию в <code>predicate</code>. Выбранные элементы возвращаются в виде потока</p>
</li>
<li>
<p><code>Object[] toArray()</code> возвращает массив из элементов потока</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Несмотря на то, что все эти операции позволяют взаимодействовать с потоком как неким набором данных наподобие коллекции, важно понимать отличие коллекций от потоков:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>потоки не хранят элементы. Элементы, используемые в потоках, могут храниться в коллекции, либо при необходимости могут быть напрямую сгенерированы</p>
</li>
<li>
<p>операции с потоками не изменяют источника данных. Операции с потоками лишь возвращают новый поток с результатами этих операций</p>
</li>
<li>
<p>для потоков характерно отложенное выполнение. То есть выполнение всех операций с потоком происходит лишь тогда, когда выполняется терминальная операция и возвращается конкретный результат, а не новый поток
= Встроенные функциональные интерфейсы</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В JDK 8 вместе с самой функциональностью лямбда-выражений также было добавлено некоторое количество встроенных функциональных интерфейсов, которые мы можем использовать в различных ситуациях и в различные API в рамках JDK 8. В частности, ряд далее рассматриваемых интерфейсов широко применяется в <code>Stream API</code> - новом прикладном интерфейсе для работы с данными. Рассмотрим основные из этих интерфейсов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Predicate&lt;T&gt;</code></p>
</li>
<li>
<p><code>Consumer&lt;T&gt;</code></p>
</li>
<li>
<p><code>Function&lt;T, R&gt;</code></p>
</li>
<li>
<p><code>Supplier&lt;T&gt;</code></p>
</li>
<li>
<p><code>UnaryOperator&lt;T&gt;</code></p>
</li>
<li>
<p><code>BinaryOperator&lt;T&gt;</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_predicatet">9.1.1. <code>Predicate&lt;T&gt;</code></h4>
<div class="paragraph">
<p>Функциональный интерфейс <code>Predicate&lt;T&gt;</code> проверяет соблюдение некоторого условия. Если оно соблюдается, то возвращается значение <code>true</code>. В качестве параметра лямбда-выражение принимает объект типа <code>T</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public interface Predicate&lt;T&gt; {
    boolean test(T t);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.function.Predicate;

public class LambdaApp {
    public static void main(String[] args) {
        Predicate&lt;Integer&gt; isPositive = x -&gt; x &gt; 0;

        System.out.println(isPositive.test(5)); // true
        System.out.println(isPositive.test(-7)); // false
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_binaryoperatort">9.1.2. <code>BinaryOperator&lt;T&gt;</code></h4>
<div class="paragraph">
<p><code>BinaryOperator&lt;T&gt;</code> принимает в качестве параметра два объекта типа <code>T</code>, выполняет над ними бинарную операцию и возвращает ее результат также в виде объекта типа <code>T</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public interface BinaryOperator&lt;T&gt; {
    T apply(T t1, T t2);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.function.BinaryOperator;

public class LambdaApp {
    public static void main(String[] args) {
        BinaryOperator&lt;Integer&gt; multiply = (x, y) -&gt; x * y;

        System.out.println(multiply.apply(3, 5)); // 15
        System.out.println(multiply.apply(10, -2)); // -20
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_unaryoperatort">9.1.3. <code>UnaryOperator&lt;T&gt;</code></h4>
<div class="paragraph">
<p><code>UnaryOperator&lt;T&gt;</code> принимает в качестве параметра объект типа <code>T</code>, выполняет над ними операции и возвращает результат операций в виде объекта типа <code>T</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public interface UnaryOperator&lt;T&gt; {
    T apply(T t);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.function.UnaryOperator;

public class LambdaApp {
    public static void main(String[] args) {
        UnaryOperator&lt;Integer&gt; square = x -&gt; x * x;
        System.out.println(square.apply(5)); // 25
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_functiont_r">9.1.4. <code>Function&lt;T, R&gt;</code></h4>
<div class="paragraph">
<p>Функциональный интерфейс <code>Function&lt;T, R&gt;</code> представляет функцию перехода от объекта типа <code>T</code> к объекту типа <code>R</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public interface Function&lt;T, R&gt; {
    R apply(T t);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.function.Function;

public class LambdaApp {
    public static void main(String[] args) {
        Function&lt;Integer, String&gt; convert = x -&gt; String.valueOf(x) + " долларов";
        System.out.println(convert.apply(5)); // 5 долларов
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_consumert">9.1.5. <code>Consumer&lt;T&gt;</code></h4>
<div class="paragraph">
<p><code>Consumer&lt;T&gt;</code> выполняет некоторое действие над объектом типа <code>T</code>, при этом ничего не возвращая:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public interface Consumer&lt;T&gt; {
    void accept(T t);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.function.Consumer;

public class LambdaApp {
    public static void main(String[] args) {
        Consumer&lt;Integer&gt; printer = x -&gt; System.out.printf("%d долларов \n", x);
        printer.accept(600); // 600 долларов
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_suppliert">9.1.6. <code>Supplier&lt;T&gt;</code></h4>
<div class="paragraph">
<p><code>Supplier&lt;T&gt;</code> не принимает никаких аргументов, но должен возвращать объект типа <code>T</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public interface Supplier&lt;T&gt; {
    T get();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.Scanner;
import java.util.function.Supplier;

public class LambdaApp {
    public static void main(String[] args) {
        Supplier&lt;User&gt; userFactory = () -&gt; {
            Scanner in = new Scanner(System.in);
            System.out.println("Введите имя: ");
            String name = in.nextLine();
            return new User(name);
        };

        User user1 = userFactory.get();
        User user2 = userFactory.get();

        System.out.println("Имя user1: " + user1.getName());
        System.out.println("Имя user2: " + user2.getName());
    }
}

class User {
    private String name;

    String getName() {
        return name;
    }

    User(String n) {
        this.name = n;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_создание_потока_данных">9.2. Создание потока данных</h3>
<div class="paragraph">
<p>Для создания потока данных можно применять различные методы. В качестве источника потока мы можем использовать коллекции. В частности, в JDK 8 в интерфейс <code>Collection</code>, который реализуется всеми классами коллекций, были добавлены два метода для работы с потоками:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>default Stream&lt;E&gt; stream</code> возвращается поток данных из коллекции</p>
</li>
<li>
<p><code>default Stream&lt;E&gt; parallelStream</code> возвращается параллельный поток данных из коллекции</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Так, рассмотрим пример с <code>ArrayList</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.ArrayList;
import java.util.Collections;

public class Test {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; cities = new ArrayList&lt;String&gt;();
        Collections.addAll(cities, "Париж", "Лондон", "Мадрид");
        cities.stream() // получаем поток
                .filter(s -&gt; s.length() == 6) // применяем фильтрацию по длине строки
                .forEach(s -&gt; System.out.println(s)); // выводим отфильтрованные строки на консоль
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь с помощью вызова <code>cities.stream()</code> получаем поток, который использует данные из списка <code>cities</code>. С помощью каждой промежуточной операции, которая применяется к потоку, мы также можем получить поток с учетом модификаций. Например, мы можем изменить предыдущий пример следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.Stream;

public class Test {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; cities = new ArrayList&lt;String&gt;();
        Collections.addAll(cities, "Париж", "Лондон", "Мадрид");
        Stream&lt;String&gt; citiesStream = cities.stream(); // получаем поток
        citiesStream = citiesStream.filter(s -&gt; s.length() == 6); // применяем фильтрацию по длине строки
        citiesStream.forEach(s -&gt; System.out.println(s)); // выводим отфильтрованные строки на консоль
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Важно, что после использования терминальных операций другие терминальные или промежуточные операции к этому же потоку не могут быть применены, поток уже употреблен. Например, в следующем случае мы получим ошибку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">citiesStream.forEach(s -&gt; System.out.println(s)); // терминальная операция употребляет поток
long number = citiesStream.count(); // здесь ошибка, так как поток уже употреблен
System.out.println(number);
citiesStream = citiesStream.filter(s -&gt; s.length() &gt; 5); // тоже нельзя, так как поток уже употреблен</code></pre>
</div>
</div>
<div class="paragraph">
<p>Фактически жизненный цикл потока проходит следующие три стадии:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>создание потока</p>
</li>
<li>
<p>применение к потоку ряда промежуточных операций</p>
</li>
<li>
<p>применение к потоку терминальной операции и получение результата</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Кроме вышерассмотренных методов мы можем использовать еще ряд способов для создания потока данных. Один из таких способов представляет метод <code>Arrays.stream(T[] array)</code>, который создает поток данных из массива:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;String&gt; citiesStream = Arrays.stream(new String[]{"Париж", "Лондон", "Мадрид"}) ;
citiesStream.forEach(s -&gt; System.out.println(s)); // выводим все элементы массива</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для создания потоков <code>IntStream</code>, <code>DoubleStream</code>, <code>LongStream</code> можно использовать соответствующие перегруженные версии этого метода:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">IntStream intStream = Arrays.stream(new int[]{1, 2, 4, 5, 7});
intStream.forEach(i -&gt; System.out.println(i));

LongStream longStream = Arrays.stream(new long[]{100, 250, 400, 5843787, 237});
longStream.forEach(l -&gt; System.out.println(l));

DoubleStream doubleStream = Arrays.stream(new double[]{3.4, 6.7, 9.5, 8.2345, 121});
doubleStream.forEach(d -&gt; System.out.println(d));</code></pre>
</div>
</div>
<div class="paragraph">
<p>И еще один способ создания потока представляет статический метод <code>of(T..values)</code> класса <code>Stream</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;String&gt; citiesStream = Stream.of("Париж", "Лондон", "Мадрид");
citiesStream.forEach(s -&gt; System.out.println(s));

// можно передать массив
String[] cities = {"Париж", "Лондон", "Мадрид"};
Stream&lt;String&gt; citiesStream2 = Stream.of(cities);

IntStream intStream = IntStream.of(1, 2, 4, 5, 7);
intStream.forEach(i -&gt; System.out.println(i));

LongStream longStream = LongStream.of(100, 250, 400, 5843787, 237);
longStream.forEach(l -&gt; System.out.println(l));

DoubleStream doubleStream = DoubleStream.of(3.4, 6.7, 9.5, 8.2345, 121);
doubleStream.forEach(d -&gt; System.out.println(d));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_фильтрация_перебор_элементов_и_отображение">9.3. Фильтрация, перебор элементов и отображение</h3>
<div class="sect3">
<h4 id="_foreach">9.3.1. <code>forEach()</code></h4>
<div class="paragraph">
<p>Для перебора элементов потока применяется метод <code>forEach()</code>, который представляет терминальную операцию. В качестве параметра он принимает объект <code>Consumer&lt;? super String&gt;</code>, который представляет действие, выполняемое для каждого элемента набора. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;String&gt; citiesStream = Stream.of("Париж", "Лондон", "Мадрид","Берлин", "Брюссель");
citiesStream.forEach(s -&gt; System.out.println(s));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Фактически это будет аналогично перебору всех элементов в цикле <code>for</code> и выполнению с ними действия, а именно вывод на консоль. В итоге консоль выведет:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Париж
Лондон
Мадрид
Берлин
Брюссель</code></pre>
</div>
</div>
<div class="paragraph">
<p>Кстати мы можем сократить в данном случае применение метода <code>forEach</code> следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;String&gt; citiesStream = Stream.of("Париж", "Лондон", "Мадрид","Берлин", "Брюссель");
citiesStream.forEach(System.out::println);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Фактически здесь переадается ссылка на статический метод, который выводит строку на консоль.</p>
</div>
</div>
<div class="sect3">
<h4 id="_filter">9.3.2. <code>filter()</code></h4>
<div class="paragraph">
<p>Для фильтрации элементов в потоке применяется метод <code>filter()</code>, который представляет промежуточную операцию. Он принимает в качестве параметра некоторое условие в виде объекта <code>Predicate&lt;T&gt;</code> и возвращает новый поток из элементов, которые удовлетворяют этому условию:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;String&gt; citiesStream = Stream.of("Париж", "Лондон", "Мадрид","Берлин", "Брюссель");
citiesStream.filter(s -&gt; s.length() == 6).forEach(s -&gt; System.out.println(s));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь условие <code>s.length() == 6</code> возвращает <code>true</code> для тех элементов, длина которых равна <code>6</code> символам. То есть в итоге программа выведет:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Лондон
Мадрид
Берлин</code></pre>
</div>
</div>
<div class="paragraph">
<p>Рассмотрим еще один пример фильтрации с более сложными данными. Допустим, у нас есть следующий класс <code>Phone</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Phone {
    private String name;
    private int price;

    public Phone(String name, int price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Отфильтруем набор телефонов по цене:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;Phone&gt; phoneStream = Stream.of(
    new Phone("iPhone 6 S", 54000),
    new Phone("Lumia 950", 45000),
    new Phone("Samsung Galaxy S 6", 40000)
);

phoneStream.filter(p -&gt; p.getPrice() &lt; 50000)
        .forEach(p -&gt; System.out.println(p.getName()));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_map">9.3.3. <code>map()</code></h4>
<div class="paragraph">
<p>Отображение или маппинг позволяет задать функцию преобразования одного объекта в другой, то есть получить из элемента одного типа элемент другого типа. Для отображения используется метод <code>map()</code>, который имеет следующее определение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Передаваемая в метод <code>map()</code> функция задает преобразование от объектов типа <code>T</code> к типу <code>R</code>. И в результате возвращается новый поток с преобразованными объектами.</p>
</div>
<div class="paragraph">
<p>Возьмем вышеопределенный класс телефонов и выполним преобразование от типа <code>Phone</code> к типу <code>String</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;Phone&gt; phoneStream = Stream.of(
    new Phone("iPhone 6 S", 54000),
    new Phone("Lumia 950", 45000),
    new Phone("Samsung Galaxy S 6", 40000)
);
phoneStream.map(p -&gt; p.getName()) // помещаем в поток только названия телефонов
        .forEach(s -&gt; System.out.println(s));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Операция <code>map(p &#8594; p.getName())</code> помещает в новый поток только названия телефонов. В итоге на консоли будут только названия:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">iPhone 6 S
Lumia 950
Samsung Galaxy S 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>Еще проведем преобразования:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">phoneStream
        .map(p -&gt; "название: " + p.getName() + " цена: " + p.getPrice())
        .forEach(s -&gt; System.out.println(s));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь также результирующий поток содержит только строки, только теперь названия соединяются с ценами.</p>
</div>
<div class="paragraph">
<p>Для преобразования объектов в типы <code>Integer</code>, <code>Long</code>, <code>Double</code> определены специальные методы <code>mapToInt()</code>, <code>mapToLong()</code> и <code>mapToDouble()</code> соответственно.</p>
</div>
</div>
<div class="sect3">
<h4 id="_flatmap">9.3.4. <code>flatMap()</code></h4>
<div class="paragraph">
<p>Плоское отображение выполняется тогда, когда из одного элемента нужно получить несколько. Данную операцию выполняет метод <code>flatMap</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например, в примере выше мы выводим название телефона и его цену. Но что, если мы хотим установить для каждого телефона цену со скидкой и цену без скидки. То есть из одного объекта <code>Phone</code> нам надо получить два объекта с информацией, например, в виде строки. Для этого применим <code>flatMap</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;Phone&gt; phoneStream = Stream.of(
    new Phone("iPhone 6 S", 54000),
    new Phone("Lumia 950", 45000),
    new Phone("Samsung Galaxy S 6", 40000)
);

phoneStream
        .flatMap(p -&gt; Stream.of(
                String.format("название: %s  цена без скидки: %d", p.getName(), p.getPrice()),
                String.format("название: %s  цена со скидкой: %d", p.getName(), p.getPrice() - (int) (p.getPrice() * 0.1))
        ))
        .forEach(s -&gt; System.out.println(s));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Результат работы программы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">название: iPhone 6 S цена без скидки: 54000
название: iPhone 6 S цена со скидкой: 48600
название: Lumia 950 цена без скидки: 45000
название: Lumia 950 цена со скидкой: 40500
название: Samsung Galaxy S 6 цена без скидки: 40000
название: Samsung Galaxy S 6 цена со скидкой: 36000</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sorted">9.4. <code>sorted()</code></h3>
<div class="paragraph">
<p>Коллекции, на основе которых нередко создаются потоки, уже имеют специальные методы для сортировки содержимого. Однако класс <code>Stream</code> также включает возможность сортировки. Такую сортировку мы можем задействовать, когда у нас идет набор промежуточных операций с потоком, которые создают новые наборы данных, и нам надо эти наборы отсортировать.</p>
</div>
<div class="paragraph">
<p>Для простой сортировки по возрастанию применяется метод <code>sorted()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Program {
    public static void main(String[] args) {
        List&lt;String&gt; phones = new ArrayList&lt;String&gt;();
        Collections.addAll(phones, "iPhone X", "Nokia 9", "Huawei Nexus 6P",
                "Samsung Galaxy S8", "LG G6", "Xiaomi MI6",
                "ASUS Zenfone 3", "Sony Xperia Z5", "Meizu Pro 6",
                "Pixel 2");

        phones.stream()
                .filter(p -&gt; p.length() &lt; 12)
                .sorted() // сортировка по возрастанию
                .forEach(s -&gt; System.out.println(s));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Консольный вывод после сортировки объектов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="sh">LG G6
Meizu Pro 6
Nokia 9
Pixel 2
Xiaomi MI6
iPhone X</code></pre>
</div>
</div>
<div class="paragraph">
<p>Однако данный метод не всегда подходит. Уже по консольному выводу мы видим, что метод сортирует объекты по возрастанию, но при этом заглавные и строчные буквы рассматриваются отдельно.</p>
</div>
<div class="paragraph">
<p>Кроме того, данный метод подходит только для сортировки тех объектов, которые реализуют интерфейс <code>Comparable</code>.</p>
</div>
<div class="paragraph">
<p>Если же у нас классы объектов не реализуют этот интерфейс или мы хотим создать какую-то свою логику сортировки, то мы можем использовать другую версию метода <code>sorted()</code>, которая в качестве параметра принимает компаратор.</p>
</div>
<div class="paragraph">
<p>Например, пусть у нас есть следующий класс <code>Phone</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Phone {
    private String name;
    private String company;
    private int price;

    public Phone(String name, String comp, int price) {
        this.name = name;
        this.company = comp;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public int getPrice() {
        return price;
    }

    public String getCompany() {
        return company;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Отсортируем поток обектов <code>Phone</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.Comparator;
import java.util.stream.Stream;

public class Program {
    public static void main(String[] args) {
        Stream&lt;Phone&gt; phoneStream = Stream.of(new Phone("iPhone X", "Apple", 600),
            new Phone("Pixel 2", "Google", 500),
            new Phone("iPhone 8", "Apple",450),
            new Phone("Nokia 9", "HMD Global",150),
            new Phone("Galaxy S9", "Samsung", 300));

        phoneStream.sorted(new PhoneComparator())
                .forEach(p-&gt;System.out.printf("%s (%s) - %d \n",
                        p.getName(), p.getCompany(), p.getPrice()));
    }
}

class PhoneComparator implements Comparator&lt;Phone&gt; {
    public int compare(Phone a, Phone b) {
        return a.getName().toUpperCase().compareTo(b.getName().toUpperCase());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь определен класс компаратора <code>PhoneComparator</code>, который сортирует объекты по полю <code>name</code>. В итоге мы получим следующий вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="sh">Galaxy S9 (Samsung) - 300
iPhone 8 (Apple) - 450
iPhone X (Apple) - 600
Nokia 9 (HMD Global) - 150
Pixel 2 (Google) - 500</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_получение_подпотока_и_объединение_потоков">9.5. Получение подпотока и объединение потоков</h3>
<div class="paragraph">
<p>Ряд методов Stream API возвращают подпотоки или объединенные потоки на основе уже имеющихся потоков. Рассмотрим эти методы.</p>
</div>
<div class="sect3">
<h4 id="_takewhile">9.5.1. <code>takeWhile()</code></h4>
<div class="paragraph">
<p>Метод <code>takeWhile()</code> выбирает из потока элементы, пока они соответствуют условию. Если попадается элемент, который не соответствует условию, то метод завершает свою работу. Выбранные элементы возвращаются в виде потока.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.stream.Stream;

public class Program {
    public static void main(String[] args) {
        Stream&lt;Integer&gt; numbers = Stream.of(-3, -2, -1, 0, 1, 2, 3, -4, -5);
        numbers.takeWhile(n -&gt; n &lt; 0)
            .forEach(n -&gt; System.out.println(n));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае программа выбирает из потока числа, пока они меньше нуля. Консольный вывод программы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">-3
-2
-1</code></pre>
</div>
</div>
<div class="paragraph">
<p>При этом несмотря на то, что в потоке больше отрицательных чисел, но метод завершает работу, как только обнаружит первое число, которое не соответствует условию. В этом и состоит отличие, например, от метода <code>filter()</code>.</p>
</div>
<div class="paragraph">
<p>Чтобы в данном случае охватить все элементы, которые меньше нуля, поток следует предварительно отсортировать:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;Integer&gt; numbers = Stream.of(-3, -2, -1, 0, 1, 2, 3, -4, -5);
numbers.sorted().takeWhile(n -&gt; n &lt; 0)
        .forEach(n -&gt; System.out.println(n));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Консольный вывод программы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">-5
-4
-3
-2
-1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dropwhile">9.5.2. <code>dropWhile()</code></h4>
<div class="paragraph">
<p>Метод <code>dropWhile()</code> выполняет обратную задачу - он пропускает элементы потока, которые соответствуют условию до тех пор, пока не встретит элемент, который НЕ соответствует условию:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;Integer&gt; numbers = Stream.of(-3, -2, -1, 0, 1, 2, 3, -4, -5);
numbers.sorted().dropWhile(n -&gt; n &lt; 0)
    .forEach(n -&gt; System.out.println(n));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Консольный вывод программы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">0
1
2
3</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_stream_concat">9.5.3. <code>Stream.concat()</code></h4>
<div class="paragraph">
<p>Статический метод <code>concat()</code> объединяет элементы двух потоков, возвращая объединенный поток:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.stream.Stream;

public class Program {
    public static void main(String[] args) {
        Stream&lt;String&gt; people1 = Stream.of("Tom", "Bob", "Sam");
        Stream&lt;String&gt; people2 = Stream.of("Alice", "Kate", "Sam");
        Stream.concat(people1, people2).forEach(n -&gt; System.out.println(n));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Консольный вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Tom
Bob
Sam
Alice
Kate
Sam</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_distinct">9.5.4. <code>distinct()</code></h4>
<div class="paragraph">
<p>Метод <code>distinct()</code> возвращает только ункальные элементы в виде потока:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;String&gt; people = Stream.of("Tom", "Bob", "Sam", "Tom", "Alice", "Kate", "Sam");
people.distinct().forEach(p -&gt; System.out.println(p));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Консольный вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Tom
Bob
Sam
Alice
Kate</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_skip_и_limit">9.6. <code>skip()</code> и <code>limit()</code></h3>
<div class="paragraph">
<p>Метод <code>skip(long n)</code> используется для пропуска <code>n</code> элементов. Этот метод возвращает новый поток, в котором пропущены первые <code>n</code> элементов.</p>
</div>
<div class="paragraph">
<p>Метод <code>limit(long n)</code> применяется для выборки первых <code>n</code> элементов потоков. Этот метод также возвращает модифицированный поток, в котором не более <code>n</code> элементов.</p>
</div>
<div class="paragraph">
<p>Зачастую эта пара методов используется вместе для создания эффекта постраничной навигации. Рассмотрим, как их применять:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;String&gt; phoneStream = Stream.of("iPhone 6 S", "Lumia 950", "Samsung Galaxy S 6", "LG G 4", "Nexus 7");

phoneStream.skip(1)
    .limit(2)
    .forEach(s -&gt; System.out.println(s));</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае метод <code>skip()</code> пропускает один первый элемент, а метод <code>limit()</code> выбирает два следующих элемента. В итоге мы получим следующий консольный вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Lumia 950
Samsung Galaxy S 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вполне может быть, что метод <code>skip()</code> может принимать в качестве параметра число большее, чем количество элементов в потоке. В этом случае будут пропущены все элементы, а в результирующем потоке будет <code>0</code> элементов.</p>
</div>
<div class="paragraph">
<p>И если в метод <code>limit()</code> передается число, большее, чем количество элементов, то просто выбираются все элементы потока.</p>
</div>
<div class="paragraph">
<p>Теперь рассмотрим, как создать постраничную навигацию:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.*;
import java.util.Scanner;

public class Program {
    public static void main(String[] args) {
        List&lt;String&gt; phones = new ArrayList&lt;String&gt;();
        phones.addAll(Arrays.asList(new String[]
                {"iPhone 6 S", "Lumia 950", "Huawei Nexus 6P",
                "Samsung Galaxy S 6", "LG G 4", "Xiaomi MI 5",
                "ASUS Zenfone 2", "Sony Xperia Z5", "Meizu Pro 5",
                "Lenovo S 850"}));

        int pageSize = 3; // количество элементов на страницу
        Scanner scanner = new Scanner(System.in);
        while(true) {
            System.out.println("Введите номер страницы: ");
            int page = scanner.nextInt();

            if(page &lt; 1) {
                break; // если число меньше 1, выходим из цикла
            }

            phones.stream().skip((page - 1) * pageSize)
                .limit(pageSize)
                .forEach(s -&gt; System.out.println(s));
       }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае у нас набор из 10 элементов. С помощью переменной <code>pageSize</code> определяем количество элементов на странице - <code>3</code>. То есть у нас получится <code>4</code> страницы (на последней будет только один элемент).</p>
</div>
<div class="paragraph">
<p>В бесконечном цикле получаем номер страницы и выбираем только те элементы, которые находятся на указанной странице.</p>
</div>
<div class="paragraph">
<p>Теперь введем какие-нибудь номера страниц, например, <code>4</code> и <code>2</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Введите номер страницы:
4
Lenovo S 850
Введите номер страницы:
2
Samsung Galaxy S 6
LG G 4
Xiaomi MI 5</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_операции_сведения">9.7. Операции сведения</h3>
<div class="paragraph">
<p>Операции сведения представляют терминальные операции, которые возвращают некоторое значение - результат операции. В Stream API есть ряд операций сведения.</p>
</div>
<div class="sect3">
<h4 id="_count">9.7.1. <code>count()</code></h4>
<div class="paragraph">
<p>Метод <code>count()</code> возвращает количество элементов в потоке данных:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.stream.Stream;
import java.util.Optional;
import java.util.*;
public class Program {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;();
        names.addAll(Arrays.asList(new String[]{"Tom", "Sam", "Bob", "Alice"}));
        System.out.println(names.stream().count()); // 4

        // количество элементов с длиной не больше 3 символов
        System.out.println(names.stream()
                .filter(n -&gt; n.length() &lt;= 3)
                .count());  // 3
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_findfirst_и_findany">9.7.2. <code>findFirst()</code> и <code>findAny()</code></h4>
<div class="paragraph">
<p>Метод <code>findFirst()</code> извлекает из потока первый элемент, а <code>findAny()</code> извлекает случайный объект из потока (нередко так же первый):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;();
names.addAll(Arrays.asList(new String[]{"Tom", "Sam", "Bob", "Alice"}));

Optional&lt;String&gt; first = names.stream().findFirst();
System.out.println(first.get()); // Tom

Optional&lt;String&gt; any = names.stream().findAny();
System.out.println(first.get()); // Tom</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_allmatch_anymatch_nonematch">9.7.3. <code>allMatch()</code>, <code>anyMatch()</code>, <code>noneMatch()</code></h4>
<div class="paragraph">
<p>Еще одна группа операций сведения возвращает логическое значение <code>true</code> или <code>false</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boolean allMatch(Predicate&lt;? super T&gt; predicate)</code> возвращает <code>true</code>, если все элементы потока удовлетворяют условию в предикате</p>
</li>
<li>
<p><code>boolean anyMatch(Predicate&lt;? super T&gt; predicate)</code> возвращает <code>true</code>, если хоть один элемент потока удовлетворяют условию в предикате</p>
</li>
<li>
<p><code>boolean noneMatch(Predicate&lt;? super T&gt; predicate)</code> возвращает <code>true</code>, если ни один из элементов в потоке не удовлетворяет условию в предикате</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример использования функций:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.stream.Stream;
import java.util.Optional;
import java.util.ArrayList;
import java.util.Arrays;
public class Program {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;();
        names.addAll(Arrays.asList(new String[]{"Tom", "Sam", "Bob", "Alice"}));

        // есть ли в потоке строка, длина которой больше 3
        boolean any = names.stream().anyMatch(s -&gt; s.length() &gt; 3);
        System.out.println(any); // true

        // все ли строки имеют длину в 3 символа
        boolean all = names.stream().allMatch(s -&gt; s.length() == 3);
        System.out.println(all); // false

        // НЕТ ЛИ в потоке строки "Bill". Если нет, то true, если есть, то false
        boolean none = names.stream().noneMatch(s -&gt; s == "Bill");
        System.out.println(none); // true
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_min_и_max">9.7.4. <code>min()</code> и <code>max()</code></h4>
<div class="paragraph">
<p>Методы <code>min()</code> и <code>max()</code> возвращают соответственно минимальное и максимальное значение. Поскольку данные в потоке могут представлять различные типы, в том числе сложные классы, то в качестве параметра в эти методы передается объект интерфейса <code>Comparator</code>, который указывает, как сравнивать объекты:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator)
Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Оба метода возвращают элемент потока (минимальный или максимальный), обернутый в объект <code>Optional</code>.</p>
</div>
<div class="paragraph">
<p>Например, найдем минимальное и максимальное число в числовом потоке:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.stream.Stream;
import java.util.Optional;
import java.util.ArrayList;
import java.util.Arrays;
public class Program {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();
        numbers.addAll(Arrays.asList(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9}));

        Optional&lt;Integer&gt; min = numbers.stream().min(Integer::compare);
        Optional&lt;Integer&gt; max = numbers.stream().max(Integer::compare);
        System.out.println(min.get()); // 1
        System.out.println(max.get()); // 9
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Интерфейс <code>Comparator</code> - это функциональный интерфейс, который определяет один метод <code>compare()</code>, принимающий два сравниваемых объекта и возвращающий число (если первый объект больше, возвращается положительное число, иначе возвращается отрицательное число). Поэтому вместо конкретной реализации компаратора мы можем передать лямбда-вырашение или метод, который соответствует методу compare интерфейса <code>Comparator</code>. Поскольку сравниваются числа, то в метод передается в качестве компаратора статический метод <code>Integer.compare()</code>.</p>
</div>
<div class="paragraph">
<p>При этом методы <code>min()</code> и <code>max()</code> возвращают именно <code>Optional</code>, и чтобы получить непосредственно результат операции из <code>Optional</code>, необходимо вызвать метод <code>get()</code>.</p>
</div>
<div class="paragraph">
<p>Рассмотрим более сложный случай, когда нам надо сравнивать более сложные объекты:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.stream.Stream;
import java.util.Optional;
import java.util.ArrayList;
import java.util.Arrays;
public class Program {
    public static void main(String[] args) {
        ArrayList&lt;Phone&gt; phones = new ArrayList&lt;Phone&gt;();
        phones.addAll(Arrays.asList(new Phone[] {
            new Phone("iPhone 8", 52000),
            new Phone("Nokia 9", 35000),
            new Phone("Samsung Galaxy S9", 48000),
            new Phone("HTC U12", 36000)
        }));

        Phone min = phones.stream().min(Phone::compare).get();
        Phone max = phones.stream().max(Phone::compare).get();
        System.out.printf("MIN Name: %s Price: %d \n", min.getName(), min.getPrice());
        System.out.printf("MAX Name: %s Price: %d \n", max.getName(), max.getPrice());
    }
}

class Phone {
    private String name;
    private int price;

    public Phone(String name, int price) {
        this.name = name;
        this.price = price;
    }

    public static int compare (Phone p1, Phone p2) {
        if(p1.getPrice() &gt; p2.getPrice()) {
            return 1;
        }
        return -1;
    }

    public String getName() {
        return name;
    }

    public int getPrice() {
        return price;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае мы находим минимальный и максимальный объект <code>Phone</code>: фактически объекты с максимальной и минимальной ценой. Для определения функциональности сравнения в классе <code>Phone</code> реализован статический метод <code>compare()</code>, который соответствует сигнатуре метода compare интерфейса <code>Comparator</code>. И в методах <code>min()</code> и <code>max()</code> применяем этот статический метод для сравнения объектов.</p>
</div>
<div class="paragraph">
<p>Консольный вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">MIN Name: Nokia 9 Price: 35000
MAX Name: iPhone 8 Price: 52000</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reduce">9.8. <code>reduce()</code></h3>
<div class="paragraph">
<p>Метод <code>reduce()</code> выполняет терминальные операции сведения, возвращая некоторое значение - результат операции. Он имеет следующие формы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)
T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)
U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Первая форма возвращает результат в виде объекта <code>Optional&lt;T&gt;</code>. Например, вычислим произведение набора чисел:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.stream.Stream;
import java.util.Optional;

public class Program {
    public static void main(String[] args) {
        Stream&lt;Integer&gt; numbersStream = Stream.of(1, 2, 3, 4, 5, 6);
        Optional&lt;Integer&gt; result = numbersStream.reduce((x, y) -&gt; x * y);
        System.out.println(result.get()); // 720
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Объект <code>BinaryOperator&lt;T&gt;</code> представляет функцию, которая принимает два элемента и выполняет над ними некоторую операцию, возвращая результат. При этом метод <code>reduce()</code> сохраняет результат и затем опять же применяет к этому результату и следующему элементу в наборе бинарную операцию. Фактически в данном случае мы получим результат, который будет равен: <code>n1 op n2 op n3 op n4 op n5 op n6</code>, где <code>op</code> - это операция (в данном случае умножения), а <code>n1</code>, <code>n2</code>, &#8230;&#8203; - элементы из потока.</p>
</div>
<div class="paragraph">
<p>Затем с помощью метода <code>get()</code> мы можем получить собственно результат вычислений: <code>result.get()</code></p>
</div>
<div class="paragraph">
<p>Или еще один пример - объединение слов в предложение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;String&gt; wordsStream = Stream.of("мама", "мыла", "раму");
Optional&lt;String&gt; sentence = wordsStream.reduce((x, y) -&gt; x + " " + y);
System.out.println(sentence.get());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если нам надо, чтобы первым элементом в наборе было какое-то определенное значение, то мы можем использовать вторую версию метода <code>reduce()</code>, которая в качестве первого параметра принимает <code>T identity</code>. Этот параметр хранит значение, с которого будет начинаться цепочка бинарных операций. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;String&gt; wordsStream = Stream.of("мама", "мыла", "раму");
String sentence = wordsStream.reduce("Результат:", (x, y) -&gt; x + " " + y);
System.out.println(sentence); // Результат: мама мыла раму</code></pre>
</div>
</div>
<div class="paragraph">
<p>Фактически здесь выполняется следующая цепь операций: <code>identity op n1 op n2 op n3 op n4&#8230;&#8203;</code></p>
</div>
<div class="paragraph">
<p>Использование параметра <code>identity</code> также подходит для тех случаев, когда надо предоставить значение по умолчанию, если поток пустой и не содержит элементов.</p>
</div>
<div class="paragraph">
<p>В предыдущих примерах тип возвращаемых объектов совпадал с типом элементов, которые входят в поток. Однако это не всегда удобно. Возможно, мы захотим возвратить результат, тип которого отличается от типа объектов потока. Например, пусть у нас есть следующий класс <code>Phone</code>, представляющий телефон:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Phone {
    private String name;
    private int price;

    public Phone(String name, int price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public int getPrice() {
        return price;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>И мы хотим найти сумму цен тех телефонов, у которых цена меньше определенного значения. Для этого используем третью версию метода <code>reduce()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;Phone&gt; phoneStream = Stream.of(
    new Phone("iPhone 6 S", 54000),
    new Phone("Lumia 950", 45000),
    new Phone("Samsung Galaxy S 6", 40000),
    new Phone("LG G 4", 32000)
);

int sum = phoneStream.reduce(0,
            (x, y) -&gt; (y.getPrice() &lt; 50000) ? x + y.getPrice() : x + 0,
            (x, y) -&gt; x + y);

System.out.println(sum); // 117000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Опять же здесь в качестве первого параметра идет значение по умолчанию - <code>0</code>. Второй параметр производит бинарную операцию, которая получает промежуточное значение - суммарную цену текущего и предыдущего телефонов. Третий параметр представляет бинарную операцию, которая суммирует все промежуточные вычисления.
= Класс <code>Optional</code></p>
</div>
<div class="paragraph">
<p>Ряд операций сведения, такие как <code>min()</code>, <code>max()</code>, <code>reduce()</code>, возвращают объект <code>Optional&lt;T&gt;</code>. Этот объект фактически обертывает результат операции. После выполнения операции с помощью метода <code>get()</code> объекта <code>Optional</code> мы можем получить его значение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.Optional;
import java.util.ArrayList;
import java.util.Arrays;
public class Program {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();
        numbers.addAll(Arrays.asList(new Integer[] {1, 2, 3, 4, 5, 6, 7, 8, 9}));
        Optional&lt;Integer&gt; min = numbers.stream()
            .min(Integer::compare);
        System.out.println(min.get()); // 1
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Но что, если поток не содержит вообще никаких данных:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">// список numbers пустой
ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();
Optional&lt;Integer&gt; min = numbers.stream()
    .min(Integer::compare);
System.out.println(min.get());  // java.util.NoSuchElementException</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом случае программа выдаст исключение <code>java.util.NoSuchElementException</code>. Что мы можем сделать, чтобы избежать выброса исключения? Для этого класс <code>Optional</code> предоставляет ряд методов.</p>
</div>
<div class="paragraph">
<p>Самой простой способ избежать подобной ситуации - это предварительная проверка наличия значения в <code>Optional</code> с помощью метода <code>isPresent()</code>. Он возврашает <code>true</code>, если значение присутствует в <code>Optional</code>, и <code>false</code>, если значение отсутствует:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();
Optional&lt;Integer&gt; min = numbers.stream()
    .min(Integer::compare);
if (min.isPresent()) {
    System.out.println(min.get());
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_orelse">9.8.1. <code>orElse()</code></h4>
<div class="paragraph">
<p>Метод <code>orElse()</code> позволяет определить альтернативное значение, которое будет возвращаться, если <code>Optional</code> не получит из потока какого-нибудь значения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">// пустой список
ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();
Optional&lt;Integer&gt; min = numbers.stream()
    .min(Integer::compare);
System.out.println(min.orElse(-1)); // -1

// непустой список
numbers.addAll(Arrays.asList(new Integer[] {4, 5, 6, 7, 8, 9}));
min = numbers.stream()
    .min(Integer::compare);
System.out.println(min.orElse(-1)); // 4</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_orelseget"><code>orElseGet()</code></h5>
<div class="paragraph">
<p>Метод <code>orElseGet()</code> позволяет задать функцию, которая будет возвращать значение по умолчанию:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.Optional;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;

public class Program {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();
        Optional&lt;Integer&gt; min = numbers.stream()
            .min(Integer::compare);
        Random rnd = new Random();
        System.out.println(min.orElseGet(() -&gt; rnd.nextInt(100)));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае возвращаемое значение генерируется с помощью метода <code>nextInt()</code> класса <code>Random</code>, который возвращает случайное число.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_orelsethrow">9.8.2. <code>orElseThrow()</code></h4>
<div class="paragraph">
<p>Еще один метод - <code>orElseThrow()</code> позволяет сгенерировать исключение, если <code>Optional</code> не содержит значения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();
Optional&lt;Integer&gt; min = numbers.stream()
    .min(Integer::compare);
// генеррация исключения IllegalStateException
System.out.println(min.orElseThrow(IllegalStateException::new));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ifpresent">9.8.3. <code>ifPresent()</code></h4>
<div class="paragraph">
<p>Метод <code>ifPresent()</code> определяет действия со значением в <code>Optional</code>, если значение имеется:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();
numbers.addAll(Arrays.asList(new Integer[]{4,5,6,7,8,9}));
Optional&lt;Integer&gt; min = numbers.stream().min(Integer::compare);
min.ifPresent(v-&gt;System.out.println(v)); // 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>В метод <code>ifPresent()</code> передается функция, которая принимает один параметр - значение из <code>Optional</code>. В данном случае полученное минимальное число выводится на консоль. Но если бы массив numbers был бы пустым, и соответственно <code>Optional</code> не сдержало бы никакого значения, то никакой ошибки бы не было.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ifpresentorelse">9.8.4. <code>ifPresentOrElse()</code></h4>
<div class="paragraph">
<p>Метод <code>ifPresentOrElse()</code> позволяет определить альтернативную логику на случай, если значение в <code>Optional</code> отсутствует:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();
Optional&lt;Integer&gt; min = numbers.stream()
    .min(Integer::compare);
min.ifPresentOrElse(v -&gt; System.out.println(v), () -&gt; System.out.println("Value not found"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>В метод <code>ifPresentOrElse()</code> передается две функции. Первая обрабатывает значение в <code>Optional</code>, если оно присутствует. Вторая функция представляет действия, которые выполняются, если значение в <code>Optional</code> отсутствует.
= <code>Stream.collect()</code></p>
</div>
<div class="paragraph">
<p>Большинство операций класса <code>Stream</code>, которые модифицируют набор данных, возвращают этот набор в виде потока. Однако бывают ситуации, когда хотелось бы получить данные не в виде потока, а в виде обычной коллекции, например, <code>ArrayList</code> или <code>HashSet</code>. И для этого у класса <code>Stream</code> определен метод <code>collect</code>. Первая версия метода принимает в качестве параметра функцию преобразования к коллекции:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Параметр <code>R</code> представляет тип результата метода, параметр <code>Т</code> - тип элемента в потоке, а параметр <code>А</code> - тип промежуточных накапливаемых данных. В итоге параметр <code>collector</code> представляет функцию преобразования потока в коллекцию.</p>
</div>
<div class="paragraph">
<p>Эта функция представляет объект <code>Collector</code>, который определен в пакете <code>java.util.stream</code>. Мы можем написать свою реализацию функции, однако Java уже предоставляет ряд встроенных функций, определенных в классе <code>Collectors</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>toList()</code> преобразование к типу <code>List</code></p>
</li>
<li>
<p><code>toSet()</code> преобразование к типу <code>Set</code></p>
</li>
<li>
<p><code>toMap()</code> преобразование к типу <code>Map</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Например, преобразуем набор в потоке в список:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

public class Program {
    public static void main(String[] args) {
        List&lt;String&gt; phones = new ArrayList&lt;String&gt;();
        Collections.addAll(phones, "iPhone 8", "HTC U12", "Huawei Nexus 6P",
                "Samsung Galaxy S9", "LG G6", "Xiaomi MI6", "ASUS Zenfone 2",
                "Sony Xperia Z5", "Meizu Pro 6", "Lenovo S850");
        List&lt;String&gt; filteredPhones = phones.stream()
                .filter(s -&gt; s.length() &lt; 10)
                .collect(Collectors.toList());

        for(String s : filteredPhones) {
            System.out.println(s);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Использование метода <code>toSet()</code> аналогично.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Set&lt;String&gt; filteredPhones = phones.stream()
                .filter(s -&gt; s.length() &lt; 10)
                .collect(Collectors.toSet());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для применения метода <code>toMap()</code> надо задать ключ и значение. Например, пусть у нас есть следующая модель:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Phone {
    private String name;
    private int price;

    public Phone(String name, int price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public int getPrice() {
        return price;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь применим метод <code>toMap()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Program {
    public static void main(String[] args) {
        Stream&lt;Phone&gt; phoneStream = Stream.of(new Phone("iPhone 8", 54000),
            new Phone("Nokia 9", 45000),
            new Phone("Samsung Galaxy S9", 40000),
            new Phone("LG G6", 32000));


        Map&lt;String, Integer&gt; phones = phoneStream
            .collect(Collectors.toMap(p -&gt; p.getName(), t -&gt; t.getPrice()));

        phones.forEach((k, v) -&gt; System.out.println(k + " " + v));
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Phone {
    private String name;
    private int price;

    public Phone(String name, int price) {
        this.name=name;
        this.price=price;
    }

    public String getName() {
        return name;
    }

    public int getPrice() {
        return price;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Лямбда-выражение <code>p &#8594; p.getName()</code> получает значение для ключа элемента, а <code>t &#8594; t.getPrice()</code> - извлекает значение элемента.</p>
</div>
<div class="paragraph">
<p>Если нам надо создать какой-то определенный тип коллекции, например, <code>HashSet</code>, то мы можем использовать специальные функции, которые определены в классах-коллекций. Например, получим объект <code>HashSet</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Program {
    public static void main(String[] args) {
        Stream&lt;String&gt; phones = Stream.of("iPhone 8", "HTC U12", "Huawei Nexus 6P",
                "Samsung Galaxy S9", "LG G6", "Xiaomi MI6", "ASUS Zenfone 2",
                "Sony Xperia Z5", "Meizu Pro 6", "Lenovo S850");

        TreeSet&lt;String&gt; filteredPhones = phones.filter(s -&gt; s.length() &lt; 12).
                                    collect(Collectors.toCollection(TreeSet::new));

        filteredPhones.forEach(s -&gt; System.out.println(s));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Выражение <code>HashSet::new</code> представляет функцию создания коллекции. Аналогичным образом можно получать другие коллекции, например, <code>ArrayList</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ArrayList&lt;String&gt; result = phones.collect(Collectors.toCollection(ArrayList::new));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вторая форма метода <code>&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</code> имеет три параметра:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>supplier</code> создает объект коллекции</p>
</li>
<li>
<p><code>accumulator</code> добавляет элемент в коллекцию</p>
</li>
<li>
<p><code>combiner</code> бинарная функция, которая объединяет два объекта</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Применим эту версию метода <code>collect()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.ArrayList;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Program {
    public static void main(String[] args) {
        Stream&lt;String&gt; phones = Stream.of("iPhone 8", "HTC U12", "Huawei Nexus 6P",
                "Samsung Galaxy S9", "LG G6", "Xiaomi MI6", "ASUS Zenfone 2",
                "Sony Xperia Z5", "Meizu Pro 6", "Lenovo S850");

        ArrayList&lt;String&gt; filteredPhones = phones.filter(s -&gt; s.length() &lt; 12)
            .collect(
                ()-&gt; new ArrayList&lt;String&gt;(), // создаем ArrayList
                (list, item) -&gt; list.add(item), // добавляем в список элемент
                (list1, list2) -&gt; list1.addAll(list2)); // добавляем в список другой список

        filteredPhones.forEach(s -&gt; System.out.println(s));
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_класс_collectors">9.9. Класс <code>Collectors</code></h3>
<div class="sect3">
<h4 id="_groupingby">9.9.1. <code>groupingBy()</code></h4>
<div class="paragraph">
<p>Чтобы сгруппировать данные по какому-нибудь признаку, нам надо использовать в связке метод <code>collect()</code> объекта <code>Stream</code> и метод <code>Collectors.groupingBy()</code>. Допустим, у нас есть следующий класс:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Phone {
    private String name;
    private String company;
    private int price;

    public Phone(String name, String comp, int price) {
        this.name = name;
        this.company = comp;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public int getPrice() {
        return price;
    }

    public String getCompany() {
        return company;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>И, к примеру, у нас есть набор объектов <code>Phone</code>, которые мы хотим сгруппировать по компании:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.List;
import java.util.Map;
import java.util.stream.Stream;
import java.util.stream.Collectors;

public class Program {
    public static void main(String[] args) {
        Stream&lt;Phone&gt; phoneStream = Stream.of(
            new Phone("iPhone X", "Apple", 600),
            new Phone("Pixel 2", "Google", 500),
            new Phone("iPhone 8", "Apple",450),
            new Phone("Galaxy S9", "Samsung", 440),
            new Phone("Galaxy S8", "Samsung", 340)
        );

        Map&lt;String, List&lt;Phone&gt;&gt; phonesByCompany = phoneStream.collect(
                Collectors.groupingBy(Phone::getCompany));

        for(Map.Entry&lt;String, List&lt;Phone&gt;&gt; item : phonesByCompany.entrySet()) {
            System.out.println(item.getKey());
            for(Phone phone : item.getValue()) {
                System.out.println(phone.getName());
            }
            System.out.println();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Консольный вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Google
Pixel 2

Apple
iPhone X
iPhone 8

Samsung
Galaxy S9
Galaxy S8</code></pre>
</div>
</div>
<div class="paragraph">
<p>Итак, для создания групп в метод <code>phoneStream.collect()</code> передается вызов функции <code>Collectors.groupingBy()</code>, которая с помощью выражения <code>Phone::getCompany</code> группирует объекты по компании. В итоге будет создан объект <code>Map</code>, в котором ключами являются названия компаний, а значениями - список связанных с компаниями телефонов.</p>
</div>
</div>
<div class="sect3">
<h4 id="_partitioningby">9.9.2. <code>partitioningBy()</code></h4>
<div class="paragraph">
<p>Метод <code>Collectors.partitioningBy()</code> имеет похожее действие, только он делит элементы на группы по принципу, соответствует ли элемент определенному условию. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Map&lt;Boolean, List&lt;Phone&gt;&gt; phonesByCompany = phoneStream.collect(
                Collectors.partitioningBy(p -&gt; p.getCompany() == "Apple"));

for(Map.Entry&lt;Boolean, List&lt;Phone&gt;&gt; item : phonesByCompany.entrySet()) {
    System.out.println(item.getKey());
    for(Phone phone : item.getValue()) {
        System.out.println(phone.getName());
    }
    System.out.println();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае с помощью условия <code>p &#8594; p.getCompany() == "Apple"</code> мы смотрим, принадлежит ли телефон компании <code>Apple</code>. Если телефон принадлежит этой компании, то он попадает в одну группу, если нет, то в другую.</p>
</div>
</div>
<div class="sect3">
<h4 id="_counting">9.9.3. <code>counting()</code></h4>
<div class="paragraph">
<p>Метод <code>Collectors.counting()</code> применяется в <code>Collectors.groupingBy()</code> для вычисления количества элементов в каждой группе:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Map&lt;String, Long&gt; phonesByCompany = phoneStream.collect(
        Collectors.groupingBy(Phone::getCompany, Collectors.counting()));

for(Map.Entry&lt;String, Long&gt; item : phonesByCompany.entrySet()) {
    System.out.println(item.getKey() + " - " + item.getValue());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Консольный вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Google -1
Apple - 2
Samsung - 2</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_summing">9.9.4. <code>summing()</code></h4>
<div class="paragraph">
<p>Метод <code>Collectors.summing()</code> применяется для подсчета суммы. В зависимости от типа данных, к которым применяется метод, он имеет следующие формы: <code>summingInt()</code>, <code>summingLong()</code>, <code>summingDouble()</code>. Применим этот метод для подсчета стоимости всех смартфонов по компаниям:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Map&lt;String, Integer&gt; phonesByCompany = phoneStream.collect(
        Collectors.groupingBy(Phone::getCompany, Collectors.summingInt(Phone::getPrice)));

for(Map.Entry&lt;String, Integer&gt; item : phonesByCompany.entrySet()) {
    System.out.println(item.getKey() + " - " + item.getValue());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>С помощью выражения <code>Collectors.summingInt(Phone::getPrice))</code> мы указываем, что для каждой компании будет вычислять совокупная цена всех ее смартфонов. И поскольку вычисляется результат - сумма для значений типа <code>int</code>, то в качестве типа возвращаемой коллекции используется тип <code>Map&lt;String, Integer&gt;</code></p>
</div>
<div class="paragraph">
<p>Консольный вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Google - 500
Apple - 1050
Samsung - 780</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_maxby_и_minby">9.9.5. <code>maxBy()</code> и <code>minBy()</code></h4>
<div class="paragraph">
<p>Методы <code>maxBy()</code> и <code>minBy()</code> применяются для подсчета минимального и максимального значения в каждой группе. В качестве параметра эти методы принимают функцию компаратора, которая нужна для сравнения значений. Например, найдем для каждой компании телефон с минимальной ценой:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Map&lt;String, Optional&lt;Phone&gt;&gt; phonesByCompany = phoneStream.collect(
        Collectors.groupingBy(Phone::getCompany,
                Collectors.minBy(Comparator.comparing(Phone::getPrice))));

for(Map.Entry&lt;String, Optional&lt;Phone&gt;&gt; item : phonesByCompany.entrySet()) {
    System.out.println(item.getKey() + " - " + item.getValue().get().getName());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Консольный вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Google - Pixel 2
Apple - iPhone 8
Samsung - Galaxy S8</code></pre>
</div>
</div>
<div class="paragraph">
<p>В качестве возвращаемого значения операции группировки используется объект <code>Map&lt;String, Optional&lt;Phone&gt;&gt;</code>. Опять же поскольку группируем по компаниям, то ключом будет выступать строка, а значением - объект <code>Optional&lt;Phone&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_summarizing">9.9.6. <code>summarizing()</code></h4>
<div class="paragraph">
<p>Методы <code>summarizingInt()</code> / <code>summarizingLong()</code> / <code>summarizingDouble()</code> позволяют объединить в набор значения соответствующих типов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Map&lt;String, java.util.IntSummaryStatistics&gt; priceSummary = phoneStream.collect(
    Collectors.groupingBy(Phone::getCompany,
        Collectors.summarizingInt(Phone::getPrice)));

for(Map.Entry&lt;String, java.util.IntSummaryStatistics&gt; item : priceSummary.entrySet()) {
    System.out.println(item.getKey() + " - " + item.getValue().getAverage());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>Collectors.summarizingInt(Phone::getPrice))</code> создает набор, в который помещаются цены для всех телефонов каждой из групп. Данный набор инкапсулируется в объекте <code>IntSummaryStatistics</code>. Соответственно если бы мы применяли методы <code>summarizingLong()</code> или <code>summarizingDouble()</code>, то соответственно бы получали объекты <code>LongSummaryStatistics</code> или <code>DoubleSummaryStatistics</code>.</p>
</div>
<div class="paragraph">
<p>У этих объектов есть ряд методов, который позволяют выполнить различные атомарные операции над набором:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getAverage()</code> возвращает среднее значение</p>
</li>
<li>
<p><code>getCount()</code> возвращает количество элементов в наборе</p>
</li>
<li>
<p><code>getMax()</code> возвращает максимальное значение</p>
</li>
<li>
<p><code>getMin()</code> возвращает минимальное значение</p>
</li>
<li>
<p><code>getSum()</code> возвращает сумму элементов</p>
</li>
<li>
<p><code>accept()</code> добавляет в набор новый элемент</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В данном случае мы получаем среднюю цену смартфонов для каждой группы.</p>
</div>
<div class="paragraph">
<p>Консольный вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Google - 500.0
Apple - 525.0
Samsung - 390.0</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mapping">9.9.7. <code>mapping()</code></h4>
<div class="paragraph">
<p>Метод <code>mapping()</code> позволяет дополнительно обработать данные и задать функцию отображения объектов из потока на какой-нибудь другой тип данных. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Map&lt;String, List&lt;String&gt;&gt; phonesByCompany = phoneStream.collect(
    Collectors.groupingBy(Phone::getCompany,
    Collectors.mapping(Phone::getName, Collectors.toList())));

for(Map.Entry&lt;String, List&lt;String&gt;&gt; item : phonesByCompany.entrySet()) {
    System.out.println(item.getKey());
    for(String name : item.getValue()) {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Выражение <code>Collectors.mapping(Phone::getName, Collectors.toList())</code> указывает, что в группу будут выделятся названия смартфонов, причем группа будет представлять объект <code>List</code>.
= Параллельные потоки</p>
</div>
<div class="paragraph">
<p>Кроме последовательных потоков <strong>Stream API</strong> поддерживает параллельные потоки. Распараллеливание потоков позволяет задействовать несколько ядер процессора (если целевая машина многоядерная) и тем самым может повысить производительность и ускорить вычисления. В то же время говорить, что применение параллельных потоков на многоядерных машинах однозначно повысит производительность - не совсем корректно. В каждом конкретном случае надо проверять и тестировать.</p>
</div>
<div class="paragraph">
<p>Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта <code>Stream</code> метод <code>parallel()</code>. Кроме того, можно также использовать метод <code>parallelStream()</code> интерфейса <code>Collection</code> для создания параллельного потока из коллекции.</p>
</div>
<div class="paragraph">
<p>В то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный.</p>
</div>
<div class="paragraph">
<p>Применение параллельных потоков во многих случаях будет аналогично. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.Optional;
import java.util.stream.Stream;

public class Program {
    public static void main(String[] args) {
        Stream&lt;Integer&gt; numbersStream = Stream.of(1, 2, 3, 4, 5, 6);
        Optional&lt;Integer&gt; result = numbersStream.parallel().reduce((x, y) -&gt; x * y);
        System.out.println(result.get()); // 720
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Однако не все функции можно без ущерба для точности вычисления перенести с последовательных потоков на параллельные. Прежде всего такие функции должны быть без сохранения состояния и ассоциативными, то есть при выполнении слева направо давать тот же результат, что и при выполнении справа налево, как в случае с произведением чисел. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;String&gt; wordsStream = Stream.of("мама", "мыла", "раму");
String sentence = wordsStream.parallel().reduce("Результат:", (x, y) -&gt; x + " " + y);
System.out.println(sentence);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Результатом этой функции будет консольный вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Результат: мама Результат: мыла Результат: раму</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sequential">9.9.8. <code>sequential()</code></h4>
<div class="paragraph">
<p>Данный вывод не является правильным. Если же мы не уверены, что на каком-то этапе работы с параллельным потоком он адекватно сможет выполнить какую-нибудь операцию, то мы можем преобразовать этот поток в последовательный посредством вызова метода <code>sequential()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;String&gt; wordsStream = Stream.of("мама", "мыла", "раму", "hello world");
String sentence = wordsStream.parallel()
        .filter(s-&gt;s.length()&lt;10) // фильтрация над параллельным потоком
        .sequential()
        .reduce("Результат:", (x, y) -&gt; x + " " + y); // операция над последовательным потоком
System.out.println(sentence);</code></pre>
</div>
</div>
<div class="paragraph">
<p>И возьмем другой пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Stream&lt;Integer&gt; numbersStream = Stream.of(1, 2, 3, 4, 5, 6);
Integer result = numbersStream.parallel().reduce(1, (x, y) -&gt; x * y);
System.out.println(result);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Фактически здесь происходит перемножение чисел. При этом нет разницы между <code>1 * 2 * 3 * 4 * (5 * 6)</code> или <code>5 * 6 * 1 * (2 * 3) * 4</code>. Мы можем расставить скобки любым образом, разместить последовательность чисел в любом порядке, и все равно мы получим один и тот же результат. То есть данная операция является ассоциативной и поэтому может быть распараллелена.</p>
</div>
</div>
<div class="sect3">
<h4 id="_вопросы_производительности_в_параллельных_операциях">9.9.9. Вопросы производительности в параллельных операциях</h4>
<div class="paragraph">
<p>Фактически применение параллельных потоков сводится к тому, что данные в потоке будут разделены на части, каждая часть обрабатывается на отдельном ядре процессора, и в конце эти части соединяются, и над ними выполняются финальные операции. Рассмотрим некоторые критерии, которые могут повлиять на производительность в параллельных потоках:</p>
</div>
<div class="paragraph">
<p>Размер данных. Чем больше данных, тем сложнее сначала разделять данные, а потом их соединять.</p>
</div>
<div class="paragraph">
<p>Количество ядер процессора. Теоретически, чем больше ядер в компьютере, тем быстрее программа будет работать. Если на машине одно ядро, нет смысла применять параллельные потоки.</p>
</div>
<div class="paragraph">
<p>Чем проще структура данных, с которой работает поток, тем быстрее будут происходить операции. Например, данные из <code>ArrayList</code> легко использовать, так как структура данной коллекции предполагает последовательность несвязанных данных. А вот коллекция типа <code>LinkedList</code> - не лучший вариант, так как в последовательном списке все элементы связаны с предыдущими/последующими. И такие данные трудно распараллелить.</p>
</div>
<div class="paragraph">
<p>Над данными примитивных типов операции будут производиться быстрее, чем над объектами классов</p>
</div>
</div>
<div class="sect3">
<h4 id="_упорядоченность_в_параллельных_потоках">9.9.10. Упорядоченность в параллельных потоках</h4>
<div class="paragraph">
<p>Как правило, элементы передаются в поток в том же порядке, в котором они определены в источнике данных. При работе с параллельными потоками система сохраняет порядок следования элементов. Исключение составляет метод <code>forEach()</code>, который может выводить элементы в произвольном порядке. И чтобы сохранить порядок следования, необходимо применять метод <code>forEachOrdered()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">phones.parallelStream()
    .sorted()
    .forEachOrdered(s -&gt; System.out.println(s));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сохранение порядка в параллельных потоках увеличивает издержки при выполнении. Но если нам порядок не важен, то мы можем отключить его сохранение и тем самым увеличить производительность, использовав метод <code>unordered()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">phones.parallelStream()
    .sorted()
    .unordered()
    .forEach(s -&gt; System.out.println(s));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_параллельные_операции_над_массивами">9.10. Параллельные операции над массивами</h3>
<div class="paragraph">
<p>В JDK 8 к классу <code>Arrays</code> было добавлено ряд методов, которые позволяют в параллельном режиме совершать обработку элементов массива. И хотя данные методы формально не входят в <strong>Stream API</strong>, но реализуют схожую функциональность, что и параллельные потоки:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>parallelSetAll()</code> устанавливает элементы массива с помощью лямбда-выражения</p>
</li>
<li>
<p><code>parallelSort()</code> сортирует массив</p>
</li>
<li>
<p><code>parallelPrefix()</code> вычисляет некоторое значение для элементов массива (например, сумму элементов)</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_parallelsetall">9.10.1. <code>parallelSetAll()</code></h4>
<div class="paragraph">
<p>Используем метод <code>parallelSetAll()</code> для установки элементов массива:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.Arrays;
public class Program {
    public static void main(String[] args) {
        int[] numbers = initializeArray(6);
        for(int i : numbers) {
            System.out.println(i);
        }
    }

    public static int[] initializeArray(int size) {
        int[] values = new int[size];
        Arrays.parallelSetAll(values, i -&gt; i * 10);
        return values;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В метод <code>Arrays.parallelSetAll()</code> передается два параметра: изменяемый массив и функция, которая устанавливает элементы массива. Эта функция перебирает все элементы и в качестве параметра получает индекс текущего перебираемого элемента. Выражение <code>i &#8594; i * 10</code> означает, что по каждому индексу в массиве будет хранится число, равное <code>i * 10</code>. В итоге мы получим следующий вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">0
10
20
30
40
50</code></pre>
</div>
</div>
<div class="paragraph">
<p>Рассмотрим более сложный пример. Пусть у нас есть следующий класс <code>Phone</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Phone {
    private String name;
    private int price;

    public Phone(String name, int price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public void setName(String val) {
        this.name = val;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int val) {
        this.price = val;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь произведем манипуляции с массивом объектов <code>Phone</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Phone[] phones = new Phone[] {
    new Phone("iPhone 8", 54000),
    new Phone("Pixel 2", 45000),
    new Phone("Samsung Galaxy S9", 40000),
    new Phone("Nokia 9", 32000)
};

Arrays.parallelSetAll(phones, i -&gt; {
    phones[i].setPrice(phones[i].getPrice() - 10000);
    return phones[i];
});

for(Phone p : phones) {
    System.out.printf("%s - %d \n", p.getName(), p.getPrice());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь лямбда-выражение в методе <code>Arrays.parallelSetAll()</code> представляет блок кода. И так как лямбда-выражение должно возвращать объект, то нам надо явным образом использовать оператор <code>return</code>. В этом лямбда-выражении опять же функция получает индексы перебираемых элементов, и по этим индексам мы можем обратиться к элементам массива и их изменить. Конкретно в данном случае происходит уменьшение цены смартфонов на <code>10000</code> единиц. В итоге мы получим следующий консольный вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">iPhone 8 - 44000
Pixel 2 - 35000
Samsung Galaxy S9 - 30000
Nokia 9 - 22000</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_parallelsort">9.10.2. <code>parallelSort()</code></h4>
<div class="paragraph">
<p>Отсортируем массив чисел в параллельном режиме:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int[] nums = {30, -4, 5, 29, 7, -8};
Arrays.parallelSort(nums);
for(int i : nums) {
    System.out.println(i);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>Arrays.parallelSort()</code> в качестве параметра принимает массив и сортирует его по возрастанию:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">-8
-4
5
7
29
30</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если же нам надо как-то по-другому отсортировать объекты, например, по модулю числа, или у нас более сложные объекты, то мы можем создать свой компаратор и передать его в качестве второго параметра в <code>Arrays.parallelSort()</code>. Например, возьмем выше определенный класс <code>Phone</code> и создадим для него компаратор:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.Arrays;
import java.util.Comparator;
public class Program {
    public static void main(String[] args) {
        Phone[] phones = new Phone[]{new Phone("iPhone 8", 54000),
        new Phone("Pixel 2", 45000),
        new Phone("Samsung Galaxy S9", 40000),
        new Phone("Nokia 9", 32000)};

        Arrays.parallelSort(phones,new PhoneComparator());

        for(Phone p : phones) {
        System.out.println(p.getName());
        }
    }
}

class PhoneComparator implements Comparator&lt;Phone&gt; {
    public int compare(Phone a, Phone b) {
        return a.getName().toUpperCase().compareTo(b.getName().toUpperCase());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_parallelprefix">9.10.3. <code>parallelPrefix()</code></h4>
<div class="paragraph">
<p>Метод <code>parallelPrefix()</code> походит для тех случаев, когда надо получить элемент массива или объект того же типа, что и элементы массива, который обладает некоторыми признаками. Например, в массиве чисел это может быть максимальное, минимальное значения и т.д. Например, найдем произведение чисел:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int[] numbers = {1, 2, 3, 4, 5, 6};
Arrays.parallelPrefix(numbers, (x, y) -&gt; x * y);

for(int i : numbers) {
    System.out.println(i);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Мы получим следующий результат:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">1
2
6
24
120
720</code></pre>
</div>
</div>
<div class="paragraph">
<p>То есть, как мы видим из консольного вывода, лямбда-выражение из <code>Arrays.parallelPrefix()</code>, которое представляет бинарную функцию, получает два элемента и выполняет над ними операцию. Результат операции сохраняется и передается в следующий вызов бинарной функции.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_date_and_time_api">10. Date and Time API</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_дата_и_время_since_version_8">10.1. Дата и время (since version 8)</h3>
<div class="paragraph">
<p>До Java 8 для работы с датой и временем использовались классы <code>java.util.Date</code> и <code>java.util.Calendar</code>. У них было много недостатков, например:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>не потокобезопасный,</p>
</li>
<li>
<p>изменяемые объекты</p>
</li>
<li>
<p>временная зона даты – это временная зона JVM по умолчанию</p>
</li>
<li>
<p>месяца начинаются с нуля</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В Java 8 добавили новую библиотеку, которая содержит <strong>неизменные</strong> (<strong>immutable</strong>), <strong>потокобезопасные</strong> (<strong>thread-safe</strong>) классы с более <strong>продуманным дизайном</strong>. Это классы <code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code>, <code>Instant</code>, <code>Period</code> и <code>Duration</code>. Содержатся они в пакете <code>java.time</code> и не содержат информацию о временной зоне (кроме класса <code>Instant</code>).</p>
</div>
<div class="paragraph">
<p><code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code> и <code>Instant</code> реализуют интерфейс <code>java.time.temporal.Temporal</code>. <code>Period</code> и <code>Duration</code> реализуют интерфейс <code>java.time.temporal.TemporalAmount</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/assets/img/java/core/date-time.png" alt="Date and Time"></span></p>
</div>
</div>
<div class="sect2">
<h3 id="_класс_localdate">10.2. Класс <code>LocalDate</code></h3>
<div class="paragraph">
<p>Класс <code>LocalDate</code> представляет время с годом, месяцем и днем месяца. Например <code>2015-08-25</code>.</p>
</div>
<div class="paragraph">
<p>Для создания объекта класса используется метод <code>of()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">LocalDate newYear2001 = LocalDate.of(2001, 1, 1);
LocalDate newYear2002 = LocalDate.of(2002, Month.JANUARY, 1);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для создания объекта, отображающего текущую дату, используется метод <code>now()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">LocalDate today = LocalDate.now();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий пример показывает получение года, месяца, дня месяца:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.Month;

public class LocalDateDemo2 {
    public static void main(String[] args) {
        LocalDate today = LocalDate.now();

        int year = today.getYear();
        int month = today.getMonthValue();
        Month monthAsEnum = today.getMonth(); // как перечисление
        int dayYear = today.getDayOfYear();
        int dayMonth = today.getDayOfMonth();
        DayOfWeek dayWeekEnum = today.getDayOfWeek(); // как перечисление

        System.out.println("Год: " + year);
        System.out.println("Месяц: " + month);
        System.out.println("Название месяца: " + monthAsEnum);
        System.out.println("День в году: " + dayYear);
        System.out.println("День месяца: " + dayMonth);
        System.out.println("День недели: " + dayWeekEnum);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Еще один вариант получение года, месяца, дня месяца:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.LocalDate;
import java.time.temporal.ChronoField;

public class LocalDateDemo3 {
    public static void main(String[] args) {
        LocalDate today = LocalDate.now();

        int year = today.get(ChronoField.YEAR);
        int month = today.get(ChronoField.MONTH_OF_YEAR);
        int dayYear = today.get(ChronoField.DAY_OF_YEAR);
        int dayMonth = today.get(ChronoField.DAY_OF_MONTH);
        int dayWeek = today.get(ChronoField.DAY_OF_WEEK);

        System.out.println("Год: " + year);
        System.out.println("Месяц: " + month);
        System.out.println("День в году: " + dayYear);
        System.out.println("День месяца: " + dayMonth);
        System.out.println("День недели: " + dayWeek);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для сравнения дат используются методы <code>isAfter()</code>, <code>isBefore()</code>, <code>equals()</code>, <code>isLeapYear()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.LocalDate;
import java.time.Month;

public class CompareLocalDateDemo1 {
    public static void main(String[] args) {
        LocalDate newYear2001 = LocalDate.of(2001, 1, 1);
        LocalDate newYear2002 = LocalDate.of(2002, Month.JANUARY, 1);

        boolean after = newYear2001.isAfter(newYear2002);
        boolean before = newYear2001.isBefore(newYear2002);
        boolean equal = newYear2001.equals(newYear2002);
        boolean leapYear = newYear2001.isLeapYear();

        System.out.println("newYear2001.isAfter(newYear2002): " + after);
        System.out.println("newYear2001.isBefore(newYear2002): " + before);
        System.out.println("newYear2001.equals(newYear2002): " + equal);
        System.out.println("newYear2001.isLeapYear(): " + leapYear);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий пример показывает использование методов <code>with()</code> для изменения отдельно года, месяца, дня:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.LocalDate;
import java.time.temporal.ChronoField;

public class WithLocalDateDemo {
    public static void main(String[] args) {
        LocalDate newYear2001 = LocalDate.of(2001, 1, 1);

        LocalDate newYear2003 = newYear2001.with(ChronoField.YEAR, 2003);
        LocalDate newYear2004 = newYear2001.withYear(2004);
        LocalDate december2001 = newYear2001.withMonth(12);
        LocalDate february2001 = newYear2001.withDayOfYear(32);
        LocalDate xmas2001 = newYear2001.withMonth(12).withDayOfMonth(25);

        System.out.println("newYear2003 " + newYear2003);
        System.out.println("newYear2004 " + newYear2004);
        System.out.println("december2001 " + december2001);
        System.out.println("february2001 " + february2001);
        System.out.println("xmas2001 " + xmas2001);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Методы <code>plus()</code>, <code>minus()</code> используются для добавления или вычитания года, месяца или дня:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.LocalDate;
import java.time.temporal.ChronoUnit;

public class PlusMinusLocalDateDemo {
    public static void main(String[] args) {
        LocalDate newYear2001 = LocalDate.of(2001, 1, 1);
        LocalDate newYear2005 = newYear2001.plusYears(4);
        LocalDate march2001 = newYear2001.plusMonths(2);
        LocalDate january15Year2001 = newYear2001.plusDays(14);
        LocalDate lastWeekJanuary2001 = newYear2001.plusWeeks(3);
        LocalDate newYear2006 = newYear2001.plus(5, ChronoUnit.YEARS);

        LocalDate newYear2000 = newYear2001.minusYears(1);
        LocalDate nov2000 = newYear2001.minusMonths(2);
        LocalDate dec30Year2000 = newYear2001.minusDays(2);
        LocalDate lastWeekDec2001 = newYear2001.minusWeeks(1);
        LocalDate newYear1999 = newYear2001.minus(2, ChronoUnit.YEARS);

        System.out.println("newYear2005: " + newYear2005);
        System.out.println("march2001: " + march2001);
        System.out.println("january15Year2001: " + january15Year2001);
        System.out.println("lastWeekJanuary2001: " + lastWeekJanuary2001);
        System.out.println("newYear2006: " + newYear2006);

        System.out.println("newYear2000: " + newYear2000);
        System.out.println("nov2000: " + nov2000);
        System.out.println("dec30Year2000: " + dec30Year2000);
        System.out.println("lastWeekDec2001: " + lastWeekDec2001);
        System.out.println("newYear1999: " + newYear1999);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_класс_localtime">10.3. Класс <code>LocalTime</code></h3>
<div class="paragraph">
<p>Класс <code>LocalTime</code> представляет время с часами, минутами, секундами и наносекундами. Например <code>13:21.05.123456789</code>.</p>
</div>
<div class="paragraph">
<p>Для создания объекта класса <code>LocalTime</code> используется метод <code>of()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.LocalTime;

public class LocalTimeDemo1 {
    public static void main(String[] args) {
        // С часами (0-23) и минутами(0-59)
        LocalTime fiveThirty = LocalTime.of(5, 30);
        // С часами, минутами и секундами(0-59)
        LocalTime noon = LocalTime.of(12, 0, 0);
        // С часами, минутами, секундами и наносекундами(0-999,999,999)
        LocalTime almostMidnight = LocalTime.of(23, 59, 59, 999999);

        System.out.println(fiveThirty);
        System.out.println(noon);
        System.out.println(almostMidnight);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для получения объекта <code>LocalTime</code>, который содержит текущее время, используется метод <code>now()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.LocalTime;

public class LocalTimeDemo2 {
    public static void main(String[] args) {
        LocalTime now = LocalTime.now();
        int hour = now.getHour();
        int minute = now.getMinute();
        int second = now.getSecond();
        int nanosecond = now.getNano();

        System.out.println("Часы: " + hour);
        System.out.println("Минуты: " + minute);
        System.out.println("Секунды: " + second);
        System.out.println("Наносекунды: " + nanosecond);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий пример показывает использование методов <code>get()</code> класса <code>LocalTime</code> для получения часов, минут или секунд:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.LocalTime;
import java.time.temporal.ChronoField;

public class LocalTimeDemo3 {
    public static void main(String[] args) {
        LocalTime now = LocalTime.now();
        int hourAMPM = now.get(ChronoField.HOUR_OF_AMPM); // 0 - 11
        int hourDay = now.get(ChronoField.HOUR_OF_DAY); // 0 - 23
        int minuteDay = now.get(ChronoField.MINUTE_OF_DAY); // 0 - 1,439
        int minuteHour = now.get(ChronoField.MINUTE_OF_HOUR); // 0 - 59
        int secondDay = now.get(ChronoField.SECOND_OF_DAY); // 0 - 86,399
        int secondMinute = now.get(ChronoField.SECOND_OF_MINUTE);// 0 - 59
        long nanoDay = now.getLong(ChronoField.NANO_OF_DAY);//0-86399999999
        int nanoSecond = now.get(ChronoField.NANO_OF_SECOND);//0-999999999

        System.out.println("Часы: " + hourAMPM);
        System.out.println("Часы: " + hourDay);
        System.out.println("Минуты дня: " + minuteDay);
        System.out.println("Минуты: " + minuteHour);
        System.out.println("Секунды дня: " + secondDay);
        System.out.println("Секунды: " + secondMinute);
        System.out.println("Наносекунды дня: " + nanoDay);
        System.out.println("Наносекунды: " + nanoSecond);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для сравнение объектов <code>LocalTime</code> используются методы <code>isAfter()</code>, <code>isBefore()</code> и <code>equals()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.LocalTime;

public class CompareLocalTimeDemo {
    public static void main(String[] args) {
        LocalTime fiveThirty = LocalTime.of(5, 30);
        LocalTime noon = LocalTime.of(12, 0, 0);
        LocalTime almostMidnight = LocalTime.of(23, 59, 59, 999999);

        System.out.println("fiveThirty.isAfter(noon)? " + fiveThirty.isAfter(noon)); // false
        System.out.println("fiveThirty.isBefore(noon)? " + fiveThirty.isBefore(noon)); // true
        System.out.println("noon.equals(almostMidnight)? " + noon.equals(almostMidnight)); // false
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для изменения часов, минут или секунд используются методы <code>with()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.LocalTime;
import java.time.temporal.ChronoField;

public class WithLocalTimeDemo {
    public static void main(String[] args) {
        LocalTime noon = LocalTime.of(12, 0, 0);

        LocalTime ten = noon.with(ChronoField.HOUR_OF_DAY, 10);
        LocalTime eight = noon.withHour(8);
        LocalTime twelveThirty = noon.withMinute(30);
        LocalTime thirtyTwoSeconds = noon.withSecond(32);

        // Можно использовать сцепление методов
        LocalTime secondsNano = noon.withSecond(20).withNano(999999);

        System.out.println("ten: " + ten);
        System.out.println("eight: " + eight);
        System.out.println("twelveThirty: " + twelveThirty);
        System.out.println("thirtyTwoSeconds: " + thirtyTwoSeconds);
        System.out.println("secondsNano: " + secondsNano);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий пример показывает использование методов <code>plus()</code>, <code>minus()</code> класса <code>LocalTime</code> для добавления или удаления часов, минут или секунд:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.LocalTime;
import java.time.temporal.ChronoUnit;

public class PlusMinusLocalTimeDemo {
    public static void main(String[] args) {
        LocalTime fiveThirty = LocalTime.of(5, 30);
        // Добавление
        LocalTime sixThirty = fiveThirty.plusHours(1);
        LocalTime fiveForty = fiveThirty.plusMinutes(10);
        LocalTime plusSeconds = fiveThirty.plusSeconds(14);
        LocalTime plusNanos = fiveThirty.plusNanos(99999999);
        LocalTime sevenThirty = fiveThirty.plus(2, ChronoUnit.HOURS);

        // Вычитание
        LocalTime fourThirty = fiveThirty.minusHours(1);
        LocalTime fiveTen = fiveThirty.minusMinutes(20);
        LocalTime minusSeconds = fiveThirty.minusSeconds(2);
        LocalTime minusNanos = fiveThirty.minusNanos(1);
        LocalTime fiveTwenty = fiveThirty.minus(10, ChronoUnit.MINUTES);

        System.out.println("sixThirty: " + sixThirty);
        System.out.println("fiveForty: " + fiveForty);
        System.out.println("plusSeconds: " + plusSeconds);
        System.out.println("plusNanos: " + plusNanos);
        System.out.println("sevenThirty: " + sevenThirty);

        System.out.println("fourThirty: " + fourThirty);
        System.out.println("fiveTen: " + fiveTen);
        System.out.println("minusSeconds: " + minusSeconds);
        System.out.println("minusNanos: " + minusNanos);
        System.out.println("fiveTwenty: " + fiveTwenty);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_класс_localdatetime">10.4. Класс <code>LocalDateTime</code></h3>
<div class="paragraph">
<p>Класс <code>LocalDateTime</code> используется для представления даты и времени. Это комбинация содержимого <code>LocalDate</code> и <code>LocalTime</code>. Например <code>2015-08-25 13:21.05.12345</code>.</p>
</div>
<div class="paragraph">
<p>Рассмотрим пример создания объектов класса <code>LocalDateTime</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

public class LocalDateTimeDemo1 {
    public static void main(String[] args) {
        // Секунды и наносекунды равны нулю
        LocalDateTime date1 = LocalDateTime.of(2014, 9, 19, 14, 5);
        // Наносекунды равны нулю
        LocalDateTime date2 = LocalDateTime.of(2014, 9, 19, 14, 5, 20);
        LocalDateTime date3 = LocalDateTime.of(2014, 9, 19, 14, 5, 20, 9);

        LocalDate date = LocalDate.now();
        LocalDateTime date4 = date.atTime(14, 30, 59, 999999);

        LocalTime time = LocalTime.now();
        LocalDateTime date5 = time.atDate(date);

        System.out.println(date1);
        System.out.println(date2);
        System.out.println(date3);
        System.out.println(date4);
        System.out.println(date5);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий пример показывает использование методов <code>get()</code> класса <code>LocalDateTime</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.LocalDateTime;

public class LocalDateTimeDemo2 {
    public static void main(String[] args) {
        LocalDateTime now = LocalDateTime.now();
        int year = now.getYear();
        int dayYear = now.getDayOfYear();
        int hour = now.getHour();
        int minute = now.getMinute();

        System.out.println("Год: " + year);
        System.out.println("День в году: " + dayYear);
        System.out.println("Часы: " + hour);
        System.out.println("Минуты: " + minute);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Рассмотрим пример использования методов <code>with()</code>, <code>plus()</code>, <code>isAfter()</code>, <code>isBefore()</code> класса <code>LocalDateTime</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.LocalDateTime;
import java.time.temporal.ChronoField;
import java.time.temporal.ChronoUnit;

public class LocalDateTimeDemo3 {
    public static void main(String[] args) {
        LocalDateTime now = LocalDateTime.now();

        LocalDateTime date1 = now.with(ChronoField.HOUR_OF_DAY, 10);
        LocalDateTime date2 = now.withMonth(8);
        LocalDateTime date3 = now.withYear(2013).withMinute(0);

        // Сравнение
        boolean after = now.isAfter(date1);
        boolean before = now.isBefore(date1);
        boolean equal = now.equals(date1);

        // Добавление
        LocalDateTime date4 = now.plusYears(4);
        LocalDateTime date5 = now.plusWeeks(3);
        LocalDateTime date6 = date1.plus(2, ChronoUnit.HOURS);

        // Вычитание
        LocalDateTime date7 = now.minusMonths(2);
        LocalDateTime date8 = now.minusNanos(1);
        LocalDateTime date9 = now.minus(10, ChronoUnit.SECONDS);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_класс_instant">10.5. Класс <code>Instant</code></h3>
<div class="paragraph">
<p>Класс <code>Instant</code> используется для представления <strong>мгновения в секундах</strong> (<strong>Unix-время</strong>/<strong>Unix time</strong>/<strong>POSIX-время</strong>), которые прошли с <em>1 января 1970 года</em> (этот момент называют <strong>эпохой Unix</strong> <strong>(Unix Epoch</strong>). Например: <code>923,456,789</code> секунд и <code>186,054,812</code> наносекунд.</p>
</div>
<div class="paragraph">
<p>Рассмотрим пример использования методов <code>now()</code>, <code>ofEpochSecond()</code>,` ofEpochMilli()` класса <code>Instant</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.Instant;
import java.time.temporal.ChronoField;

public class InstantDemo1 {
    public static void main(String[] args) {
        Instant now = Instant.now();

        Instant instant = now.with(ChronoField.NANO_OF_SECOND, 10);
        // Устанавливаем секунды
        Instant fiveSecondsAfterEpoch = Instant.ofEpochSecond(5);
        // Устанавливаем секунды и наносекунды (могут быть отрицательные)
        Instant sixSecTwoNanBeforeEpoch = Instant.ofEpochSecond(-6, -2);
        // Устанавливаем милисекунды после (могут быть и до) эпохи
        Instant fiftyMilliSecondsAfterEpoch = Instant.ofEpochMilli(50);

        System.out.println("now: " + now);
        System.out.println("instant: " + instant);
        System.out.println("fiveSecondsAfterEpoch: " + fiveSecondsAfterEpoch);
        System.out.println("sixSecTwoNanBeforeEpoch: " + sixSecTwoNanBeforeEpoch);
        System.out.println("fiftyMilliSecondsAfterEpoch: " + fiftyMilliSecondsAfterEpoch);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий пример демонстрирует использование методов <code>get()</code> класса <code>Instant</code> для получения секунд, наносекунд и миллисекунд:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.Instant;
import java.time.temporal.ChronoField;

public class InstantDemo2 {
    public static void main(String[] args) {
        Instant now = Instant.now();
        long seconds = now.getEpochSecond(); // Получить секунды
        int nanos1 = now.getNano(); //Получить наносекунды
        // Получить значение как int
        int millis = now.get(ChronoField.MILLI_OF_SECOND);
        // Получить значение как long
        long nanos2 = now.getLong(ChronoField.NANO_OF_SECOND);

        System.out.println("Секунды: " + seconds);
        System.out.println("Наносекунды: " + nanos1);
        System.out.println("Милисекунды: " + millis);
        System.out.println("Наносекунды: " + nanos2);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Объекты класса <code>Instant</code> можно сравнивать методами <code>isAfter()</code>, <code>isBefore()</code> и <code>equals()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.Instant;

public class InstantDemo3 {
    public static void main(String[] args) {
        Instant now = Instant.now();
        Instant fiveSecondsAfterEpoch = Instant.ofEpochSecond(5);

        System.out.println("now.isAfter(fiveSecondsAfterEpoch)? " + now.isAfter(fiveSecondsAfterEpoch));
        System.out.println("now.isBefore(fiveSecondsAfterEpoch)? " + now.isBefore(fiveSecondsAfterEpoch));
        System.out.println("now.equals(fiveSecondsAfterEpoch)? " + now.equals(fiveSecondsAfterEpoch));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Пример использования методов <code>plus()</code>, <code>minus()</code> класса <code>Instant</code> для добавления секунд, миллисекунд и наносекунд:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.Instant;
import java.time.temporal.ChronoUnit;

public class InstantDemo4 {
    public static void main(String[] args) {
        Instant now = Instant.ofEpochSecond(0);
        // Добавление
        Instant instant1 = now.plusSeconds(400);
        Instant instant2 = now.plusMillis(98622200);
        Instant instant3 = now.plusNanos(300013890);
        Instant instant4 = now.plus(2, ChronoUnit.MINUTES);

        // Вычитание
        Instant instant5 = now.minusSeconds(2);
        Instant instant6 = now.minusMillis(1);
        Instant instant7 = now.minusNanos(1);
        Instant instant8 = now.minus(10, ChronoUnit.SECONDS);

        System.out.println(now);
        System.out.println(instant1);
        System.out.println(instant2);
        System.out.println(instant3);
        System.out.println(instant4);

        System.out.println(instant5);
        System.out.println(instant6);
        System.out.println(instant7);
        System.out.println(instant8);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_класс_zoneddatetime">10.6. Класс <code>ZonedDateTime</code></h3>
<div class="paragraph">
<p>Класс <code>ZonedDateTime</code> представляет дату и время с информацией о часовом поясе. Это может быть начало определенного события где-нибудь в мире, например конференции, запуска ракеты и т.д.</p>
</div>
<div class="paragraph">
<p><code>ZonedDateTimeКласс</code> неизменяемый, это означает, что все методы, выполняющие вычисления над <code>ZonedDateTime</code> объектом, возвращают новый объект <code>ZonedDateTime</code>.</p>
</div>
<div class="sect3">
<h4 id="_создание_zoneddatetime_объектов">10.6.1. Создание <code>ZonedDateTime</code> объектов</h4>
<div class="paragraph">
<p>Создать объект <code>ZonedDateTime</code> можно несколькими способами.</p>
</div>
<div class="paragraph">
<p>Первый способ - вызвать  метод <code>now()</code> класса <code>ZonedDateTime</code>. Вот пример создания объекта <code>ZonedDateTime`с помощью `now()</code> метода:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ZonedDateTime zonedDateTime = ZonedDateTime.now();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Другой способ создать объект <code>ZonedDateTime</code> - использовать метод <code>of()</code>, который может создать <code>ZonedDateTime</code> объект на основе конкретной даты и времени. Вот пример создания объекта <code>ZonedDateTime</code> с помощью метода <code>of()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ZoneId zoneId = ZoneId.of("UTC+1");

ZonedDateTime zonedDateTime2 =
    ZonedDateTime.of(2015, 11, 30, 23, 45, 59, 1234, zoneId);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_доступ_к_дате_и_времени_zoneddatetime">10.6.2. Доступ к дате и времени <code>ZonedDateTime</code></h4>
<div class="paragraph">
<p>Можно получить доступ к полям даты и времени <code>ZonedDateTime</code> экземпляра, используя один из следующих методов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getYear()</code></p>
</li>
<li>
<p><code>getMonth()</code></p>
</li>
<li>
<p><code>getDayOfMonth()</code></p>
</li>
<li>
<p><code>getDayOfWeek()</code></p>
</li>
<li>
<p><code>getDayOfYear()</code></p>
</li>
<li>
<p><code>getHour()</code></p>
</li>
<li>
<p><code>getMinute()</code></p>
</li>
<li>
<p><code>getSecond()</code></p>
</li>
<li>
<p><code>getNano()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример доступа к году ZonedDateTime:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int year = ZonedDateTime.now().getYear();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Некоторые из этих методов возвращают <strong>enum</strong>, а другие возвращают <code>int</code>. Из <strong>enums</strong> можно получить <code>int</code> представление их значения, используя метод <code>getValue()</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">int month = ZonedDateTime.now().getMonth().getValue();</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_расчет_даты_и_времени">Расчет даты и времени</h5>
<div class="paragraph">
<p>Класс <code>ZonedDateTime</code> содержит набор методов, используемых для расчета даты и времени. Вот некоторые из этих методов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>plusYears()</code></p>
</li>
<li>
<p><code>plusMonths()</code></p>
</li>
<li>
<p><code>plusDays()</code></p>
</li>
<li>
<p><code>plusHours()</code></p>
</li>
<li>
<p><code>plusMinutes</code></p>
</li>
<li>
<p><code>plusSeconds</code></p>
</li>
<li>
<p><code>plusNanos()</code></p>
</li>
<li>
<p><code>minusYears()</code></p>
</li>
<li>
<p><code>minusMonths()</code></p>
</li>
<li>
<p><code>minusDays()</code></p>
</li>
<li>
<p><code>minusHours()</code></p>
</li>
<li>
<p><code>minusMinutes</code></p>
</li>
<li>
<p><code>minusSeconds</code></p>
</li>
<li>
<p><code>minusNanos()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Имейте в виду, что расчеты, которые охватывают изменения летнего времени (начало или конец), могут не дать ожидаемого результата! Альтернативой является использование экземпляра класса <code>Period</code>, например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ZonedDateTime newZoneDateTime = previousDateTime.plus(Period.ofDays(3));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это должно привести к более правильному расчету.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_часовые_пояса">10.6.3. Часовые пояса</h4>
<div class="paragraph">
<p>Часовые пояса представлены классом <code>ZoneId</code>, как показано в предыдущем примере. Можно создать объект <code>ZoneId</code> с помощью  метода <code>now()</code>. Вот пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ZoneId zoneId = ZoneId.of("UTC+1");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Параметр, передаваемый <code>of()</code> методу, - это идентификатор часового пояса, для которого создается <code>ZoneId</code> . В приведенном выше примере идентификатором является <code>UTC+1</code>, который является смещением от времени <strong>UTC</strong> (<strong>по Гринвичу</strong>). Можно найти смещение <strong>UTC</strong> для желаемого часового пояса и создать соответствующий ему идентификатор, объединив <code>UTC</code> со смещением (например, <code>+1</code> или <code>-5</code>).</p>
</div>
<div class="paragraph">
<p>Вы также можете использовать другой тип идентификатора часового пояса, который состоит из названия места, где этот часовой пояс активен. Вот пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ZoneId zoneId2 = ZoneId.of("Europe/Copenhagen");
ZoneId zoneId3 = ZoneId.of("Europe/Paris");</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_класс_period">10.7. Класс <code>Period</code></h3>
<div class="paragraph">
<p>Класс <code>Period</code> представляет количество времени в годах, месяцах и днях. Например: 5 лет, 2 месяца и 9 дней.</p>
</div>
<div class="paragraph">
<p>Рассмотрим пример создания объектов класса <code>Period</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.Period;

public class PeriodDemo1 {
    public static void main(String[] args) {
        Period period5y4m3d = Period.of(5, 4, 3);
        Period period2d = Period.ofDays(2);
        Period period2m = Period.ofMonths(2);
        Period period14d = Period.ofWeeks(2);
        Period period2y = Period.ofYears(2);

        System.out.println(period5y4m3d);
        System.out.println(period2d);
        System.out.println(period2m);
        System.out.println(period14d);
        System.out.println(period2y);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Период можно рассматривать как разницу между двумя <code>LocalDate</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.LocalDate;
import java.time.Period;

public class PeriodDemo2 {
    public static void main(String[] args) {
        LocalDate march2003 = LocalDate.of(2003, 3, 1);
        LocalDate may2003 = LocalDate.of(2003, 5, 1);
        Period dif = Period.between(march2003, may2003);
        System.out.println(dif);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий пример показывает использование методов <code>get()</code> класса <code>Period</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.Period;
import java.time.temporal.ChronoUnit;

public class PeriodDemo4 {
    public static void main(String[] args) {
        Period period5y4m3d = Period.of(5, 4, 3);
        int days = period5y4m3d.getDays();
        int months = period5y4m3d.getMonths();
        int year = period5y4m3d.getYears();
        long days2 = period5y4m3d.get(ChronoUnit.DAYS);

        System.out.println("Дни: " + days);
        System.out.println("Месяца: " + months);
        System.out.println("Годы: " + year);
        System.out.println("Дни: " + days2);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для изменения года, месяца или дня используются методы <code>with()</code> класса <code>Period</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.Period;

public class PeriodDemo5 {
    public static void main(String[] args) {
        Period period2d = Period.ofDays(2);
        Period period8d = period2d.withDays(8);
        Period period2y1m2d = period2d.withYears(2).withMonths(1);

        System.out.println(period2d);
        System.out.println(period8d);
        System.out.println(period2y1m2d);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для добавления или удаления года, месяца или дня используются методы <code>plus()</code>, <code>minus()</code> класса <code>Period</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.Period;

public class PeriodDemo6 {
    public static void main(String[] args) {
        Period period5y4m3d = Period.of(5, 4, 3);
        Period period2y = Period.ofYears(2);
        // Добавление
        System.out.println(period5y4m3d.plusYears(4));
        System.out.println(period5y4m3d.plusMonths(3));
        System.out.println(period5y4m3d.plusDays(3));
        System.out.println(period5y4m3d.plus(period2y));

        // Вычитание
        System.out.println(period5y4m3d.minusYears(2));
        System.out.println(period5y4m3d.minusMonths(1));
        System.out.println(period5y4m3d.minusDays(1));
        System.out.println(period5y4m3d.minus(period2y));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_класс_duration">10.8. Класс <code>Duration</code></h3>
<div class="paragraph">
<p>Класс <code>Duration</code> служит для хранения продолжительности времени на основе секунд и наносекунд. Например: <code>12.87656</code> секунд.</p>
</div>
<div class="paragraph">
<p>Также для отображения длительности можно использовать и другие величины, вроде минут, часов, дней. Однако, основное предназначение этого класса - представление небольших промежутков времени. Для работы с длительными промежутками времени предназначен другой класс - <code>Period</code>.</p>
</div>
<div class="paragraph">
<p>Рассмотрим пример создания объектов класса <code>java.time.Duration</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.Duration;
import java.time.temporal.ChronoUnit;

public class DurationDemo1 {
    public static void main(String[] args) {
        Duration oneDay = Duration.ofDays(1);
        Duration oneHour = Duration.ofHours(1);
        Duration oneMin = Duration.ofMinutes(1);
        Duration tenSeconds = Duration.ofSeconds(10);
        Duration twoSeconds = Duration.ofSeconds(1, 1_000_000_000);
        Duration oneSecondFromMillis = Duration.ofMillis(1);
        Duration oneSecondFromNanos = Duration.ofNanos(1000000000);
        Duration oneSecond = Duration.of(1, ChronoUnit.SECONDS);

        System.out.println("oneDay: " + oneDay);
        System.out.println("oneHour: " + oneHour);
        System.out.println("oneMin: " + oneMin);
        System.out.println("tenSeconds: " + tenSeconds);
        System.out.println("twoSeconds: " + twoSeconds);
        System.out.println("oneSecondFromMillis: "+oneSecondFromMillis);
        System.out.println("oneSecondFromNanos: "+oneSecondFromNanos);
        System.out.println("oneSecond: "+oneSecond);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_класс_datetimeformatter">10.9. Класс <code>DateTimeFormatter</code></h3>
<div class="paragraph">
<p>Класс <code>DateTimeFormatter</code> используется в Java 8 при форматировании и разборе даты.</p>
</div>
<div class="paragraph">
<p>Для создания объекта этого класса используется статический метод <code>ofPattern()</code>, на вход которого передается строка и объект класс <code>Locale</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MMMM, dd, yyyy HH:mm:ss", Locale.US);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Строка описывает формат написания даты и времени. Если локаль не указана, используется текущая локаль.</p>
</div>
<div class="paragraph">
<p>В следующей табличке указаны возможные символы, для описания формата даты:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Символ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Что означает</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Пример</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>y</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">год в эре</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2014; 14</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>M/L</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">месяц (название или номер)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">9; 09; Sep; September; S</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>d</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">день месяца</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">17</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>E</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">день недели</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Вт; вторник</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>h</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">время в 12-часовом формате</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>H</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">часы в 24-часовом формате</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>m</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">минуты</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>s</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">секунды</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>S</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">миллисекунды</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">109</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Для разбора даты и времени из строковых значений существует два статических метода <code>parse()</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>parse(CharSequence text)</code> - конвертация строки, которая содержит дату и время, в объект <code>LocalDateTime</code>. При этом используется формат строки вида <code>2007-12-03T10:15:30</code>.</p>
</li>
<li>
<p><code>parse(CharSequence text, DateTimeFormatter formatter)</code> - конвертация строки, которая содержит дату и время, в объект <code>LocalDateTime</code> с использованием указанного формата.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Рассмотрим пример разбора даты:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class FormatLocalDateTimeDemo1 {
    public static void main(String[] args) {
        DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern("MMMM d, yyyy HH:mm:ss");
        LocalDateTime localDateTime = LocalDateTime.parse("июня 5, 2018 12:10:56", formatter1);
        System.out.println(localDateTime);

        DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern("MMMM d, yyyy");
        LocalDate localDate = LocalDate.parse("июня 5, 2018", formatter2);
        System.out.println(localDate);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий пример описывает форматирование даты:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

public class FormatLocalDateTimeDemo2 {
    public static void main(String[] args) {
        LocalDateTime dateTime = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MMMM, dd, yyyy HH:mm:ss", Locale.US);
        System.out.println(dateTime.format(formatter));
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_java_inputoutput">11. Java Input/Output</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_java_io">11.1. Java IO</h3>
<div class="paragraph">
<p>Отличительной чертой многих языков программирования является работа с файлами и потоками. В Java основной функционал работы с потоками сосредоточен в классах из пакета <code>java.io</code>.</p>
</div>
<div class="paragraph">
<p>Ключевым понятием здесь является понятие <strong>потока</strong>. Хотя понятие "поток" в программировании довольно перегружено и может обозначать множество различных концепций. В данном случае применительно к работе с файлами и вводом-выводом будет говориться о <strong>потоке</strong> (<strong>stream</strong>), как об абстракции, которая используется для чтения или записи информации (файлов, сокетов, текста консоли и т.д.).</p>
</div>
<div class="paragraph">
<p><strong>Поток</strong> связан с реальным физическим устройством с помощью системы ввода-вывода Java. Может быть определен поток, который связан с файлом и через который можно вести чтение или запись файла. Это также может быть поток, связанный с сетевым сокетом, с помощью которого можно получить или отправить данные в сети. Все эти задачи: чтение и запись различных файлов, обмен информацией по сети, ввод-ввывод в консоли решаются в Java с помощью потоков.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/assets/img/java/core/io/java-io.png" alt="Java IO"></span></p>
</div>
<div class="paragraph">
<p>Объект, из которого можно считать данные, называется <strong>потоком ввода</strong>, а объект, в который можно записывать данные, - <strong>потоком вывода</strong>. Например, если надо считать содержание файла, то применяется поток ввода, а если надо записать в файл - то поток вывода.</p>
</div>
<div class="paragraph">
<p>В основе всех классов, управляющих <strong>потоками байтов</strong>, находятся два абстрактных класса: <code>InputStream</code> (представляющий потоки ввода) и <code>OutputStream</code> (представляющий потоки вывода)</p>
</div>
<div class="paragraph">
<p>Но поскольку работать с байтами не очень удобно, то для работы с <strong>потоками символов</strong> были добавлены абстрактные классы <code>Reader</code> (для чтения потоков символов) и <code>Writer</code> (для записи потоков символов).</p>
</div>
<div class="paragraph">
<p>Все остальные классы, работающие с потоками, являются наследниками этих абстрактных классов. Основные классы потоков:</p>
</div>
<div class="paragraph">
<p>Byte Based:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Type</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Input</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Output</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Basic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">InputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OutputStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Arrays</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ByteArrayInputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ByteArrayOutputStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Files</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FileInputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FileOutputStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Files</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RandomAccessFile</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RandomAccessFile</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pipes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PipedInputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PipedOutputStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Buffering</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BufferedInputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BufferedOutputStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Filtering</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FilterInputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FilterOutputStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parsing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PushbackInputStream</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parsing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">StreamTokenizer</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Data</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DataInputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DataOutputStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Data-Formatted</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PrintStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Objects</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ObjectInputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ObjectOutputStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Utilities</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SequenceInputStream</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Character Based:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Type</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Input</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Output</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Basic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Writer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Basic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">InputStreamReader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OutputStreamWriter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Arrays</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CharArrayReader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CharArrayWriter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Files</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FileReader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FileWriter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pipes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PipedReader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PipedWriter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Buffering</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BufferedReader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BufferedWriter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Filtering</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FilterReader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FilterWriter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parsing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PushbackReader</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parsing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LineNumberReader</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Strings</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">StringReader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">StringWriter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Data-Formatted</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PrintWriter</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_абстрактный_класс_inputstream">11.1.1. Абстрактный класс <code>InputStream</code></h4>
<div class="paragraph">
<p>Класс <code>InputStream</code> является базовым для всех классов, управляющих байтовыми потоками ввода. Рассмотрим его основные методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>int available()</code> возвращает количество байтов, доступных для чтения в потоке</p>
</li>
<li>
<p><code>void close()</code> закрывает поток</p>
</li>
<li>
<p><code>int read()</code> возвращает целочисленное представление следующего байта в потоке. Когда в потоке не останется доступных для чтения байтов, данный метод возвратит число <code>-1</code></p>
</li>
<li>
<p><code>int read(byte[] buffer)</code> считывает байты из потока в массив <code>buffer</code>. После чтения возвращает число считанных байтов. Если ни одного байта не было считано, то возвращается число <code>-1</code></p>
</li>
<li>
<p><code>int read(byte[] buffer, int offset, int length)</code> считывает некоторое количество байтов, равное <code>length</code>, из потока в массив <code>buffer</code>. При этом считанные байты помещаются в массиве, начиная со смещения <code>offset</code>, то есть с элемента <code>buffer[offset]</code>. Метод возвращает число успешно прочитанных байтов.</p>
</li>
<li>
<p><code>long skip(long number)</code> пропускает в потоке при чтении некоторое количество байт, которое равно <code>number</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_абстрактный_класс_outputstream">11.1.2. Абстрактный класс <code>OutputStream</code></h4>
<div class="paragraph">
<p>Класс <code>OutputStream</code> является базовым классом для всех классов, которые работают с бинарными потоками записи. Свою функциональность он реализует через следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void close()</code> закрывает поток</p>
</li>
<li>
<p><code>void flush()</code> очищает буфер вывода, записывая все его содержимое</p>
</li>
<li>
<p><code>void write(int b)</code> записывает в выходной поток один байт, который представлен целочисленным параметром <code>b</code></p>
</li>
<li>
<p><code>void write(byte[] buffer)</code> записывает в выходной поток массив байтов <code>buffer</code></p>
</li>
<li>
<p><code>void write(byte[] buffer, int offset, int length)</code> записывает в выходной поток некоторое число байтов, равное <code>length</code>, из массива <code>buffer</code>, начиная со смещения <code>offset</code>, то есть с элемента <code>buffer[offset]</code></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_абстрактный_класс_reader">Абстрактный класс <code>Reader</code></h5>
<div class="paragraph">
<p>Абстрактный класс <code>Reader</code> предоставляет функционал для чтения текстовой информации. Рассмотрим его основные методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>absract void close()</code> закрывает поток ввода</p>
</li>
<li>
<p><code>int read()</code> возвращает целочисленное представление следующего символа в потоке. Если таких символов нет, и достигнут конец файла, то возвращается число <code>-1</code></p>
</li>
<li>
<p><code>int read(char[] buffer)</code> считывает в массив <code>buffer</code> из потока символы, количество которых равно длине массива <code>buffer</code>. Возвращает количество успешно считанных символов. При достижении конца файла возвращает <code>-1</code></p>
</li>
<li>
<p><code>int read(CharBuffer buffer)</code> считывает в объект <code>CharBuffer</code> из потока символы. Возвращает количество успешно считанных символов. При достижении конца файла возвращает <code>-1</code></p>
</li>
<li>
<p><code>absract int read(char[] buffer, int offset, int count)</code> считывает в массив <code>buffer</code>, начиная со смещения <code>offset</code>, из потока символы, количество которых равно <code>count</code></p>
</li>
<li>
<p><code>long skip(long count)</code> пропускает количество символов, равное <code>count</code>. Возвращает число успешно пропущенных символов</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_абстрактный_класс_writer">11.1.3. Абстрактный класс <code>Writer</code></h4>
<div class="paragraph">
<p>Класс <code>Writer</code> определяет функционал для всех символьных потоков вывода. Его основные методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Writer append(char c)</code> добавляет в конец выходного потока символ <code>c</code>. Возвращает объект <code>Writer</code></p>
</li>
<li>
<p><code>Writer append(CharSequence chars)</code> добавляет в конец выходного потока набор символов <code>chars</code>. Возвращает объект <code>Writer</code></p>
</li>
<li>
<p><code>abstract void close()</code> закрывает поток</p>
</li>
<li>
<p><code>abstract void flush()</code> очищает буферы потока</p>
</li>
<li>
<p><code>void write(int c)</code> записывает в поток один символ, который имеет целочисленное представление</p>
</li>
<li>
<p><code>void write(char[] buffer)</code> записывает в поток массив символов</p>
</li>
<li>
<p><code>absract void write(char[] buffer, int off, int len) ` записывает в поток только несколько символов из массива `buffer</code>. Причем количество символов равно <code>len</code>, а отбор символов из массива начинается с индекса <code>off</code></p>
</li>
<li>
<p><code>void write(String str)</code> записывает в поток строку</p>
</li>
<li>
<p><code>void write(String str, int off, int len)</code> записывает в поток из строки некоторое количество символов, которое равно <code>len</code>, причем отбор символов из строки начинается с индекса <code>off</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_интерфейс_closeable">11.2. Интерфейс <code>Closeable</code></h3>
<div class="paragraph">
<p>При завершении работы с потоком его надо закрыть с помощью метода <code>close()</code>, который определен в интерфейсе <code>Closeable</code>. Метод <code>close</code> имеет следующее определение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">void close() throws IOException</code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот интерфейс уже реализуется в классах <code>InputStream</code> и <code>OutputStream</code>, а через них и во всех классах потоков.</p>
</div>
<div class="paragraph">
<p>При закрытии потока освобождаются все выделенные для него ресурсы, например, файл. В случае, если поток окажется не закрыт, может происходить утечка памяти.</p>
</div>
<div class="paragraph">
<p>Есть два способа закрытия файла:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>использование блока <code>try..catch..finally</code></p>
</li>
<li>
<p>использование конструкции <code>try-with-resource</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Используем первый (традиционный) способ и считаем данные из файла:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.FileInputStream;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        FileInputStream fin = null;
        try {
            fin = new FileInputStream("C://SomeDir//notes.txt");
            int i = -1;
            while ((i = fin.read()) != -1) {
                System.out.print((char) i);
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        } finally {
            try {
                if (fin != null)
                    fin.close();
            } catch (IOException ex) {
                System.out.println(ex.getMessage());
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Поскольку при открытии или считывании файла может произойти ошибка ввода-вывода, то код считывания помещается в блок <code>try</code>. И чтобы быть уверенным, что поток в любом случае закроется, даже если при работе с ним возникнет ошибка, вызов метода <code>close()</code> помещается в блок <code>finally</code>. И, так как метод <code>close()</code> также в случае ошибки может генерировать исключение <code>IOException</code>, то его вызов также помещается во вложенный блок <code>try..catch</code>.</p>
</div>
<div class="paragraph">
<p>Начиная с Java 7 можно использовать второй способ, который автоматически вызывает метод <code>close</code>. Этот способ заключается в использовании конструкции <strong>try-with-resources</strong> (<strong>try с ресурсами</strong>). Данная конструкция работает с объектами, которые реализуют интерфейс <code>AutoCloseable</code>. Так как все классы потоков реализуют интерфейс <code>Closeable</code>, который в свою очередь наследуется от <code>AutoCloseable</code>, то их также можно использовать в данной конструкции.</p>
</div>
<div class="paragraph">
<p>Предыдущий пример с использованием конструкции <strong>try-with-resources</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.FileInputStream;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        try (FileInputStream fin = new FileInputStream("C://SomeDir//notes.txt")) {
            int i = -1;
            while ((i = fin.read()) != -1) {
                System.out.print((char) i);
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Синтаксис конструкции следующий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">try(название_класса имя_переменной = конструктор_класса) {
    // code
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Данная конструкция также не исключает использования блоков <code>catch</code>.</p>
</div>
<div class="paragraph">
<p>После окончания работы в блоке <code>try</code> у ресурса (в данном случае у объекта <code>FileInputStream</code>) автоматически вызывается метод <code>close()</code>.</p>
</div>
<div class="paragraph">
<p>Если нам надо использовать несколько потоков, которые после выполнения надо закрыть, то мы можем указать объекты потоков через точку с запятой:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">try (FileInputStream fin = new FileInputStream("C://SomeDir//Hello.txt");
        FileOutputStream fos = new FileOutputStream("C://SomeDir//Hello2.txt")) {
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_класс_file">11.3. Класс <code>File</code></h3>
<div class="paragraph">
<p>Класс <code>File</code>, определенный в пакете <code>java.io</code>, не работает напрямую с потоками. Его задачей является управление информацией о файлах и директориях. Хотя на уровне операционной системы файлы и директории отличаются, но в Java они описываются одним классом <code>File</code>.</p>
</div>
<div class="paragraph">
<p>В зависимости от того, что должен представлять объект <code>File</code> - файл или директория, мы можем использовать один из конструкторов для создания объекта:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>File(String путь_к_директории)</code></p>
</li>
<li>
<p><code>File(String путь_к_директории, String имя_файла)</code></p>
</li>
<li>
<p><code>File(File каталог, String имя_файла)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">// создаем объект File для директории
File dir1 = new File("C://SomeDir");
// создаем объекты для файлов, которые находятся в директории
File file1 = new File("C://SomeDir", "Hello.txt");
File file2 = new File(dir1, "Hello2.txt");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Класс <code>File</code> имеет ряд методов, которые позволяют управлять файлами и директориями. Рассмотрим некоторые из них:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boolean createNewFile()</code> создает новый файл по пути, который передан в конструктор. В случае удачного создания возвращает <code>true</code>, иначе <code>false</code></p>
</li>
<li>
<p><code>boolean delete()</code> удаляет директорию или файл по пути, который передан в конструктор. При удачном удалении возвращает <code>true</code></p>
</li>
<li>
<p><code>boolean exists()</code> проверяет, существует ли по указанному в конструкторе пути файл или директория. И если файл или директория существует, то возвращает <code>true</code>, иначе возвращает <code>false</code></p>
</li>
<li>
<p><code>String getAbsolutePath()</code> возвращает абсолютный путь для пути, переданного в конструктор объекта</p>
</li>
<li>
<p><code>String getName()</code> возвращает краткое имя файла или директории</p>
</li>
<li>
<p><code>String getParent()</code> возвращает имя родительской директории</p>
</li>
<li>
<p><code>boolean isDirectory()</code> возвращает значение <code>true</code>, если по указанному пути располагается директория</p>
</li>
<li>
<p><code>boolean isFile()</code> возвращает значение <code>true</code>, если по указанному пути находится файл</p>
</li>
<li>
<p><code>boolean isHidden()</code> возвращает значение <code>true</code>, если директория или файл являются скрытыми</p>
</li>
<li>
<p><code>long length()</code> возвращает размер файла в байтах</p>
</li>
<li>
<p><code>long lastModified()</code> возвращает время последнего изменения файла или директории. Значение представляет количество миллисекунд, прошедших с начала эпохи <strong>Unix</strong></p>
</li>
<li>
<p><code>String[] list()</code> возвращает массив файлов и поддиректорий, которые находятся в определенной директории</p>
</li>
<li>
<p><code>File[] listFiles()</code> возвращает массив файлов и поддиректорий, которые находятся в определенной директории</p>
</li>
<li>
<p><code>boolean mkdir()</code> создает новую директорию и при удачном создании возвращает значение <code>true</code></p>
</li>
<li>
<p><code>boolean renameTo(File dest)</code> переименовывает файл или директорию</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_работа_с_директориями">11.3.1. Работа с директориями</h4>
<div class="paragraph">
<p>Если объект <code>File</code> представляет директорию, то его метод <code>isDirectory()</code> возвращает <code>true</code>. И поэтому мы можем получить ее содержимое - вложенные поддиректории и файлы с помощью методов <code>list()</code> и <code>listFiles()</code>. Получим все поддиректории и файлы в определенной директории:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.File;

public class Program {
    public static void main(String[] args) {
        // определяем объект для каталога
        File dir = new File("C://SomeDir");
        // если объект представляет каталог
        if (dir.isDirectory()) {
            // получаем все вложенные объекты в каталоге
            for (File item : dir.listFiles()) {
                if (item.isDirectory()) {
                    System.out.println(item.getName() + "  \t folder");
                } else {
                    System.out.println(item.getName() + "\t file");
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь выполним еще ряд операций с директорией, как удаление, переименование и создание:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.File;

public class Program {
    public static void main(String[] args) {
        // определяем объект для каталога
        File dir = new File("C://SomeDir//NewDir");
        boolean created = dir.mkdir();
        if (created) {
            System.out.println("Folder has been created");
        }
        // переименуем каталог
        File newDir = new File("C://SomeDir//NewDirRenamed");
        dir.renameTo(newDir);
        // удалим каталог
        boolean deleted = newDir.delete();
        if (deleted) {
            System.out.println("Folder has been deleted");
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_работа_с_файлами">11.3.2. Работа с файлами</h4>
<div class="paragraph">
<p>Работа с файлами аналогична работе с директориями. Например, получим данные по одному из файлов и создадим еще один файл:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.File;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        // определяем объект для каталога
        File myFile = new File("C://SomeDir//notes.txt");
        System.out.println("File name: " + myFile.getName());
        System.out.println("Parent folder: " + myFile.getParent());
        if (myFile.exists()) {
            System.out.println("File exists");
        } else {
            System.out.println("File not found");
        }

        System.out.println("File size: " + myFile.length());
        if (myFile.canRead()) {
            System.out.println("File can be read");
        } else {
            System.out.println("File can not be read");
        }

        if (myFile.canWrite()) {
            System.out.println("File can be written");
        } else {
            System.out.println("File can not be written");
        }
        // создадим новый файл
        File newFile = new File("C://SomeDir//MyFile");
        try {
            boolean created = newFile.createNewFile();
            if (created) {
                System.out.println("File has been created");
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>При создании нового файла метод <code>createNewFile()</code> в случае неудачи выбрасывает исключение <code>IOException</code>, поэтому нам надо его отлавливать, например, в блоке <code>try&#8230;&#8203;catch</code>, как делается в примере выше.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_классы_fileoutputstream_и_fileinputstream">11.4. Классы <code>FileOutputStream</code> и <code>FileInputStream</code></h3>
<div class="sect3">
<h4 id="_запись_файлов_и_класс_fileoutputstream">11.4.1. Запись файлов и класс <code>FileOutputStream</code></h4>
<div class="paragraph">
<p>Класс <code>FileOutputStream</code> предназначен для записи байтов в файл. Он является производным от класса <code>OutputStream</code>, поэтому наследует всю его функциональность.</p>
</div>
<div class="paragraph">
<p>Через конструктор класса <code>FileOutputStream</code> задается файл, в который производится запись. Класс поддерживает несколько конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FileOutputStream(String filePath)</code></p>
</li>
<li>
<p><code>FileOutputStream(File fileObj)</code></p>
</li>
<li>
<p><code>FileOutputStream(String filePath, boolean append)</code></p>
</li>
<li>
<p><code>FileOutputStream(File fileObj, boolean append)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Файл задается либо через строковый путь, либо через объект <code>File</code>. Второй параметр - <code>append</code> задает способ записи: eсли он равен <code>true</code>, то данные дозаписываются в конец файла, а при <code>false</code> - файл полностью перезаписывается</p>
</div>
<div class="paragraph">
<p>Например, запишем в файл строку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.FileOutputStream;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        String text = "Hello world!"; // строка для записи
        try (FileOutputStream fos = new FileOutputStream("C://SomeDir//notes.txt")) {
            byte[] buffer = text.getBytes(); // перевод строки в байты
            fos.write(buffer, 0, buffer.length);
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
        System.out.println("The file has been written");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для создания объекта <code>FileOutputStream</code> используется конструктор, принимающий в качестве параметра путь к файлу для записи. Если такого файла нет, то он автоматически создается при записи. Так как здесь записываем строку, то ее надо сначала перевести в массив байтов. И с помощью метода <code>write()</code> строка записывается в файл.</p>
</div>
<div class="paragraph">
<p>Для автоматического закрытия файла и освобождения ресурса объект <code>FileOutputStream</code> создается с помощью конструктции <code>try&#8230;&#8203;catch</code>.</p>
</div>
<div class="paragraph">
<p>При этом необязательно записывать весь массив байтов. Используя перегрузку метода <code>write()</code>, можно записать и одиночный байт:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">fos.write(buffer[0]); // запись первого байта</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_чтение_файлов_и_класс_fileinputstream">11.4.2. Чтение файлов и класс <code>FileInputStream</code></h4>
<div class="paragraph">
<p>Для считывания данных из файла предназначен класс <code>FileInputStream</code>, который является наследником класса <code>InputStream</code> и поэтому реализует все его методы.</p>
</div>
<div class="paragraph">
<p>Для создания объекта <code>FileInputStream</code> мы можем использовать ряд конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FileInputStream(File file)</code> открывает соединение с файлом, <code>file</code> является <code>Object</code> типа <code>File</code> к считываемому файлу</p>
</li>
<li>
<p><code>​​FileInputStream(FileDescriptor fdObj)</code> используя файловый дескриптор <code>fdObj</code>, который представляет существующее соединение с файлом в файловой системе</p>
</li>
<li>
<p><code>FileInputStream(String name)</code> открывает соединение с файлом, <code>name</code> является путем к считываемому файлу</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если файл не может быть открыт, например, по указанному пути такого файла не существует, то генерируется исключение <code>FileNotFoundException</code>.</p>
</div>
<div class="paragraph">
<p>Считаем данные из ранее записанного файла и выведем на консоль:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.FileInputStream;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        try (FileInputStream fin = new FileInputStream("C://SomeDir//notes.txt")) {
            System.out.printf("File size: %d bytes \n", fin.available());
            int i = -1;
            while ((i = fin.read()) != -1) {
                System.out.print((char) i);
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае мы считываем каждый отдельный байт в переменную <code>i</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">while ((i = fin.read()) != -1) {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Когда в потоке больше нет данных для чтения, метод возвращает число <code>-1</code>.</p>
</div>
<div class="paragraph">
<p>Затем каждый считанный байт конвертируется в объект типа <code>char</code> и выводится на консоль.</p>
</div>
<div class="paragraph">
<p>Подобным образом можно считать данные в массив байтов и затем производить с ним манипуляции:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">byte[] buffer = new byte[fin.available()]; // считаем файл в буфер
fin.read(buffer, 0, fin.available());
System.out.println("File data:");
for (int i = 0; i &lt; buffer.length; i++) {
    System.out.print((char) buffer[i]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Совместим оба класса и выполним чтение из одного и запись в другой файл:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        try (FileInputStream fin = new FileInputStream("C://SomeDir//notes.txt");
             FileOutputStream fos = new FileOutputStream("C://SomeDir//notes_new.txt")) {
            byte[] buffer = new byte[fin.available()]; // считываем буфер
            fin.read(buffer, 0, buffer.length); // записываем из буфера в файл
            fos.write(buffer, 0, buffer.length);
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Классы <code>FileInputStream</code> и <code>FileOutputStream</code> предназначены прежде всего для записи двоичных файлов, то есть для записи и чтения байтов. И хотя они также могут использоваться для работы с текстовыми файлами, но все же для этой задачи больше подходят другие классы.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_классы_bytearrayinputstream_и_bytearrayoutputstream">11.5. Классы <code>ByteArrayInputStream</code> и <code>ByteArrayOutputStream</code></h3>
<div class="paragraph">
<p>Для работы с массивами байтов - их чтения и записи используются классы <code>ByteArrayInputStream</code> и <code>ByteArrayOutputStream</code>.</p>
</div>
<div class="sect3">
<h4 id="_чтение_массива_байтов_и_класс_bytearrayinputstream">11.5.1. Чтение массива байтов и класс <code>ByteArrayInputStream</code></h4>
<div class="paragraph">
<p>Класс ByteArrayInputStream представляет входной поток, использующий в качестве источника данных массив байтов. Он имеет следующие конструкторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ByteArrayInputStream(byte[] buf)</code></p>
</li>
<li>
<p><code>ByteArrayInputStream(byte[] buf, int offset, int length)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В качестве параметров конструкторы используют массив байтов <code>buf</code>, из которого производится считывание, смещение относительно начала массива <code>offset</code> и количество считываемых символов <code>length</code>.</p>
</div>
<div class="paragraph">
<p>Считаем массив байтов и выведем его на экран:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.ByteArrayInputStream;

public class Program {
    public static void main(String[] args) {
        byte[] array1 = new byte[] {1, 3, 5, 7};
        ByteArrayInputStream byteStream1 = new ByteArrayInputStream(array1);
        int b;
        while ((b = byteStream1.read()) != -1) {
            System.out.println(b);
        }
        String text = "Hello world!";
        byte[] array2 = text.getBytes();
        ByteArrayInputStream byteStream2 = new ByteArrayInputStream(array2, 0, 5); // считываем 5 символов
        int c;
        while ((c = byteStream2.read()) != -1) {
            System.out.println((char) c);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В отличие от других классов потоков для закрытия объекта <code>ByteArrayInputStream</code> не требуется вызывать метод <code>close()</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_запись_массива_байт_и_класс_bytearrayoutputstream">11.5.2. Запись массива байт и класс <code>ByteArrayOutputStream</code></h4>
<div class="paragraph">
<p>Класс <code>ByteArrayOutputStream</code> представляет поток вывода, использующий массив байтов в качестве места вывода.</p>
</div>
<div class="paragraph">
<p>Чтобы создать объект данного класса, мы можем использовать один из его конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ByteArrayOutputStream()</code></p>
</li>
<li>
<p><code>ByteArrayOutputStream(int size)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Первая версия создает массив для хранения байтов длиной в <strong>32 байта</strong>, а вторая версия создает массив длиной <code>size</code>.</p>
</div>
<div class="paragraph">
<p>Рассмотрим применение класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.ByteArrayOutputStream;

public class Program {
    public static void main(String[] args) {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        String text = "Hello Wolrd!";
        byte[] buffer = text.getBytes();
        try {
            baos.write(buffer);
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        System.out.println(baos.toString()); // превращаем массив байтов в строку
        byte[] array = baos.toByteArray(); // получаем массив байтов и выводим по символьно
        for (byte b : array) {
            System.out.print((char) b);
        }
        System.out.println();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как и в других потоках вывода в классе <code>ByteArrayOutputStream</code> определен метод <code>write()</code>, который записывает в поток некоторые данные. В данном случае мы записываем в поток массив байтов. Этот массив байтов записывается в объекте <code>ByteArrayOutputStream</code> в защищенное поле <code>buf</code>, которое представляет также массив байтов <code>(protected byte[] buf)</code>.</p>
</div>
<div class="paragraph">
<p>Так как метод <code>write()</code> может сгенерировать исключение, то вызов этого метода помещается в блок <code>try&#8230;&#8203;catch</code>.</p>
</div>
<div class="paragraph">
<p>Используя методы <code>toString()</code> и <code>toByteArray()</code>, можно получить массив байтов <code>buf</code> в виде текста или непосредственно в виде массива байт.</p>
</div>
<div class="paragraph">
<p>С помощью метода <code>writeTo()</code> мы можем вывести массив байт в другой поток. Данный метод в качестве параметра принимает объект <code>OutputStream</code>, в который производится запись массива байт:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ByteArrayOutputStream baos = new ByteArrayOutputStream();
String text = "Hello Wolrd!";
byte[] buffer = text.getBytes();
try {
    baos.write(buffer);
} catch (Exception ex) {
    System.out.println(ex.getMessage());
}
try (FileOutputStream fos = new FileOutputStream("hello.txt")) {
    baos.writeTo(fos);
} catch (IOException e) {
    System.out.println(e.getMessage());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>После выполнения этой программы в папке с программой появится файл <code>hello.txt</code>, который будет содержать строку <code>Hello Wolrd!</code>.</p>
</div>
<div class="paragraph">
<p>И в заключении также надо сказать, что как и для объектов <code>ByteArrayInputStream</code>, для <code>ByteArrayOutputStream</code> не надо явным образом закрывать поток с помощью метода <code>close()</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_классы_bufferedinputstream_and_bufferedoutputstream">11.6. Классы <code>BufferedInputStream</code> and <code>BufferedOutputStream</code></h3>
<div class="paragraph">
<p>Для оптимизации операций ввода-вывода используются буферизуемые потоки. Эти потоки добавляют к стандартным специальный буфер в памяти, с помощью которого повышается производительность при чтении и записи потоков.</p>
</div>
<div class="sect3">
<h4 id="_класс_bufferedinputstream">11.6.1. Класс <code>BufferedInputStream</code></h4>
<div class="paragraph">
<p>Класс <code>BufferedInputStream</code> накапливает вводимые данные в специальном буфере без постоянного обращения к устройству ввода. Класс <code>BufferedInputStream</code> определяет два конструктора:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BufferedInputStream(InputStream inputStream)</code></p>
</li>
<li>
<p><code>BufferedInputStream(InputStream inputStream, int bufSize)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Первый параметр - это поток ввода, с которого данные будут считываться в буфер. Второй параметр - размер буфера.</p>
</div>
<div class="paragraph">
<p>Например, буферизируем считывание данных из потока <code>ByteArrayInputStream</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;

public class Program {
    public static void main(String[] args) {
        String text = "Hello world!";
        byte[] buffer = text.getBytes();
        ByteArrayInputStream in = new ByteArrayInputStream(buffer);
        try (BufferedInputStream bis = new BufferedInputStream(in)) {
            int c;
            while ((c = bis.read()) != -1) {
                System.out.print((char) c);
            }
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        System.out.println();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Класс <code>BufferedInputStream</code> в конструкторе принимает объект <code>InputStream</code>. В данном случае таким объектом является экземпляр класса <code>ByteArrayInputStream</code>.</p>
</div>
<div class="paragraph">
<p>Как и все потоки ввода <code>BufferedInputStream</code> обладает методом <code>read()</code>, который считывает данные. И здесь мы считываем с помощью метода <code>read()</code> каждый байт из массива <code>buffer</code>.</p>
</div>
<div class="paragraph">
<p>Фактические все то же самое можно было сделать и с помощью одного <code>ByteArrayInputStream</code>, не прибегая к буферизированному потоку. Класс <code>BufferedInputStream</code> просто оптимизирует производительность при работе с потоком <code>ByteArrayInputStream</code>. Естественно вместо <code>ByteArrayInputStream</code> может использоваться любой другой класс, который унаследован от <code>InputStream</code>.</p>
</div>
<div class="sect4">
<h5 id="_класс_bufferedoutputstream">Класс <code>BufferedOutputStream</code></h5>
<div class="paragraph">
<p>Класс <code>BufferedOutputStream</code> аналогично создает буфер для потоков вывода. Этот буфер накапливает выводимые байты без постоянного обращения к устройству. И когда буфер заполнен, производится запись данных.</p>
</div>
<div class="paragraph">
<p><code>BufferedOutputStream</code> определяет два конструктора:
- <code>BufferedOutputStream(OutputStream outputStream)</code>
- <code>BufferedOutputStream(OutputStream outputStream, int bufSize)</code></p>
</div>
<div class="paragraph">
<p><code>outputStream</code> - это поток вывода, который унаследован от <code>OutputStream</code>, а <code>bufSize</code> - размер буфера.</p>
</div>
<div class="paragraph">
<p>Рассмотрим на примере записи в файл:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        String text = "Hello world!"; // строка для записи
        try (FileOutputStream out = new FileOutputStream("notes.txt");
             BufferedOutputStream bos = new BufferedOutputStream(out)) {
            byte[] buffer = text.getBytes(); // перевод строки в байты
            bos.write(buffer, 0, buffer.length);
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Класс <code>BufferedOutputStream</code> в конструкторе принимает в качестве параметра объект <code>OutputStream</code> - в данном случае это файловый поток вывода <code>FileOutputStream</code>. И также производится запись в файл. Опять же <code>BufferedOutputStream</code> не добавляет много новой функциональности, он просто оптимизирует действие потока вывода.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_классы_dataoutputstream_и_datainputstream">11.7. Классы <code>DataOutputStream</code> и <code>DataInputStream</code></h3>
<div class="paragraph">
<p>Классы <code>DataOutputStream</code> и <code>DataInputStream</code> позволяют записывать и считывать данные примитивных типов.</p>
</div>
<div class="sect3">
<h4 id="_запись_данных_и_dataoutputstream">11.7.1. Запись данных и <code>DataOutputStream</code></h4>
<div class="paragraph">
<p>Класс <code>DataOutputStream</code> представляет поток вывода и предназначен для записи данных примитивных типов. Для записи каждого из примитивных типов предназначен свой метод:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>writeBoolean(boolean v)</code> записывает в поток булевое однобайтовое значение</p>
</li>
<li>
<p><code>writeByte(int v)</code> записывает в поток 1 байт, которые представлен в виде целочисленного значения</p>
</li>
<li>
<p><code>writeChar(int v)</code> записывает 2-байтовое значение <code>char</code></p>
</li>
<li>
<p><code>writeDouble(double v)</code> записывает в поток 8-байтовое значение <code>double</code></p>
</li>
<li>
<p><code>writeFloat(float v)</code> записывает в поток 4-байтовое значение <code>float</code></p>
</li>
<li>
<p><code>writeInt(int v)</code> записывает в поток целочисленное значение <code>int</code></p>
</li>
<li>
<p><code>writeLong(long v)</code> записывает в поток значение <code>long</code></p>
</li>
<li>
<p><code>writeShort(int v)</code> записывает в поток значение <code>short</code></p>
</li>
<li>
<p><code>writeUTF(String str)</code> записывает в поток строку в кодировке <code>UTF-8</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_считывание_данных_и_datainputstream">11.7.2. Считывание данных и <code>DataInputStream</code></h4>
<div class="paragraph">
<p>Класс <code>DataInputStream</code> действует противоположным образом - он считывает из потока данные примитивных типов. Соответственно для каждого примитивного типа определен свой метод для считывания:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boolean readBoolean()</code> считывает из потока булевое однобайтовое значение</p>
</li>
<li>
<p><code>byte readByte()</code> считывает из потока 1 байт</p>
</li>
<li>
<p><code>char readChar()</code> считывает из потока значение <code>char</code></p>
</li>
<li>
<p><code>double readDouble()</code> считывает из потока 8-байтовое значение <code>double</code></p>
</li>
<li>
<p><code>float readFloat()</code> считывает из потока 4-байтовое значение <code>float</code></p>
</li>
<li>
<p><code>int readInt()</code> считывает из потока целочисленное значение <code>int</code></p>
</li>
<li>
<p><code>long readLong()</code> считывает из потока значение <code>long</code></p>
</li>
<li>
<p><code>short readShort()</code> считывает значение <code>short</code></p>
</li>
<li>
<p><code>String readUTF()</code> считывает из потока строку в кодировке <code>UTF-8</code></p>
</li>
<li>
<p><code>int skipBytes(int n)</code> пропускает при чтении из потока n байтов</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Рассмотрим применение классов на примере:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.*;

public class Program {
    public static void main(String[] args) {
        Person tom = new Person("Tom", 34, 1.68, false);
        // запись в файл
        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream("data.bin"))) {
            dos.writeUTF(tom.name);
            dos.writeInt(tom.age);
            dos.writeDouble(tom.height);
            dos.writeBoolean(tom.married);
            System.out.println("File has been written");
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }

        // обратное считывание из файла
        try (DataInputStream dos = new DataInputStream(new FileInputStream("data.bin"))) {
            String name = dos.readUTF();
            int age = dos.readInt();
            double height = dos.readDouble();
            boolean married = dos.readBoolean();
            System.out.printf("Name: %s  Age: %d  Height: %f  Married: %b", name, age, height, married);
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person {
    public String name;
    public int age;
    public double height;
    public boolean married;

    public Person(String n, int a, double h, boolean m) {
        this.name = n;
        this.height = h;
        this.age = a;
        this.married = m;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь мы последовательно записываем в файл данные объекта <code>Person</code>.</p>
</div>
<div class="paragraph">
<p>Объект <code>DataOutputStream</code> в конструкторе принимает поток вывода: <code>DataOutputStream(OutputStream out)</code>. В данном случае в качестве потока вывода используется объект <code>FileOutputStream</code>, поэтому вывод будет происходить в файл. И с помощью выше рассмотренных методов типа <code>writeUTF()</code> производится запись значений в бинарный файл.</p>
</div>
<div class="paragraph">
<p>Затем происходит чтение ранее записанных данных. Объект <code>DataInputStream</code> в конструкторе принимает поток для чтения: <code>DataInputStream(InputStream in)</code>. Здесь таким потоком выступает объект <code>FileInputStream</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_классы_printstream_и_printwriter">11.8. Классы <code>PrintStream</code> и <code>PrintWriter</code></h3>
<div class="sect3">
<h4 id="_класс_printstream">11.8.1. Класс <code>PrintStream</code></h4>
<div class="paragraph">
<p>Класс <code>PrintStream</code> - это именно тот класс, который используется для вывода на консоль. Когда мы выводим на консоль некоторую информацию с помощью вызова <code>System.out.println()</code>, то тем самым мы задействует <code>PrintStream</code>, так как переменная <code>out</code> в классе <code>System</code> как раз и представляет объект класса <code>PrintStream</code>, а метод <code>println()</code> - это метод класса <code>PrintStream</code>.</p>
</div>
<div class="paragraph">
<p>Но <code>PrintStream</code> полезен не только для вывода на консоль. Мы можем использовать данный класс для записи информации в поток вывода. Для этого <code>PrintStream</code> определяет ряд конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PrintStream(OutputStream outputStream)</code></p>
</li>
<li>
<p><code>PrintStream(OutputStream outputStream, boolean autoFlushingOn)</code></p>
</li>
<li>
<p><code>PrintStream(OutputStream outputStream, boolean autoFlushingOn, String charSet) throws UnsupportedEncodingException</code></p>
</li>
<li>
<p><code>PrintStream(File outputFile) throws FileNotFoundException</code></p>
</li>
<li>
<p><code>PrintStream(File outputFile, String charSet) throws FileNotFoundException, UnsupportedEncodingException</code></p>
</li>
<li>
<p><code>PrintStream(String outputFileName) throws FileNotFoundException</code></p>
</li>
<li>
<p><code>PrintStream(String outputFileName, String charSet) throws FileNotFoundException, UnsupportedEncodingException</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Параметр <code>outputStream</code> - это объект <code>OutputStream</code>, в который производится запись. Параметр <code>autoFlushingOn</code> при значении <code>true</code> позволяет автоматически записывать данные в поток вывода. По умолчанию этот параметр равен <code>false</code>. Параметр <code>charSet</code> позволяет указать кодировку символов.</p>
</div>
<div class="paragraph">
<p>В качестве источника для записи данных вместо <code>OutputStream</code> можно использовать объект <code>File</code> или строковый путь, по которому будет создаваться файл.</p>
</div>
<div class="paragraph">
<p>Для вывода информации в выходной поток <code>PrintStream</code> использует следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>println()</code> вывод строковой информации с переводом строки</p>
</li>
<li>
<p><code>print()</code> вывод строковой информации без перевода строки</p>
</li>
<li>
<p><code>printf()</code> форматированный вывод</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Например, запишем информацию в файл:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;

public class Program {
    public static void main(String[] args) {
        String text = "Привет мир!"; // строка для записи
        try (FileOutputStream fos = new FileOutputStream("C://SomeDir//notes3.txt");
             PrintStream printStream = new PrintStream(fos)) {
            printStream.println(text);
            System.out.println("Запись в файл произведена");
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае применяется форма конструктора <code>PrintStream</code>, которая в качестве параметра принимает поток вывода: <code>PrintStream (OutputStream out)</code>. Кроме того, мы могли бы использовать ряд других форм конструктора, например, указывая названия файла для записи: <code>PrintStream (string filename)</code></p>
</div>
<div class="paragraph">
<p>В качестве потока вывода используется объект <code>FileOutputStream</code>. С помощью метода <code>println()</code> производится запись информации в выходной поток - то есть в объект <code>FileOutputStream</code>. (В случае с выводом на консоль с помощью <code>System.out.println()</code> в качестве потока вывода выступает консоль)</p>
</div>
<div class="paragraph">
<p>Кроме того, как и любой поток вывода и наследник класса <code>OutputStream</code> он имеет метод <code>write()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.IOException;
import java.io.PrintStream;

public class Program {
    public static void main(String[] args) {
        try (PrintStream printStream = new PrintStream("notes3.txt")) {
            printStream.print("Hello World!");
            printStream.println("Welcome to Java!");
            printStream.printf("Name: %s Age: %d \n", "Tom", 34);
            String message = "PrintStream";
            byte[] messageToBytes = message.getBytes();
            printStream.write(messageToBytes);
            System.out.println("The file has been written");
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>После выполнения этой программы получится файл со следующим содержанием:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Hello World!Welcome to Java!
Name: Tom Age: 34
PrintStream</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_printwriter">11.8.2. <code>PrintWriter</code></h4>
<div class="paragraph">
<p>На <code>PrintStream</code> похож другой класс <code>PrintWriter</code>. Его можно использовать как для вывода информации на консоль, так и в файл или любой другой поток вывода. Данный класс имеет ряд конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PrintWriter(File file)</code> автоматически добавляет информацию в указанный файл</p>
</li>
<li>
<p><code>PrintWriter(File file, String csn)</code> автоматически добавляет информацию в указанный файл с учетом кодировки <code>csn</code></p>
</li>
<li>
<p><code>PrintWriter(OutputStream out)</code> для вывода информации используется существующий объект <code>OutputStream</code>, автоматически сбрасывая в него данные</p>
</li>
<li>
<p><code>PrintWriter(OutputStream out, boolean autoFlush)</code> для вывода информации используется существующий объект <code>OutputStream</code>, второй параметр указывает, надо ли автоматически добавлять в <code>OutputStream</code> данные</p>
</li>
<li>
<p><code>PrintWriter(String fileName)</code> автоматически добавляет информацию в файл по указанному имени</p>
</li>
<li>
<p><code>PrintWriter(String fileName, String csn)</code> автоматически добавляет информацию в файл по указанному имени, используя кодировку <code>csn</code></p>
</li>
<li>
<p><code>PrintWriter(Writer out)</code> для вывода информации используется существующий объект <code>Writer</code>, в который автоматически идет запись данных</p>
</li>
<li>
<p><code>PrintWriter(Writer out, boolean autoFlush)</code> для вывода информации используется существующий объект <code>Writer</code>, второй параметр указывает, надо ли автоматически добавлять в <code>Writer</code> данные</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>PrintWriter</code> реализует интерфейсы <code>Appendable</code>, <code>Closable</code> и <code>Flushable</code>, и поэтому после использования представляемый им поток надо закрывать.</p>
</div>
<div class="paragraph">
<p>Для записи данных в поток он также используется методы <code>printf()</code> и <code>println()</code>.</p>
</div>
<div class="paragraph">
<p>Например, применим данный класс для вывода на консоль:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">try (PrintWriter pw = new PrintWriter(System.out)) {
    pw.println("Hello world!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В качестве потока вывода здесь применяется <code>System.out</code>, а на консоль будет выведена строка <code>Hello world!</code></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_класс_filewriter_и_filereader">11.9. Класс <code>FileWriter</code> и <code>FileReader</code></h3>
<div class="paragraph">
<p>Хотя с помощью ранее рассмотренных классов можно записывать текст в файлы, однако они предназначены прежде всего для работы с бинарными потоками данных, и их возможностей для полноценной работы с текстовыми файлами недостаточно. И для этой цели служат совсем другие классы, которые являются наследниками абстрактных классов <code>Reader</code> и <code>Writer</code>.</p>
</div>
<div class="sect3">
<h4 id="_запись_файлов_класс_filewriter">11.9.1. Запись файлов. Класс <code>FileWriter</code></h4>
<div class="paragraph">
<p>Класс <code>FileWriter</code> является производным от класса <code>Writer</code>. Он используется для записи текстовых файлов.</p>
</div>
<div class="paragraph">
<p>Чтобы создать объект <code>FileWriter</code>, можно использовать один из следующих конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FileWriter(File file)</code></p>
</li>
<li>
<p><code>FileWriter(File file, boolean append)</code></p>
</li>
<li>
<p><code>FileWriter(FileDescriptor fd)</code></p>
</li>
<li>
<p><code>FileWriter(String fileName)</code></p>
</li>
<li>
<p>`FileWriter(String fileName, boolean append) `</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Так, в конструктор передается либо путь к файлу в виде строки, либо объект <code>File</code>, который ссылается на конкретный текстовый файл. Параметр <code>append</code> указывает, должны ли данные дозаписываться в конец файла (если параметр равен <code>true</code>), либо файл должен перезаписываться.</p>
</div>
<div class="paragraph">
<p>Запишем в файл какой-нибудь текст:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.FileWriter;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        try (FileWriter writer = new FileWriter("notes3.txt", false)) {
            String text = "Hello Gold!";
            writer.write(text); // запись всей строки
            writer.append('\n'); // запись одного символа
            writer.append('E');
            writer.flush();
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В конструкторе использовался параметр <code>append</code> со значением <code>false</code> - то есть файл будет перезаписываться. Затем с помощью методов, определенных в базовом классе <code>Writer</code> производится запись данных.</p>
</div>
<div class="sect4">
<h5 id="_чтение_файлов_класс_filereader">Чтение файлов. Класс <code>FileReader</code></h5>
<div class="paragraph">
<p>Класс <code>FileReader</code> наследуется от абстрактного класса <code>Reader</code> и предоставляет функциональность для чтения текстовых файлов.</p>
</div>
<div class="paragraph">
<p>Для создания объекта <code>FileReader</code> мы можем использовать один из его конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FileReader(String fileName)</code></p>
</li>
<li>
<p><code>FileReader(File file)</code></p>
</li>
<li>
<p><code>FileReader(FileDescriptor fd)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>А используя методы, определенные в базом классе <code>Reader</code>, произвести чтение файла:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.FileReader;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        try (FileReader reader = new FileReader("notes3.txt")) {
            // читаем посимвольно
            int c;
            while ((c = reader.read()) != -1) {
                System.out.print((char) c);
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Также мы можем считывать в промежуточный буфер из массива символов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

public class Program {
    public static void main(String[] args) {
        try (FileReader reader = new FileReader("notes3.txt")) {
            char[] buf = new char[256];
            int c;
            while ((c = reader.read(buf)) &gt; 0) {
                if (c &lt; 256) {
                    buf = Arrays.copyOf(buf, c);
                }
                System.out.print(buf);
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае считываем последовательно символы из файла в массив из 256 символов, пока не дойдем до конца файла в этом случае метод <code>read()</code> возвратит число <code>-1</code>.</p>
</div>
<div class="paragraph">
<p>Поскольку считанная порция файла может быть меньше 256 символов (например, в файле всего 73 символа), и если количество считанных данных меньше размера буфера (256), то выполняем копирование массива с помощью метода <code>Arrays.copyOf()</code>. То есть фактически обрезаем массив <code>buf</code>, оставляя в нем только те символы, которые считаны из файла.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_классы_bufferedwriter_and_bufferedreader">11.10. Классы <code>BufferedWriter</code> and <code>BufferedReader</code></h3>
<div class="sect3">
<h4 id="_запись_текста_через_буфер_и_bufferedwriter">11.10.1. Запись текста через буфер и <code>BufferedWriter</code></h4>
<div class="paragraph">
<p>Класс <code>BufferedWriter</code> записывает текст в поток, предварительно буферизируя записываемые символы, тем самым снижая количество обращений к физическому носителю для записи данных.</p>
</div>
<div class="paragraph">
<p>Класс <code>BufferedWriter</code> имеет следующие конструкторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BufferedWriter(Writer out)</code></p>
</li>
<li>
<p><code>BufferedWriter(Writer out, int sz)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В качестве параметра он принимает поток вывода, в который надо осуществить запись. Второй параметр указывает на размер буфера.</p>
</div>
<div class="paragraph">
<p>Например, осуществим запись в файл:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter("notes4.txt"))) {
            String text = "Hello  World!\nHey! Teachers! Leave them kids alone.";
            bw.write(text);
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_чтение_текста_и_bufferedreader">11.10.2. Чтение текста и <code>BufferedReader</code></h4>
<div class="paragraph">
<p>Класс <code>BufferedReader</code> считывает текст из символьного потока ввода, буферизируя прочитанные символы. Использование буфера призвано увеличить производительность чтения данных из потока.</p>
</div>
<div class="paragraph">
<p>Класс <code>BufferedReader</code> имеет следующие конструкторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BufferedReader(Reader in)</code></p>
</li>
<li>
<p><code>BufferedReader(Reader in, int sz)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Второй конструктор, кроме потока ввода, из которого производится чтение, также определяет размер буфера, в который будут считываться символы.</p>
</div>
<div class="paragraph">
<p>Так как <code>BufferedReader</code> наследуется от класса <code>Reader</code>, то он может использовать все те методы для чтения из потока, которые определены в <code>Reader</code>. И также <code>BufferedReader</code> определяет свой собственный метод <code>readLine()</code>, который позволяет считывать из потока построчно.</p>
</div>
<div class="paragraph">
<p>Рассмотрим применение <code>BufferedReader</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader("notes4.txt"))) {
            // чтение посимвольно
            int c;
            while ((c = br.read()) != -1) {
                System.out.print((char) c);
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Также можно считать текст построчно:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">try (BufferedReader br = new BufferedReader(new FileReader("notes4.txt"))) {
    //чтение построчно
    String s;
    while ((s = br.readLine()) != null) {
        System.out.println(s);
    }
} catch (IOException ex) {
    System.out.println(ex.getMessage());
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_считывание_с_консоли_в_файл">11.10.3. Считывание с консоли в файл</h4>
<div class="paragraph">
<p>Соединим оба класса <code>BufferedReader</code> и <code>BufferedWriter</code> для считывания с консоли в файл. Для этого определим следующий код программы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.*;

public class Program {
    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
             BufferedWriter bw = new BufferedWriter(new FileWriter("notes5.txt"))) {
            // чтение построчно
            String text;
            while (!(text = br.readLine()).equals("ESC")) {
                bw.write(text + "\n");
                bw.flush();
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь объект <code>BufferedReader</code> устанавливается для чтения с консоли с помощью объекта <code>new InputStreamReader(System.in)</code>. В цикле <code>while</code> считывается введенный текст. И пока пользователь не введет строку <code>ESC</code>, объект <code>BufferedWriter</code> будет записывать текст файл.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_сериализация">11.11. Сериализация</h3>
<div class="paragraph">
<p><strong>Сериализация</strong> представляет процесс записи состояния объекта в поток, соответственно процесс извлечения или восстановления состояния объекта из потока называется <strong>десериализацией</strong>. Сериализация очень удобна, когда идет работа со сложными объектами.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/assets/img/java/core/io/serialization.png" alt="Serialization"></span></p>
</div>
<div class="sect3">
<h4 id="_интерфейс_serializable">11.11.1. Интерфейс <code>Serializable</code></h4>
<div class="paragraph">
<p>Сразу надо сказать, что сериализовать можно только те объекты, которые реализуют интерфейс <code>Serializable</code>. Этот интерфейс не определяет никаких методов, просто он служит указателем системе, что объект, реализующий его, может быть сериализован.</p>
</div>
</div>
<div class="sect3">
<h4 id="_сериализация_класс_objectoutputstream">11.11.2. Сериализация. Класс <code>ObjectOutputStream</code></h4>
<div class="paragraph">
<p>Для сериализации объектов в поток используется класс <code>ObjectOutputStream</code>. Он записывает данные в поток.</p>
</div>
<div class="paragraph">
<p>Для создания объекта <code>ObjectOutputStream</code> в конструктор передается поток, в который производится запись:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ObjectOutputStream(OutputStream out)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для записи данных <code>ObjectOutputStream</code> использует ряд методов, среди которых можно выделить следующие:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void close()</code> закрывает поток</p>
</li>
<li>
<p><code>void flush()</code> очищает буфер и сбрасывает его содержимое в выходной поток</p>
</li>
<li>
<p><code>void write(byte[] buf)</code> записывает в поток массив байтов</p>
</li>
<li>
<p><code>void write(int val)</code> записывает в поток один младший байт из <code>val</code></p>
</li>
<li>
<p><code>void writeBoolean(boolean val)</code> записывает в поток значение <code>boolean</code></p>
</li>
<li>
<p><code>void writeByte(int val)</code> записывает в поток один младший байт из <code>val</code></p>
</li>
<li>
<p><code>void writeChar(int val)</code> записывает в поток значение типа <code>char</code>, представленное целочисленным значением</p>
</li>
<li>
<p><code>void writeDouble(double val)</code> записывает в поток значение типа <code>double</code></p>
</li>
<li>
<p><code>void writeFloat(float val)</code> записывает в поток значение типа <code>float</code></p>
</li>
<li>
<p><code>void writeInt(int val)</code> записывает целочисленное значение <code>int</code></p>
</li>
<li>
<p><code>void writeLong(long val)</code> записывает значение типа <code>long</code></p>
</li>
<li>
<p><code>void writeShort(int val)</code> записывает значение типа <code>short</code></p>
</li>
<li>
<p><code>void writeUTF(String str)</code> записывает в поток строку в кодировке <code>UTF-8</code></p>
</li>
<li>
<p><code>void writeObject(Object obj)</code> записывает в поток отдельный объект</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Эти методы охватывают весь спектр данных, которые можно сериализовать.</p>
</div>
<div class="paragraph">
<p>Например, сохраним в файл один объект класса <code>Person</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class Program {
    public static void main(String[] args) {
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.dat"))) {
            Person p = new Person("Sam", 33, 178, true);
            oos.writeObject(p);
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
    }
}

class Person implements Serializable {
    private String name;
    private int age;
    private double height;
    private boolean married;

    Person(String n, int a, double h, boolean m) {
        name = n;
        age = a;
        height = h;
        married = m;
    }

    String getName() {
        return name;
    }

    int getAge() {
        return age;
    }

    double getHeight() {
        return height;
    }

    boolean getMarried() {
        return married;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_десериализация_класс_objectinputstream">11.11.3. Десериализация. Класс <code>ObjectInputStream</code></h4>
<div class="paragraph">
<p>Класс <code>ObjectInputStream</code> отвечает за обратный процесс - чтение ранее сериализованных данных из потока. В конструкторе он принимает ссылку на поток ввода:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ObjectInputStream(InputStream in)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функционал <code>ObjectInputStream</code> сосредоточен в методах, предназначенных для чтения различных типов данных. Рассмотрим основные методы этого класса:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void close()</code> закрывает поток</p>
</li>
<li>
<p><code>int skipBytes(int len)</code> пропускает при чтении несколько байт, количество которых равно <code>len</code></p>
</li>
<li>
<p><code>int available()</code> возвращает количество байт, доступных для чтения</p>
</li>
<li>
<p><code>int read()</code> считывает из потока один байт и возвращает его целочисленное представление</p>
</li>
<li>
<p><code>boolean readBoolean()</code> считывает из потока одно значение <code>boolean</code></p>
</li>
<li>
<p><code>byte readByte()</code> считывает из потока один байт</p>
</li>
<li>
<p><code>char readChar()</code> считывает из потока один символ <code>char</code></p>
</li>
<li>
<p><code>double readDouble()</code> считывает значение типа <code>double</code></p>
</li>
<li>
<p><code>float readFloat()</code> считывает из потока значение типа <code>float</code></p>
</li>
<li>
<p><code>int readInt()</code> считывает целочисленное значение <code>int</code></p>
</li>
<li>
<p><code>long readLong()</code> считывает значение типа <code>long</code></p>
</li>
<li>
<p><code>short readShort()</code> считывает значение типа <code>short</code></p>
</li>
<li>
<p><code>String readUTF()</code> считывает строку в кодировке <code>UTF-8</code></p>
</li>
<li>
<p><code>Object readObject()</code> считывает из потока объект</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Например, извлечем выше сохраненный объект <code>Person</code> из файла:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.FileInputStream;
import java.io.ObjectInputStream;

public class Program {
    public static void main(String[] args) {
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("person.dat"))) {
            Person p = (Person) ois.readObject();
            System.out.printf("Name: %s \t Age: %d \n", p.getName(), p.getAge());
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь совместим сохранение и восстановление из файла на примере списка объектов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.*;
import java.util.ArrayList;

public class Program {
    //@SuppressWarnings("unchecked")
    public static void main(String[] args) {
        String filename = "people.dat";
        // создадим список объектов, которые будем записывать
        ArrayList&lt;Person&gt; people = new ArrayList&lt;Person&gt;();
        people.add(new Person("Tom", 30, 175, false));
        people.add(new Person("Sam", 33, 178, true));

        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename))) {
            oos.writeObject(people);
            System.out.println("File has been written");
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }

        // десериализация в новый список
        ArrayList&lt;Person&gt; newPeople = new ArrayList&lt;Person&gt;();
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename))) {
            newPeople = ((ArrayList&lt;Person&gt;) ois.readObject());
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }

        for (Person p : newPeople) {
            System.out.printf("Name: %s \t Age: %d \n", p.getName(), p.getAge());
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class Person implements Serializable {
    private String name;
    private int age;
    private double height;
    private boolean married;

    public Person(String n, int a, double h, boolean m) {
        this.name = n;
        this.age = a;
        this.height = h;
        this.married = m;
    }

    public String getName() {
        return this.name;
    }

    public int getAge() {
        return this.age;
    }

    public double getHeight() {
        return this.height;
    }

    public boolean getMarried() {
        return this.married;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_исключение_данных_из_сериализации">11.11.4. Исключение данных из сериализации</h4>
<div class="paragraph">
<p>По умолчанию сериализуются все переменные объекта. Однако, возможно, мы хотим, чтобы некоторые поля были исключены из сериализации. Для этого они должны быть объявлены с модификатором <code>transient</code>. Например, исключим из сериализации объекта <code>Person</code> переменные <code>height</code> и <code>married</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.Serializable;

class Person implements Serializable {
    private String name;
    private int age;
    private transient double height;
    private transient boolean married;

    public Person(String n, int a, double h, boolean m) {
        this.name = n;
        this.age = a;
        this.height = h;
        this.married = m;
    }

    public String getName() {
        return this.name;
    }

    public int getAge() {
        return this.age;
    }

    public double getHeight() {
        return this.height;
    }

    public boolean getMarried() {
        return this.married;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_классы_zipoutputstream_и_zipinputstream">11.12. Классы <code>ZipOutputStream</code> и <code>ZipInputStream</code></h3>
<div class="paragraph">
<p>Кроме общего функционала для работы с файлами Java предоставляет функциональность для работы с таким видом файлов как zip-архивы. Для этого в пакете <code>java.util.zip</code> определены два класса - <code>ZipInputStream</code> и <code>ZipOutputStream</code>.</p>
</div>
<div class="sect3">
<h4 id="_zipoutputstream_запись_архивов">11.12.1. <code>ZipOutputStream</code>. Запись архивов</h4>
<div class="paragraph">
<p>Для создания архива используется класс <code>ZipOutputStream</code>. Для создания объекта <code>ZipOutputStream</code> в его конструктор передается поток вывода:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ZipOutputStream(OutputStream out)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для записи файлов в архив для каждого файла создается объект <code>ZipEntry</code>, в конструктор которого передается имя архивируемого файла. А чтобы добавить каждый объект <code>ZipEntry</code> в архив, применяется метод <code>putNextEntry()</code>.</p>
</div>
<div class="paragraph">
<p>Создадим архив:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class Program {
    public static void main(String[] args) {
        String filename = "C:\\SomeDir\\notes.txt";
        try (ZipOutputStream zout = new ZipOutputStream(new FileOutputStream("C:\\SomeDir\\output.zip"));
             FileInputStream fis = new FileInputStream(filename);) {
            ZipEntry entry1 = new ZipEntry("notes.txt");
            zout.putNextEntry(entry1);
            // считываем содержимое файла в массив byte
            byte[] buffer = new byte[fis.available()];
            fis.read(buffer);
            // добавляем содержимое к архиву
            zout.write(buffer);
            // закрываем текущую запись для новой записи
            zout.closeEntry();
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>После добавления объекта <code>ZipEntry</code> в поток нам также надо добавить в него и содержимое файла. Для этого используется метод <code>write()</code>, записывающий в поток массив байтов: <code>zout.write(buffer);</code>. В конце надо закрыть <code>ZipEntry</code> с помощью метода <code>closeEntry()</code>. После этого можно добавлять в архив новые файлы - в этом случае все вышеописанные действия для каждого нового файла повторяются.</p>
</div>
</div>
<div class="sect3">
<h4 id="_чтение_архивов_zipinputstream">11.12.2. Чтение архивов. <code>ZipInputStream</code></h4>
<div class="paragraph">
<p>Для чтения архивов применяется класс <code>ZipInputStream</code>. В конструкторе он принимает поток, указывающий на zip-архив:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ZipInputStream(InputStream in)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для считывания файлов из архива <code>ZipInputStream</code> использует метод <code>getNextEntry()</code>, который возвращает объект <code>ZipEntry</code>. Объект <code>ZipEntry</code> представляет отдельную запись в zip-архиве. Например, считаем какой-нибудь архив:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public class Program {
    public static void main(String[] args) {
        try (ZipInputStream zin = new ZipInputStream(new FileInputStream("C:\\SomeDir\\output.zip"))) {
            ZipEntry entry;
            String name;
            long size;
            while ((entry = zin.getNextEntry()) != null) {
                name = entry.getName(); // получим название файла
                size = entry.getSize();  // получим его размер в байтах
                System.out.printf("File name: %s \t File size: %d \n", name, size);
                // распаковка
                FileOutputStream fout = new FileOutputStream("C:\\somedir\\new" + name);
                for (int c = zin.read(); c != -1; c = zin.read()) {
                    fout.write(c);
                }
                fout.flush();
                zin.closeEntry();
                fout.close();
            }
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ZipInputStream</code> в конструкторе получает ссылку на поток ввода. И затем в цикле выводятся все файлы и их размер в байтах, которые находятся в данном архиве.</p>
</div>
<div class="paragraph">
<p>Затем данные извлекаются из архива и сохраняются в новые файлы, которые находятся в той же папке и которые начинаются с <code>new</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_класс_console">11.13. Класс <code>Console</code></h3>
<div class="paragraph">
<p>Специально для работы с консолью в Java определен класс <code>Console</code>, который хранится в пакете <code>java.io</code>. Он не получает консольный ввод-вывод сам по себе, а использует уже имеющиеся потоки <code>System.in</code> и <code>System.out</code>. Но в то же время <code>Console</code> значительно упрощает ряд операций, связанных с консолью.</p>
</div>
<div class="paragraph">
<p>Для получения объекта консоли надо вызвать статический метод <code>System.console()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Console console = System.console();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Основные методы класса <code>Console</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>flush()</code> выводит на консоль все данные из буфера</p>
</li>
<li>
<p><code>format()</code> выводит на консоль строку с использованием форматирования</p>
</li>
<li>
<p><code>printf()</code> выводит на консоль строку с использованием форматирования (фактически то же самое, что и предыдущий метод)</p>
</li>
<li>
<p><code>String readLine()</code> считывает с консоли введенную пользователем строку</p>
</li>
<li>
<p><code>char[] readPassword()</code> считывает с консоли введенную пользователем строку, при этом символы строки не отображаются на консоли</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Используем класс <code>Console</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.Console;

public class Program {
    public static void main(String[] args) {
        // получаем консоль
        Console console = System.console();
        if (console != null) {
            // считываем данные с консоли
            String login = console.readLine("Введите логин:");
            char[] password = console.readPassword("Введите пароль:");
            console.printf("Введенный логин: %s \n", login);
            console.printf("Введенный пароль: %s \n", new String(password));
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Важно, что доступ к консоли мы можем получить только из самой консоли. При запуске, например, в <strong>IntelliJ IDEA</strong> вызов <code>System.console()</code> будет возвращать значение <code>null</code>. Поэтому при работе с консолью желательно проверять полученное значение на <code>null</code>. Ну а если мы запустим программу в командной строке, то естественно у нас все будет работать.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_java_concurrency">12. Java Concurrency</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_многопоточное_программирование">12.1. Многопоточное программирование</h3>
<div class="paragraph">
<p>Большинство языков программирования поддерживают такую важную функциональность как многопоточность, и Java в этом плане не исключение. При помощи многопоточности мы можем выделить в приложении несколько потоков, которые будут выполнять различные задачи одновременно. Если у нас, допустим, графическое приложение, которое посылает запрос к какому-нибудь серверу или считывает и обрабатывает огромный файл, то без многопоточности у нас бы блокировался графический интерфейс на время выполнения задачи. А благодаря потокам мы можем выделить отправку запроса или любую другую задачу, которая может долго обрабатываться, в отдельный поток. Поэтому большинство реальных приложений, которые многим из нас приходится использовать, практически не мыслимы без многопоточности.</p>
</div>
<div class="sect3">
<h4 id="_класс_thread">12.1.1. Класс <code>Thread</code></h4>
<div class="paragraph">
<p>В Java функциональность отдельного потока заключается в классе <code>Thread</code>. И чтобы создать новый поток, нам надо создать объект этого класса. Но все потоки не создаются сами по себе. Когда запускается программа, начинает работать <strong>главный поток</strong> этой программы. От этого главного потока порождаются все остальные <strong>дочерние потоки</strong>.</p>
</div>
<div class="paragraph">
<p>С помощью статического метода <code>Thread.currentThread()</code> мы можем получить текущий поток выполнения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static void main(String[] args) {
    Thread t = Thread.currentThread(); // получаем главный поток
    System.out.println(t.getName()); // main
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>По умолчанию именем главного потока будет <code>main</code>.</p>
</div>
<div class="paragraph">
<p>Для управления потоком класс <code>Thread</code> предоставляет еще ряд методов. Наиболее используемые из них:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getName()</code> возвращает имя потока</p>
</li>
<li>
<p><code>setName(String name)</code> устанавливает имя потока</p>
</li>
<li>
<p><code>getPriority()</code> возвращает приоритет потока</p>
</li>
<li>
<p><code>setPriority(int proirity)</code> устанавливает приоритет потока. Приоритет является одним из ключевых факторов для выбора системой потока из кучи потоков для выполнения. В этот метод в качестве параметра передается числовое значение приоритета - от <code>1</code> до <code>10</code>. По умолчанию главному потоку выставляется средний приоритет - <code>5</code>.</p>
</li>
<li>
<p><code>isAlive()</code> возвращает <code>true</code>, если поток активен</p>
</li>
<li>
<p><code>isInterrupted()</code> возвращает <code>true</code>, если поток был прерван</p>
</li>
<li>
<p><code>join()</code> ожидает завершение потока</p>
</li>
<li>
<p><code>run()</code> определяет точку входа в поток</p>
</li>
<li>
<p><code>sleep()</code> приостанавливает поток на заданное количество миллисекунд</p>
</li>
<li>
<p><code>start()</code> запускает поток, вызывая его метод <code>run()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Мы можем вывести всю информацию о потоке:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static void main(String[] args) {
    Thread t = Thread.currentThread(); // получаем главный поток
    System.out.println(t); // Thread[main,5,main]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Первое <code>main</code> будет представлять имя потока (что можно получить через <code>t.getName()</code>), второе значение <code>5</code> предоставляет приоритет потока (также можно получить через <code>t.getPriority()</code>), и последнее <code>main</code> представляет имя группы потоков, к которому относится текущий - по умолчанию также <code>main</code> (также можно получить через <code>t.getThreadGroup().getName()</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="_недостатки_при_использовании_потоков">12.1.2. Недостатки при использовании потоков</h4>
<div class="paragraph">
<p>Далее мы рассмотрим, как создавать и использовать потоки. Это довольно легко. Однако при создании многопоточного приложения нам следует учитывать ряд обстоятельств, которые негативно могут сказаться на работе приложения.</p>
</div>
<div class="paragraph">
<p>На некоторых платформах запуск новых потоков может замедлить работу приложения. Что может иметь большое значение, если нам критичная производительность приложения.</p>
</div>
<div class="paragraph">
<p><strong>Для каждого потока создается свой собственный стек в памяти</strong>, куда помещаются все локальные переменные и ряд других данных, связанных с выполнением потока. Соответственно, чем больше потоков создается, тем больше памяти используется. При этом надо помнить, в любой системе размеры используемой памяти ограничены. Кроме того, во многих системах может быть ограничение на количество потоков. Но даже если такого ограничения нет, то в любом случае имеется естественное ограничение в виде максимальной скорости процессора.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_создание_и_выполнение_потоков">12.2. Создание и выполнение потоков</h3>
<div class="paragraph">
<p>Для создания нового потока мы можем создать новый класс, либо наследуя его от класса <code>Thread</code>, либо реализуя в классе интерфейс <code>Runnable</code>.</p>
</div>
<div class="sect3">
<h4 id="_наследование_от_класса_thread">12.2.1. Наследование от класса <code>Thread</code></h4>
<div class="paragraph">
<p>Создадим свой класс на основе <code>Thread</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class JThread extends Thread {
    JThread(String name) {
        super(name);
    }

    public void run() {
        System.out.printf("%s started... \n", Thread.currentThread().getName());
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            System.out.println("Thread has been interrupted");
        }
        System.out.printf("%s fiished... \n", Thread.currentThread().getName());
    }
}

public class Program {
    public static void main(String[] args) {
        System.out.println("Main thread started...");
        new JThread("JThread").start();
        System.out.println("Main thread finished...");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Класс потока называется <code>JThread</code>. Предполагается, что в конструктор класса передается имя потока, которое затем передается в конструктор базового класса. В конструктор своего класса потока мы можем передать различные данные, но главное, чтобы в нем вызывался конструктор базового класса <code>Thread</code>, в который передается имя потока.</p>
</div>
<div class="paragraph">
<p>И также в <code>JThread</code> переопределяется метод <code>run()</code>, код которого собственно и будет представлять весь тот код, который выполняется в потоке.</p>
</div>
<div class="paragraph">
<p>В методе <code>main()</code> для запуска потока <code>JThread</code> у него вызывается метод <code>start()</code>, после чего начинается выполнение того кода, который определен в методе <code>run()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">new JThread("JThread").start();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Main thread started...
Main thread finished...
JThread started...
JThread finished...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь в методе <code>main()</code> в конструктор <code>JThread</code> передается произвольное название потока, и затем вызывается метод <code>start()</code>. По сути этот метод как раз и вызывает переопределенный метод <code>run()</code> класса <code>JThread</code>.</p>
</div>
<div class="paragraph">
<p>Обратите внимание, что главный поток завершает работу раньше, чем порожденный им дочерний поток <code>JThread</code>.</p>
</div>
<div class="paragraph">
<p>Аналогично созданию одного потока мы можем запускать сразу несколько потоков:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static void main(String[] args) {
    System.out.println("Main thread started...");
    for (int i = 1; i &lt; 6; i++)
        new JThread("JThread " + i).start();
    System.out.println("Main thread finished...");
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Main thread started...
Main thread finished...
JThread 2 started...
JThread 5 started...
JThread 4 started...
JThread 1 started...
JThread 3 started...
JThread 1 finished...
JThread 2 finished...
JThread 5 finished...
JThread 4 finished...
JThread 3 finished...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ожидание_завершения_потока">12.2.2. Ожидание завершения потока</h4>
<div class="paragraph">
<p>При запуске потоков в примерах выше <code>Main</code> <code>thread</code> завершался до дочернего потока. Как правило, более распространенной ситуацией является случай, когда <code>Main</code> thread завершается самым последним. Для этого надо применить метод <code>join()</code>. В этом случае текущий поток будет ожидать завершения потока, для которого вызван метод <code>join()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        System.out.println("Main thread started...");
        JThread t = new JThread("JThread ");
        t.start();
        try {
            t.join();
        } catch (InterruptedException e) {
            System.out.printf("%s has been interrupted", t.getName());
        }
        System.out.println("Main thread finished...");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>join()</code> заставляет вызвавший поток (в данном случае <code>Main thread</code>) ожидать завершения вызываемого потока, для которого и применяется метод <code>join()</code> (в данном случае <code>JThread</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Main thread started...
JThread  started...
JThread  finished...
Main thread finished...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если в программе используется несколько дочерних потоков, и надо, чтобы <code>Main thread</code> завершался после дочерних, то для каждого дочернего потока надо вызвать метод <code>join()</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_реализация_интерфейса_runnable">12.2.3. Реализация интерфейса <code>Runnable</code></h4>
<div class="paragraph">
<p>Другой способ определения потока представляет реализация интерфейса <code>Runnable</code>. Этот интерфейс имеет один метод <code>run()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">interface Runnable {
    void run();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В методе <code>run()</code> собственно определяется весь тот код, который выполняется при запуске потока.</p>
</div>
<div class="paragraph">
<p>После определения объекта <code>Runnable</code> он передается в один из конструкторов класса <code>Thread</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Thread(Runnable runnable, String threadName)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для реализации интерфейса определим следующий класс <code>MyThread</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class MyThread implements Runnable {
    public void run() {
        System.out.printf("%s started... \n", Thread.currentThread().getName());
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            System.out.println("Thread has been interrupted");
        }
        System.out.printf("%s finished... \n", Thread.currentThread().getName());
    }
}

public class Program {
    public static void main(String[] args) {
        System.out.println("Main thread started...");
        Thread myThread = new Thread(new MyThread(), "MyThread");
        myThread.start();
        System.out.println("Main thread finished...");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Реализация интерфейса <code>Runnable</code> во многом аналогична переопределению класса <code>Thread</code>. Также в методе <code>run()</code> определяется простейший код, который усыпляет поток на <code>500</code> миллисекунд.</p>
</div>
<div class="paragraph">
<p>В методе <code>main()</code> вызывается конструктор <code>Thread</code>, в который передается объект <code>MyThread</code>. И чтобы запустить поток, вызывается метод <code>start()</code>. В итоге консоль выведет что-то наподобие следующего:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Main thread started...
Main thread finished...
MyThread started...
MyThread finished...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Поскольку <code>Runnable</code> фактически представляет функциональный интерфейс, который определяет один метод, то объект этого интерфейса мы можем представить в виде лямбда-выражения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        System.out.println("Main thread started...");
        Runnable r = () -&gt; {
            System.out.printf("%s started... \n", Thread.currentThread().getName());
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                System.out.println("Thread has been interrupted");
            }
            System.out.printf("%s finished... \n", Thread.currentThread().getName());
        };
        Thread myThread = new Thread(r, "MyThread");
        myThread.start();
        System.out.println("Main thread finished...");
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_завершение_и_прерывание_потока">12.3. Завершение и прерывание потока</h3>
<div class="paragraph">
<p>Примеры потоков ранее представляли поток как последовательный набор операций. После выполнения последней операции завершался и поток. Однако нередко имеет место и другая организация потока в виде бесконечного цикла. Например, поток сервера в бесконечном цикле прослушивает определенный порт на предмет получения данных. И в этом случае мы также можем предусмотреть механизм завершения потока.</p>
</div>
<div class="sect3">
<h4 id="_завершение_потока">12.3.1. Завершение потока</h4>
<div class="paragraph">
<p>Распространенный способ завершения потока представляет опрос логической переменной. И если она равна, например, <code>false</code>, то поток завершает бесконечный цикл и заканчивает свое выполнение.</p>
</div>
<div class="paragraph">
<p>Определим следующий класс потока:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class MyThread implements Runnable {
    private boolean isActive;

    void disable() {
        isActive = false;
    }

    MyThread() {
        isActive = true;
    }

    public void run() {
        System.out.printf("%s started... \n", Thread.currentThread().getName());
        int counter = 1; // счетчик циклов
        while (isActive) {
            System.out.println("Loop " + counter++);
            try {
                Thread.sleep(400);
            } catch (InterruptedException e) {
                System.out.println("Thread has been interrupted");
            }
        }
        System.out.printf("%s finished... \n", Thread.currentThread().getName());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Переменная <code>isActive</code> указывает на активность потока. С помощью метода <code>disable()</code> мы можем сбросить состояние этой переменной.</p>
</div>
<div class="paragraph">
<p>Теперь используем этот класс:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public static void main(String[] args) {
    System.out.println("Main thread started...");
    MyThread myThread = new MyThread();
    new Thread(myThread, "MyThread").start();
    try {
        Thread.sleep(1100);
        myThread.disable();
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        System.out.println("Thread has been interrupted");
    }
    System.out.println("Main thread finished...");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Итак, вначале запускается дочерний поток: <code>new Thread(myThread,"MyThread").start()</code>. Затем на <code>1100</code> миллисекунд останавливаем <code>Main thread</code> и потом вызываем метод <code>myThread.disable()</code>, который переключает в потоке флаг <code>isActive</code>. И дочерний поток завершается.</p>
</div>
</div>
<div class="sect3">
<h4 id="_метод_interrupt">12.3.2. Метод <code>interrupt()</code></h4>
<div class="paragraph">
<p>Еще один способ вызова завершения или прерывания потока представляет метод <code>interrupt()</code>. Вызов этого метода устанавливает у потока статус, что он прерван. Сам метод возвращает <code>true</code>, если поток может быть прерван, в ином случае возвращается <code>false</code>.</p>
</div>
<div class="paragraph">
<p>При этом сам вызов этого метода НЕ завершает поток, он только устанавливает статус: в частности, метод <code>isInterrupted()</code> класса <code>Thread</code> будет возвращать значение <code>true</code>. Мы можем проверить значение возвращаемое данным методом и прозвести некоторые действия. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class JThread extends Thread {
    JThread(String name) {
        super(name);
    }

    public void run() {
        System.out.printf("%s started... \n", Thread.currentThread().getName());
        int counter = 1; // счетчик циклов
        while (!isInterrupted()) {
            System.out.println("Loop " + counter++);
        }
        System.out.printf("%s finished... \n", Thread.currentThread().getName());
    }
}

public class Program {
    public static void main(String[] args) {
        System.out.println("Main thread started...");
        JThread t = new JThread("JThread");
        t.start();
        try {
            Thread.sleep(150);
            t.interrupt();
            Thread.sleep(150);
        } catch (InterruptedException e) {
            System.out.println("Thread has been interrupted");
        }
        System.out.println("Main thread finished...");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В классе, который унаследован от <code>Thread</code>, мы можем получить статус текущего потока с помощью метода <code>isInterrupted()</code>. И пока этот метод возвращает <code>false</code>, мы можем выполнять цикл. А после того, как будет вызван метод <code>interrupt()</code>, <code>isInterrupted()</code> возвратит <code>true</code>, и соответственно произойдет выход из цикла.</p>
</div>
<div class="paragraph">
<p>Возможный консольный вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Main thread started...
JThread started...
Loop 1
Loop 2
Loop 3
Loop 4
JThread finished...
Main thread finished...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если основная функциональность заключена в классе, который реализует интерфейс <code>Runnable</code>, то там можно проверять статус потока с помощью метода <code>Thread.currentThread().isInterrupted()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class MyThread implements Runnable {
    public void run() {
        System.out.printf("%s started... \n", Thread.currentThread().getName());
        int counter = 1; // счетчик циклов
        while (!Thread.currentThread().isInterrupted()) {
            System.out.println("Loop " + counter++);
        }
        System.out.printf("%s finished... \n", Thread.currentThread().getName());
    }
}

public class Program {
    public static void main(String[] args) {
        System.out.println("Main thread started...");
        MyThread myThread = new MyThread();
        Thread t = new Thread(myThread, "MyThread");
        t.start();
        try {
            Thread.sleep(150);
            t.interrupt();
            Thread.sleep(150);
        } catch (InterruptedException e) {
            System.out.println("Thread has been interrupted");
        }
        System.out.println("Main thread finished...");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Однако при получении статуса потока с помощью метода <code>isInterrupted()</code> следует учитывать, что если мы обрабатываем в цикле исключение <code>InterruptedException</code> в блоке catch, то при перехвате исключения статус потока автоматически сбрасывается, и после этого <code>isInterrupted()</code> будет возвращать <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Например, добавим в цикл потока задержку с помощью метода <code>sleep()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public void run() {
    System.out.printf("%s started... \n", Thread.currentThread().getName());
    int counter = 1; // счетчик циклов
    while (!isInterrupted()) {
        System.out.println("Loop " + counter++);
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            System.out.println(getName() + " has been interrupted");
            System.out.println(isInterrupted()); // false
            interrupt(); // повторно сбрасываем состояние
        }
    }
    System.out.printf("%s finished... \n", Thread.currentThread().getName());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Когда поток вызовет метод <code>interrupt()</code>, метод <code>sleep()</code> сгенерирует исключение <code>InterruptedException</code>, и управление перейдет к блоку <code>catch</code>. Но если мы проверим статус потока, то увидим, что метод <code>isInterrupted()</code> возвращает <code>false</code>. Как вариант, в этом случае мы можем повторно прервать текущий поток, опять же вызвав метод <code>interrupt()</code>. Тогда при новой итерации цикла <code>while</code> метода <code>isInterrupted()</code> возвратит <code>true</code>, и поизойдет выход из цикла.</p>
</div>
<div class="paragraph">
<p>Либо мы можем сразу же в блоке <code>catch</code> выйти из цикла с помощью <code>break</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">while (!isInterrupted()) {
    System.out.println("Loop " + counter++);
    try {
        Thread.sleep(100);
    } catch (InterruptedException e) {
        System.out.println(getName() + " has been interrupted");
        break; // выход из цикла
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если бесконечный цикл помещен в конструкцию <code>try&#8230;&#8203;catch</code>, то достаточно обработать <code>InterruptedException</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public void run() {
    System.out.printf("%s started... \n", Thread.currentThread().getName());
    int counter = 1; // счетчик циклов
    try {
        while (!isInterrupted()) {
            System.out.println("Loop " + counter++);
            Thread.sleep(100);
        }
    } catch (InterruptedException e) {
        System.out.println(getName() + " has been interrupted");
    }
    System.out.printf("%s finished... \n", Thread.currentThread().getName());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_оператор_synchronized">12.4. Оператор <code>synchronized</code></h3>
<div class="paragraph">
<p>При работе потоки нередко обращаются к каким-то общим ресурсам, которые определены вне потока, например, обращение к какому-то файлу. Если одновременно несколько потоков обратятся к общему ресурсу, то результаты выполнения программы могут быть неожиданными и даже непредсказуемыми. Например, определим следующий код:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        CommonResource commonResource = new CommonResource();
        for (int i = 1; i &lt; 6; i++) {
            Thread t = new Thread(new CountThread(commonResource));
            t.setName("Thread " + i);
            t.start();
        }
    }
}

class CommonResource {
    int x = 0;
}

class CountThread implements Runnable {
    CommonResource res;

    CountThread(CommonResource res) {
        this.res = res;
    }

    public void run() {
        res.x = 1;
        for (int i = 1; i &lt; 5; i++) {
            System.out.printf("%s %d \n", Thread.currentThread().getName(), res.x);
            res.x++;
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                System.out.println(e.toString());
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь определен класс <code>CommonResource</code>, который представляет общий ресурс и в котором определено одно целочисленное поле <code>x</code>.</p>
</div>
<div class="paragraph">
<p>Этот ресурс используется классом потока <code>CountThread</code>. Этот класс просто увеличивает в цикле значение <code>x</code> на единицу. Причем при входе в поток значение <code>x = 1</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">res.x = 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>То есть в итоге мы ожидаем, что после выполнения цикла <code>res.x</code> будет равно <code>4</code>.</p>
</div>
<div class="paragraph">
<p>В главном классе программы запускается пять потоков. То есть мы ожидаем, что каждый поток будет увеличивать <code>res.x</code> с <code>1</code> до <code>4</code> и так пять раз. Но если мы посмотрим на результат работы программы, то он будет иным:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Thread 1 1
Thread 2 1
Thread 3 1
Thread 5 1
Thread 4 1
Thread 5 6
Thread 2 6
Thread 1 6
Thread 3 6
Thread 4 6
Thread 4 11
Thread 2 11
Thread 5 11
Thread 3 11
Thread 1 11
Thread 4 16
Thread 1 16
Thread 3 16
Thread 5 16
Thread 2 16</code></pre>
</div>
</div>
<div class="paragraph">
<p>То есть пока один поток не окончил работу с полем <code>res.x</code>, с ним начинает работать другой поток.</p>
</div>
<div class="paragraph">
<p>Чтобы избежать подобной ситуации, надо <strong>синхронизировать потоки</strong>. Одним из способов синхронизации является использование ключевого слова <code>synchronized</code>. Этот оператор предваряет блок кода или метод, который подлежит синхронизации. Для его применения изменим класс <code>CountThread</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">class CountThread implements Runnable {
    CommonResource res;

    CountThread(CommonResource res) {
        this.res = res;
    }

    public void run() {
        synchronized (res) {
            res.x = 1;
            for (int i = 1; i &lt; 5; i++) {
                System.out.printf("%s %d \n", Thread.currentThread().getName(), res.x);
                res.x++;
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    System.out.println(e.toString());
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>При создании синхронизированного блока кода после оператора <code>synchronized</code> идет объект-заглушка: <code>synchronized(res)</code>. Причем в качестве объекта может использоваться только объект какого-нибудь класса, но не примитивного типа.</p>
</div>
<div class="paragraph">
<p>Каждый объект в Java имеет ассоциированный с ним <strong>монитор</strong>. Монитор представляет своего рода инструмент для управления доступа к объекту. Когда выполнение кода доходит до оператора <code>synchronized</code>, монитор объекта <code>res</code> блокируется, и на время его блокировки монопольный доступ к блоку кода имеет только один поток, который и произвел блокировку. После окончания работы блока кода, монитор объекта <code>res</code> освобождается и становится доступным для других потоков.</p>
</div>
<div class="paragraph">
<p>После освобождения монитора его захватывает другой поток, а все остальные потоки продолжают ожидать его освобождения.</p>
</div>
<div class="paragraph">
<p>В итоге консольный вывод изменится:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Thread 1 1
Thread 1 2
Thread 1 3
Thread 1 4
Thread 3 1
Thread 3 2
Thread 3 3
Thread 3 4
Thread 5 1
Thread 5 2
Thread 5 3
Thread 5 4
Thread 4 1
Thread 4 2
Thread 4 3
Thread 4 4
Thread 2 1
Thread 2 2
Thread 2 3
Thread 2 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>При применении оператора <code>synchronized</code> к методу пока этот метод не завершит выполнение, монопольный доступ имеет только один поток - первый, который начал его выполнение. Для применения <code>synchronized</code> к методу, изменим классы программы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        CommonResource commonResource= new CommonResource();
        for (int i = 1; i &lt; 6; i++) {
            Thread t = new Thread(new CountThread(commonResource));
            t.setName("Thread " + i);
            t.start();
        }
    }
}

class CommonResource {
    int x;

    synchronized void increment() {
        x = 1;
        for (int i = 1; i &lt; 5; i++) {
            System.out.printf("%s %d \n", Thread.currentThread().getName(), x);
            x++;
            try {
                Thread.sleep(100);
            } catch(InterruptedException e) {
                System.out.println(e.toString());
            }
        }
    }
}

class CountThread implements Runnable {
    CommonResource res;

    CountThread(CommonResource res) {
        this.res = res;
    }

    public void run() {
        res.increment();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Результат работы в данном случае будет аналогичен примеру выше с блоком <code>synchronized</code>. Здесь опять в дело вступает монитор объекта <code>CommonResource</code> - общего объекта для всех потоков. Поэтому синхронизированным объявляется не метод <code>run()</code> в классе <code>CountThread</code>, а метод <code>increment()</code> класса <code>CommonResource</code>. Когда первый поток начинает выполнение метода <code>increment()</code>, он захватывает монитор объекта <code>CommonResource</code>. А все потоки также продолжают ожидать его освобождения.</p>
</div>
</div>
<div class="sect2">
<h3 id="_методы_wait_и_notify">12.5. Методы <code>wait()</code> и <code>notify()</code></h3>
<div class="paragraph">
<p>Иногда при взаимодействии потоков встает вопрос о извещении одних потоков о действиях других. Например, действия одного потока зависят от результата действий другого потока, и надо как-то известить один поток, что второй поток произвел некую работу. И для подобных ситуаций у класса <code>Object</code> определено ряд методов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>wait()</code> освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод <code>notify()</code></p>
</li>
<li>
<p><code>notify()</code> продолжает работу потока, у которого ранее был вызван метод <code>wait()</code></p>
</li>
<li>
<p><code>notifyAll()</code> возобновляет работу всех потоков, у которых ранее был вызван метод <code>wait()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Все эти методы вызываются только из синхронизированного контекста - синхронизированного блока или метода.</p>
</div>
<div class="paragraph">
<p>Рассмотрим, как мы можем использовать эти методы. Возьмем стандартную задачу "Производитель-Потребитель" ("Producer-Consumer"): пока производитель не произвел продукт, потребитель не может его купить. Пусть производитель должен произвести 5 товаров, соответственно потребитель должен их все купить. Но при этом одновременно на складе может находиться не более 3 товаров. Для решения этой задачи задействуем методы <code>wait()</code> и <code>notify()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class Program {
    public static void main(String[] args) {
        Store store=new Store();
        Producer producer = new Producer(store);
        Consumer consumer = new Consumer(store);
        new Thread(producer).start();
        new Thread(consumer).start();
    }
}

// Класс Магазин, хранящий произведенные товары
class Store {
    private int product = 0;

    public synchronized void get() {
        while (product &lt; 1) {
            try {
                wait();
            } catch (InterruptedException e) {
            }
        }
        product--;
        System.out.println("Покупатель купил 1 товар");
        System.out.println("Товаров на складе: " + product);
        notify();
    }

    public synchronized void put() {
        while (product &gt;= 3) {
            try {
                wait();
            } catch (InterruptedException e) {
            }
        }
        product++;
        System.out.println("Производитель добавил 1 товар");
        System.out.println("Товаров на складе: " + product);
        notify();
    }
}

// класс Производитель
class Producer implements Runnable {
    Store store;

    Producer(Store store) {
       this.store = store;
    }

    public void run() {
        for (int i = 1; i &lt; 6; i++) {
            store.put();
        }
    }
}

// Класс Потребитель
class Consumer implements Runnable {
    Store store;

    Consumer(Store store) {
       this.store = store;
    }

    public void run() {
        for (int i = 1; i &lt; 6; i++) {
            store.get();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Итак, здесь определен класс магазина, потребителя и покупателя. Производитель в методе <code>run()</code> добавляет в объект <code>Store</code> с помощью его метода <code>put()</code> 6 товаров. Потребитель в методе <code>run()</code> в цикле обращается к методу <code>get()</code> объекта <code>Store</code> для получения этих товаров. Оба метода <code>Store</code> - <code>put()</code> и <code>get()</code> являются синхронизированными.</p>
</div>
<div class="paragraph">
<p>Для отслеживания наличия товаров в классе <code>Store</code> проверяем значение переменной <code>product</code>. По умолчанию товара нет, поэтому переменная равна <code>0</code>. Метод <code>get()</code> - получение товара должен срабатывать только при наличии хотя бы одного товара. Поэтому в методе <code>get()</code> проверяем, отсутствует ли товар:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">while (product &lt; 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если товар отсутсвует, вызывается метод <code>wait()</code>. Этот метод освобождает монитор объекта <code>Store</code> и блокирует выполнение метода <code>get()</code>, пока для этого же монитора не будет вызван метод <code>notify()</code>.</p>
</div>
<div class="paragraph">
<p>Когда в методе <code>put()</code> добавляется товар и вызывается <code>notify()</code>, то метод <code>get()</code> получает монитор и выходит из конструкции <code>while (product &lt; 1)</code>, так как товар добавлен. Затем имитируется получение покупателем товара. Для этого выводится сообщение, и уменьшается значение <code>product</code>: <code>product--</code>. И в конце вызов метода <code>notify()</code> дает сигнал методу <code>put()</code> продолжить работу.</p>
</div>
<div class="paragraph">
<p>В методе <code>put()</code> работает похожая логика, только теперь метод <code>put()</code> должен срабатывать, если в магазине не более трех товаров. Поэтому в цикле проверяется наличие товара, и если товар уже есть, то освобождаем монитор с помощью <code>wait()</code> и ждем вызова <code>notify()</code> в методе <code>get()</code>.</p>
</div>
<div class="paragraph">
<p>И теперь программа покажет нам другие результаты:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Производитель добавил 1 товар
Товаров на складе: 1
Производитель добавил 1 товар
Товаров на складе: 2
Производитель добавил 1 товар
Товаров на складе: 3
Покупатель купил 1 товар
Товаров на складе: 2
Покупатель купил 1 товар
Товаров на складе: 1
Покупатель купил 1 товар
Товаров на складе: 0
Производитель добавил 1 товар
Товаров на складе: 1
Производитель добавил 1 товар
Товаров на складе: 2
Покупатель купил 1 товар
Товаров на складе: 1
Покупатель купил 1 товар
Товаров на складе: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Таким образом, с помощью <code>wait()</code> в методе <code>get()</code> мы ожидаем, когда производитель добавит новый продукт. А после добавления вызываем <code>notify()</code>, как бы говоря, что магазин теперь снова пуст, и можно еще добавлять.</p>
</div>
<div class="paragraph">
<p>А в методе <code>put()</code> с помощью <code>wait()</code> мы ожидаем освобождения места на складе. После того, как место освободится, добавляем товар и через <code>notify()</code> уведомляем покупателя о том, что он может забирать товар.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_java_concurrency_utilities_jsr_166">13. Java Concurrency Utilities (JSR-166)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_семафоры">13.1. Семафоры</h3>
<div class="paragraph">
<p><strong>Семафоры</strong> представляют еще одно средство синхронизации для доступа к ресурсу. В Java семафоры представлены классом <code>Semaphore</code>, который располагается в пакете <code>java.util.concurrent</code>.</p>
</div>
<div class="paragraph">
<p>Для управления доступом к ресурсу семафор использует счетчик, представляющий количество разрешений. Если значение счетчика больше нуля, то поток получает доступ к ресурсу, при этом счетчик уменьшается на единицу. После окончания работы с ресурсом поток освобождает семафор, и счетчик увеличивается на единицу. Если же счетчик равен нулю, то поток блокируется и ждет, пока не получит разрешение от семафора.</p>
</div>
<div class="paragraph">
<p>Установить количество разрешений для доступа к ресурсу можно с помощью конструкторов класса <code>Semaphore</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Semaphore(int permits)
Semaphore(int permits, boolean fair)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Параметр <code>permits</code> указывает на количество допустимых разрешений для доступа к ресурсу. Параметр <code>fair</code> во втором конструкторе позволяет установить очередность получения доступа. Если он равен <code>true</code>, то разрешения будут предоставляться ожидающим потокам в том порядке, в каком они запрашивали доступ. Если же он равен <code>false</code>, то разрешения будут предоставляться в неопределенном порядке.</p>
</div>
<div class="paragraph">
<p>Для получения разрешения у семафора надо вызвать метод <code>acquire()</code>, который имеет две формы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">void acquire() throws InterruptedException
void acquire(int permits) throws InterruptedВxception</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для получения одного разрешения применяется первый вариант, а для получения нескольких разрешений - второй вариант.</p>
</div>
<div class="paragraph">
<p>После вызова этого метода пока поток не получит разрешение, он блокируется.</p>
</div>
<div class="paragraph">
<p>После окончания работы с ресурсом полученное ранее разрешение надо освободить с помощью метода <code>release()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">void release()
void release(int permits)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Первый вариант метода освобождает одно разрешение, а второй вариант - количество разрешений, указанных в <code>permits</code>.</p>
</div>
<div class="paragraph">
<p>Используем семафор в простом примере:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.concurrent.Semaphore;

public class Program {
    public static void main(String[] args) {
        Semaphore sem = new Semaphore(1); // 1 разрешение
        CommonResource res = new CommonResource();
        new Thread(new CountThread(res, sem, "CountThread 1")).start();
        new Thread(new CountThread(res, sem, "CountThread 2")).start();
        new Thread(new CountThread(res, sem, "CountThread 3")).start();
    }
}

class CommonResource {
    int x = 0;
}

class CountThread implements Runnable {
    CommonResource res;
    Semaphore sem;
    String name;

    CountThread(CommonResource res, Semaphore sem, String name) {
        this.res = res;
        this.sem = sem;
        this.name = name;
    }

    public void run() {
        try {
            System.out.println(name + " ожидает разрешение");
            sem.acquire();
            res.x = 1;
            for(int i = 1; i &lt; 5; i++) {
                System.out.println(this.name + ": " + res.x);
                res.x++;
                Thread.sleep(100);
            }
        } catch(InterruptedException e) {
            System.out.println(e.getMessage());
        }
        System.out.println(name + " освобождает разрешение");
        sem.release();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Итак, здесь есть общий ресурс <code>CommonResource</code> с полем <code>x</code>, которое изменяется каждым потоком. Потоки представлены классом <code>CountThread</code>, который получает семафор и выполняет некоторые действия над ресурсом. В основном классе программы эти потоки запускаются. В итоге мы получим следующий вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">CountThread 1 ожидает разрешение
CountThread 2 ожидает разрешение
CountThread 3 ожидает разрешение
CountThread 1: 1
CountThread 1: 2
CountThread 1: 3
CountThread 1: 4
CountThread 1 освобождает разрешение
CountThread 3: 1
CountThread 3: 2
CountThread 3: 3
CountThread 3: 4
CountThread 3 освобождает разрешение
CountThread 2: 1
CountThread 2: 2
CountThread 2: 3
CountThread 2: 4
CountThread 2 освобождает разрешение</code></pre>
</div>
</div>
<div class="paragraph">
<p>Семафоры отлично подходят для решения задач, где надо ограничивать доступ. Например, классическая задача про обедающих философов. Ее суть: есть несколько философов, допустим, пять, но одновременно за столом могут сидеть не более двух. И надо, чтобы все философы пообедали, но при этом не возникло взаимоблокировки философами друг друга в борьбе за тарелку и вилку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.concurrent.Semaphore;

public class Program {
    public static void main(String[] args) {
        Semaphore sem = new Semaphore(2);
        for(int i = 1; i &lt; 6; i++)
            new Philosopher(sem, i).start();
    }
}

// класс философа
class Philosopher extends Thread {
    Semaphore sem; // семафор. ограничивающий число философов
    // кол-во приемов пищи
    int num = 0;
    // условный номер философа
    int id;
    // в качестве параметров конструктора передаем идентификатор философа и семафор
    Philosopher(Semaphore sem, int id) {
        this.sem = sem;
        this.id = id;
    }

    public void run() {
        try {
            while(num &lt; 3) { // пока количество приемов пищи не достигнет 3
                //Запрашиваем у семафора разрешение на выполнение
                sem.acquire();
                System.out.println ("Философ " + id+" садится за стол");
                // философ ест
                sleep(500);
                num++;

                System.out.println ("Философ " + id+" выходит из-за стола");
                sem.release();

                // философ гуляет
                sleep(500);
            }
        } catch(InterruptedException e) {
            System.out.println ("у философа " + id + " проблемы со здоровьем");
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В итоге только два философа смогут одновременно находиться за столом, а другие будут ждать:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Философ 1 садится за стол
Философ 3 садится за стол
Философ 3 выходит из-за стола
Философ 1 выходит из-за стола
Философ 2 садится за стол
Философ 4 садится за стол
Философ 2 выходит из-за стола
Философ 4 выходит из-за стола
Философ 5 садится за стол
Философ 1 садится за стол
Философ 1 выходит из-за стола
Философ 5 выходит из-за стола
Философ 3 садится за стол
Философ 2 садится за стол
Философ 3 выходит из-за стола
Философ 4 садится за стол
Философ 2 выходит из-за стола
Философ 5 садится за стол
Философ 4 выходит из-за стола
Философ 5 выходит из-за стола
Философ 1 садится за стол
Философ 3 садится за стол
Философ 1 выходит из-за стола
Философ 2 садится за стол
Философ 3 выходит из-за стола
Философ 5 садится за стол
Философ 2 выходит из-за стола
Философ 4 садится за стол
Философ 5 выходит из-за стола
Философ 4 выходит из-за стола</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_класс_exchanger">13.2. Класс <code>Exchanger</code></h3>
<div class="paragraph">
<p>Класс <code>Exchanger</code> предназначен для обмена данными между потоками. Он является типизированным и типизируется типом данных, которыми потоки должны обмениваться.</p>
</div>
<div class="paragraph">
<p>Обмен данными производится с помощью единственного метода этого класса <code>exchange()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">V exchange(V x) throws InterruptedException
V exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException</code></pre>
</div>
</div>
<div class="paragraph">
<p>Параметр <code>x</code> представляет буфер данных для обмена. Вторая форма метода также определяет параметр <code>timeout</code> - время ожидания и <code>unit</code> - тип временных единиц, применяемых для параметра <code>timeout</code>.</p>
</div>
<div class="paragraph">
<p>Данный класс очень просто использовать:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.concurrent.Exchanger;

public class Program {
    public static void main(String[] args) {
        Exchanger&lt;String&gt; ex = new Exchanger&lt;String&gt;();
        new Thread(new PutThread(ex)).start();
        new Thread(new GetThread(ex)).start();
    }
}

class PutThread implements Runnable {
    Exchanger&lt;String&gt; exchanger;
    String message;

    PutThread(Exchanger&lt;String&gt; ex) {
        this.exchanger = ex;
        message = "Hello Java!";
    }

    public void run() {
        try {
            message = exchanger.exchange(message);
            System.out.println("PutThread has received: " + message);
        } catch(InterruptedException ex) {
            System.out.println(ex.getMessage());
        }
    }
}

class GetThread implements Runnable {
    Exchanger&lt;String&gt; exchanger;
    String message;

    GetThread(Exchanger&lt;String&gt; ex) {
        this.exchanger = ex;
        message = "Hello World!";
    }

    public void run() {
        try {
            message = exchanger.exchange(message);
            System.out.println("GetThread has received: " + message);
        } catch(InterruptedException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В классе <code>PutThread</code> отправляет в буфер сообщение <code>Hello Java!</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">message = exchanger.exchange(message);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Причем в ответ метод <code>exchange()</code> возвращает данные, которые отправил в буфер другой поток. То есть происходит обмен данными. Хотя нам необязательно получать данные, мы можем просто их отправить:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">exchanger.exchange(message);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Логика класса <code>GetThread</code> аналогична - также отправляется сообщение.</p>
</div>
<div class="paragraph">
<p>В итоге консоль выведет следующий результат:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">PutThread has received: Hello World!
GetThread has received: Hello Java!</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_класс_phaser">13.3. Класс <code>Phaser</code></h3>
<div class="paragraph">
<p>Класс <code>Phaser</code> позволяет синхронизировать потоки, представляющие отдельную фазу или стадию выполнения общего действия. <code>Phaser</code> определяет объект синхронизации, который ждет, пока не завершится определенная фаза. Затем <code>Phaser</code> переходит к следующей стадии или фазе и снова ожидает ее завершения.</p>
</div>
<div class="paragraph">
<p>Для создания объекта <code>Phaser</code> используется один из конструкторов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Phaser()
Phaser(int parties)
Phaser(Phaser parent)
Phaser(Phaser parent, int parties)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Параметр <code>parties</code> указывает на количество сторон (грубо говоря, потоков), которые должны выполнять все фазы действия. Первый конструктор создает объект <code>Phaser</code> без каких-либо сторон. Второй конструктор регистрирует передаваемое в конструктор количество сторон. Третий и четвертый конструкторы также устанавливают родительский объект <code>Phaser</code>.</p>
</div>
<div class="paragraph">
<p>Основные методы класса <code>Phaser</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>int register()</code> регистрирует сторону, которая выполняет фазы, и возвращает номер текущей фазы - обычно фаза 0</p>
</li>
<li>
<p><code>int arrive()</code> сообщает, что сторона завершила фазу и возвращает номер текущей фазы</p>
</li>
<li>
<p><code>int arriveAndAwaitAdvance()</code> аналогичен методу <code>arrive</code>, только при этом заставляет phaser ожидать завершения фазы всеми остальными сторонами</p>
</li>
<li>
<p><code>int arriveAndDeregister()</code> сообщает о завершении всех фаз стороной и снимает ее с регистрации. Возвращает номер текущей фазы или отрицательное число, если синхронизатор <code>Phaser</code> завершил свою работу</p>
</li>
<li>
<p><code>int getPhase()</code> возвращает номер текущей фазы</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>При работае с классом <code>Phaser</code> обычно сначала создается его объект. Далее нам надо зарегистрировать все участвующие стороны. Для регистрации в каждой стороне вызывается метод <code>register()</code>, либо можно обойтись и без этого метода, передав нужное количество сторон в конструктор <code>Phaser</code>.</p>
</div>
<div class="paragraph">
<p>Затем каждая сторона выполняет некоторый набор действий, составляющих фазу. А синхронизатор Phaser ждет, пока все стороны не завершат выполнение фазы. Чтобы сообщить синхронизатору, что фаза завершена, сторона должна вызвать метод <code>arrive()</code> или <code>arriveAndAwaitAdvance()</code>. После этого синхронизатор переходит к следующей фазе.</p>
</div>
<div class="paragraph">
<p>Применим <code>Phaser</code> в приложении:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.concurrent.Phaser;

public class Program {
    public static void main(String[] args) {
        Phaser phaser = new Phaser(1);
        new Thread(new PhaseThread(phaser, "PhaseThread 1")).start();
        new Thread(new PhaseThread(phaser, "PhaseThread 2")).start();

        // ждем завершения фазы 0
        int phase = phaser.getPhase();
        phaser.arriveAndAwaitAdvance();
        System.out.println("Фаза " + phase + " завершена");

        // ждем завершения фазы 1
        phase = phaser.getPhase();
        phaser.arriveAndAwaitAdvance();
        System.out.println("Фаза " + phase + " завершена");

        // ждем завершения фазы 2
        phase = phaser.getPhase();
        phaser.arriveAndAwaitAdvance();
        System.out.println("Фаза " + phase + " завершена");

        phaser.arriveAndDeregister();
    }
}

class PhaseThread implements Runnable {
    Phaser phaser;
    String name;

    PhaseThread(Phaser phaser, String name) {
        this.phaser = phaser;
        this.name = name;
        phaser.register();
    }
    public void run() {

        System.out.println(name + " выполняет фазу " + phaser.getPhase());
        phaser.arriveAndAwaitAdvance(); // сообщаем, что первая фаза достигнута

        System.out.println(name + " выполняет фазу " + phaser.getPhase());
        phaser.arriveAndAwaitAdvance(); // сообщаем, что вторая фаза достигнута

        System.out.println(name + " выполняет фазу " + phaser.getPhase());
        phaser.arriveAndDeregister(); // сообщаем о завершении фаз и удаляем с регистрации объекты
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Итак, здесь у нас фазы выполняются тремя сторонами - главным потоком и двумя потоками <code>PhaseThread</code>. Поэтому при создании объекта <code>Phaser</code> ему передается число <code>1</code> - главный поток, а в конструкторе <code>PhaseThread</code> вызывается метод <code>register()</code>. Мы в принципе могли бы не использовать метод <code>register()</code>, но тогда нам надо было бы указать <code>Phaser phaser = new Phaser(3)</code>, так как у нас три стороны.</p>
</div>
<div class="paragraph">
<p>Фаза в каждой стороне представляет минимальный примитивный набор действий: для потоков <code>PhaseThread</code> это вывод сообщения, а для главного потока - подсчет текущей фазы с помощью метода <code>getPhase()</code>. При этом отсчет фаз начинается с нуля. Каждая сторона завершает выполнение фазы вызовом метода <code>phaser.arriveAndAwaitAdvance()</code>. При вызове этого метода пока последняя сторона не завершит выполнение текущей фазы, все остальные стороны блокируются.</p>
</div>
<div class="paragraph">
<p>После завершения выполнения последней фазы происходит отмена регистрации всех сторон с помощью метода <code>arriveAndDeregister()</code>.</p>
</div>
<div class="paragraph">
<p>В итоге работа программы даст следующий вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">PhaseThread 1 выполняет фазу 0
PhaseThread 2 выполняет фазу 0
PhaseThread 1 выполняет фазу 1
PhaseThread 2 выполняет фазу 1
Фаза 0 завершена
Фаза 1 завершена
PhaseThread 1 выполняет фазу 2
PhaseThread 2 выполняет фазу 2
Фаза 2 завершена</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае получается немного путанный вывод. Так, сообщения о выполнении фазы 1 выводится после сообщения об окончании фазы 0. Что связано с многопоточностью - фазы завершились, но в одном потоке еще не выведено сообщение о завершении, тогда как другие потоки уже начали выполнение следующей фазы. В любом случае все это происходит уже после завершения фазы.</p>
</div>
<div class="paragraph">
<p>Но чтобы было более наглядно, мы можем использовать <code>sleep()</code> в потоках:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public void run() {
        System.out.println(name + " выполняет фазу " + phaser.getPhase());
        phaser.arriveAndAwaitAdvance(); // сообщаем, что первая фаза достигнута
        try {
            Thread.sleep(200);
        } catch(InterruptedException ex) {
            System.out.println(ex.getMessage());
        }

        System.out.println(name + " выполняет фазу " + phaser.getPhase());
        phaser.arriveAndAwaitAdvance(); // сообщаем, что вторая фаза достигнута
        try {
            Thread.sleep(200);
        } catch(InterruptedException ex) {
            System.out.println(ex.getMessage());
        }
        System.out.println(name + " выполняет фазу " + phaser.getPhase());
        phaser.arriveAndDeregister(); // сообщаем о завершении фаз и удаляем с регистрации объекты
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>И в этом случае вывод будет более привычным, хотя на работу фаз это никак не повлияет.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">PhaseThread 1 выполняет фазу 0
PhaseThread 2 выполняет фазу 0
Фаза 0 завершена
PhaseThread 2 выполняет фазу 1
PhaseThread 1 выполняет фазу 1
Фаза 1 завершена
PhaseThread 2 выполняет фазу 2
PhaseThread 1 выполняет фазу 2
Фаза 2 завершена</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_блокировки_reentrantlock">13.4. Блокировки. <code>ReentrantLock</code></h3>
<div class="paragraph">
<p>Для управления доступом к общему ресурсу в качестве альтернативы оператору synchronized мы можем использовать блокировки. Функциональность блокировок заключена в пакете <code>java.util.concurrent.locks</code>.</p>
</div>
<div class="paragraph">
<p>Вначале поток пытается получить доступ к общему ресурсу. Если он свободен, то на него накладывает блокировку. После завершения работы блокировка с общего ресурса снимается. Если же ресурс не свободен и на него уже наложена блокировка, то поток ожидает, пока эта блокировка не будет снята.</p>
</div>
<div class="paragraph">
<p>Классы блокировок реализуют интерфейс <code>Lock</code>, который определяет следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void lock()</code> ожидает, пока не будет получена блокировка</p>
</li>
<li>
<p><code>void lockInterruptibly() throws InterruptedException</code> ожидает, пока не будет получена блокировка, если поток не прерван</p>
</li>
<li>
<p><code>boolean tryLock()</code> пытается получить блокировку, если блокировка получена, то возвращает <code>true</code>. Если блокировка не получена, то возвращает <code>false</code>. В отличие от метода <code>lock()</code> не ожидает получения блокировки, если она недоступна</p>
</li>
<li>
<p><code>void unlock()</code> снимает блокировку</p>
</li>
<li>
<p><code>Condition newCondition()</code> возвращает объект <code>Condition</code>, который связан с текущей блокировкой</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Организация блокировки в общем случае довольно проста: для получения блокировки вызывается метод <code>lock()</code>, а после окончания работы с общими ресурсами вызывается метод <code>unlock()</code>, который снимает блокировку.</p>
</div>
<div class="paragraph">
<p>Объект <code>Condition</code> позволяет управлять блокировкой.</p>
</div>
<div class="paragraph">
<p>Как правило, для работы с блокировками используется класс <code>ReentrantLock</code> из пакета <code>java.util.concurrent.locks</code>. Данный класс реализует интерфейс <code>Lock</code>.</p>
</div>
<div class="paragraph">
<p>Для примера возьмем код из темы про оператор synchronized и перепишем данный код с использованием заглушки <code>ReentrantLock</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.concurrent.locks.ReentrantLock;

public class Program {
    public static void main(String[] args) {
        CommonResource commonResource= new CommonResource();
        ReentrantLock locker = new ReentrantLock(); // создаем заглушку
        for (int i = 1; i &lt; 6; i++) {
            Thread t = new Thread(new CountThread(commonResource, locker));
            t.setName("Thread "+ i);
            t.start();
        }
    }
}

class CommonResource {
    int x = 0;
}

class CountThread implements Runnable {
    CommonResource res;
    ReentrantLock locker;

    CountThread(CommonResource res, ReentrantLock lock) {
        this.res = res;
        this.locker = lock;
    }

    public void run() {
        locker.lock(); // устанавливаем блокировку
        try {
            res.x = 1;
            for (int i = 1; i &lt; 5; i++) {
                System.out.printf("%s %d \n", Thread.currentThread().getName(), res.x);
                res.x++;
                Thread.sleep(100);
            }
        } catch (InterruptedException e) {
            System.out.println(e.getMessage());
        } finally {
            locker.unlock(); // снимаем блокировку
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь также используется общий ресурс <code>CommonResource</code>, для управления которым создается пять потоков. На входе в критическую секцию устанавливается заглушка:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">locker.lock();</code></pre>
</div>
</div>
<div class="paragraph">
<p>После этого только один поток имеет доступ к критической секции, а остальные потоки ожидают снятия блокировки. В блоке <code>finally</code> после всей окончания основной работы потока эта блокировка снимается. Причем делается это обязательно в блоке <code>finally</code>, так как в случае возникновения ошибки все остальные потоки окажутся заблокированными.</p>
</div>
<div class="paragraph">
<p>В итоге мы получим вывод, аналогичный тому, который был в случае с оператором <code>synchronized</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Thread 4 1
Thread 4 2
Thread 4 3
Thread 4 4
Thread 3 1
Thread 3 2
Thread 3 3
Thread 3 4
Thread 2 1
Thread 2 2
Thread 2 3
Thread 2 4
Thread 1 1
Thread 1 2
Thread 1 3
Thread 1 4
Thread 5 1
Thread 5 2
Thread 5 3
Thread 5 4</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interface_condition">13.5. Interface <code>Condition</code></h3>
<div class="paragraph">
<p>Применение условий в блокировках позволяет добиться контроля над управлением доступом к потокам. Условие блокировки представлет собой объект интерфейса <code>Condition</code> из пакета <code>java.util.concurrent.locks</code>.</p>
</div>
<div class="paragraph">
<p>Применение объектов <code>Condition</code> во многом аналогично использованию методов <code>wait()/notify()/notifyAll()</code> класса <code>Object</code>, которые были рассмотрены в одной из прошлых тем. В частности, мы можем использовать следующие методы интерфейса <code>Condition</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>await()</code> поток ожидает, пока не будет выполнено некоторое условие и пока другой поток не вызовет методы <code>signal()</code>/<code>signalAll()</code>. Во многом аналогичен методу wait класса <code>Object</code></p>
</li>
<li>
<p><code>signal()</code> сигнализирует, что поток, у которого ранее был вызван метод <code>await()</code>, может продолжить работу. Применение аналогично использованию методу <code>notify()</code> класса <code>Object</code></p>
</li>
<li>
<p><code>signalAll()</code> сигнализирует всем потокам, у которых ранее был вызван метод <code>await()</code>, что они могут продолжить работу. Аналогичен методу <code>notifyAll()</code> класса <code>Object</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Эти методы вызываются из блока кода, который попадает под действие блокировки <code>ReentrantLock</code>. Сначала, используя эту блокировку, нам надо получить объект <code>Condition</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ReentrantLock locker = new ReentrantLock();
Condition condition = locker.newCondition();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как правило, сначала проверяется условие доступа. Если соблюдается условие, то поток ожидает, пока условие не изменится:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">while (условие) {
    condition.await();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>После выполнения всех действий другим потокам подается сигнал об изменении условия:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">condition.signalAll();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Важно в конце вызвать метод <code>signal()</code>/<code>signalAll()</code>, чтобы избежать возможности взаимоблокировки потоков.</p>
</div>
<div class="paragraph">
<p>Для примера возьмем задачу из темы про методы <code>wait()</code>/<code>notify()</code> и изменим ее, применяя объект <code>Condition</code>.</p>
</div>
<div class="paragraph">
<p>Итак, у нас есть склад, где могут одновременно быть размещено не более 3 товаров. И производитель должен произвести 5 товаров, а покупатель должен эти товары купить. В то же время покупатель не может купить товар, если на складе нет никаких товаров:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;

public class Program {
    public static void main(String[] args) {
        Store store=new Store();
        Producer producer = new Producer(store);
        Consumer consumer = new Consumer(store);
        new Thread(producer).start();
        new Thread(consumer).start();
    }
}

// Класс Магазин, хранящий произведенные товары
class Store {
   private int product = 0;
   ReentrantLock locker;
   Condition condition;

   Store() {
       locker = new ReentrantLock(); // создаем блокировку
       condition = locker.newCondition(); // получаем условие, связанное с блокировкой
   }

   public void get() {
      locker.lock();
      try {
          // пока нет доступных товаров на складе, ожидаем
          while (product &lt; 1) {
              condition.await();
          }

          product--;
          System.out.println("Покупатель купил 1 товар");
          System.out.println("Товаров на складе: " + product);

          // сигнализируем
          condition.signalAll();
      } catch (InterruptedException e) {
          System.out.println(e.getMessage());
      } finally {
          locker.unlock();
      }
   }

   public void put() {
       locker.lock();
       try {
          // пока на складе 3 товара, ждем освобождения места
          while (product &gt;= 3) {
              condition.await();
          }

          product++;
          System.out.println("Производитель добавил 1 товар");
          System.out.println("Товаров на складе: " + product);
          // сигнализируем
          condition.signalAll();
      } catch (InterruptedException e) {
          System.out.println(e.getMessage());
      } finally {
          locker.unlock();
      }
   }
}

// класс Производитель
class Producer implements Runnable {
    Store store;

    Producer(Store store) {
       this.store = store;
    }

    public void run() {
        for (int i = 1; i &lt; 6; i++) {
            store.put();
        }
    }
}

// Класс Потребитель
class Consumer implements Runnable {
    Store store;

    Consumer(Store store) {
       this.store = store;
    }

    public void run() {
        for (int i = 1; i &lt; 6; i++) {
            store.get();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В итоге мы получим вывод наподобие следующего:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="out">Производитель добавил 1 товар
Товаров на складе: 1
Производитель добавил 1 товар
Товаров на складе: 2
Производитель добавил 1 товар
Товаров на складе: 3
Покупатель купил 1 товар
Товаров на складе: 2
Покупатель купил 1 товар
Товаров на складе: 1
Покупатель купил 1 товар
Товаров на складе: 0
Производитель добавил 1 товар
Товаров на складе: 1
Производитель добавил 1 товар
Товаров на складе: 2
Покупатель купил 1 товар
Товаров на складе: 1
Покупатель купил 1 товар
Товаров на складе: 0</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_java_network">14. Java Network</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_cтандартизированный_http_client_api_since_11">14.1. Cтандартизированный HTTP-client API (@since 11)</h3>
<div class="paragraph">
<p>Одной из функций, которые будут включены в предстоящий выпуск <strong>JDK 11</strong>, является стандартизированный <strong>HTTP-client API</strong>, целью которого является замена унаследованного класса <code>HttpUrlConnection</code> , который присутствует в JDK с самых ранних лет Java. Проблема с старым API, главным образом, в том, что он  старый и сложный в использовании.</p>
</div>
<div class="paragraph">
<p>Новый API поддерживает как <strong>HTTP/1.1</strong>, так и <strong>HTTP/2</strong>. Более новая версия протокола HTTP предназначена для повышения общей производительности отправки запросов клиентом и получения ответов от сервера. Это достигается путем внесения ряда изменений, таких как мультиплексирование потоков, сжатие заголовков и push promises. Кроме того, новый HTTP-клиент также изначально поддерживает <strong>WebSockets</strong>.</p>
</div>
<div class="paragraph">
<p>Новый модуль <code>java.net.http</code> который экспортирует пакет с тем же именем, определен в <strong>JDK 11</strong>, который содержит клиентские интерфейсы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">module java.net.http {
    exports java.net.http;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Пакет содержит следующие классы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>HttpClient</code> главная точка входа API. Это HTTP-клиент, который используется для отправки запросов и получения ответов. Он поддерживает отправку запросов как синхронно, так и асинхронно, вызывая его методы <code>send()</code> и <code>sendAsync()</code>, соответственно. Создать экземпляр можно с помощью <code>Builder</code> для <code>HttpClient</code>. После создания экземпляр является неизменным</p>
</li>
<li>
<p><code>HttpRequest</code> инкапсулирует HTTP-запрос, включая целевой <code>URI</code>, метод (<code>GET</code>, <code>POST</code> и т.д.), заголовки и другую информацию. Запрос создается с использованием <code>Builder</code>, является неизменным после создания и может быть отправлен несколько раз</p>
</li>
<li>
<p><code>HttpRequest.BodyPublisher</code> если запрос имеет тело (например, в запросах <code>POST</code>), это объект, ответственный за публикацию содержимого тела из данного источника, например, из строки, файла и т д.</p>
</li>
<li>
<p><code>HttpResponse</code> инкапсулирует ответ HTTP, включая заголовки и тело сообщения, если оно есть. Это то, что клиент получает после отправки <code>HttpRequest</code></p>
</li>
<li>
<p><code>HttpResponse.BodyHandler</code> функциональный интерфейс, который принимает некоторую информацию об ответе (код состояния и заголовки) и возвращает a <code>BodySubscriber</code>, который сам обрабатывает использование тела ответа <code>HttpResponse.BodySubscriber</code> подписывается на тело ответа и использует его байты в какой-либо другой форме (строка, файл или некоторый другой тип хранения)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>BodyPublisher</code> это подинтерфейс <code>Flow.Publisher</code>, введенный в Java 9. Аналогично, <code>BodySubscriber</code> это подинтерфейс <code>Flow.Subscriber</code>. Это означает, что эти интерфейсы согласованы с подходом <strong>reactive streams</strong>, который подходит для асинхронной отправки запросов с использованием <code>HTTP/2</code>.</p>
</div>
<div class="paragraph">
<p>Реализации для распространенных <code>publishers</code>, <code>handlers</code> и  <code>subscribers</code> для тела response предварительно определены в фабричных классах  <code>BodyPublishers</code>, <code>BodyHandlers</code> и <code>BodySubscribers</code>.</p>
</div>
<div class="paragraph">
<p>Например, чтобы создать объект, <code>BodyHandler</code> который обрабатывает байты тела ответа (через нижележащий <code>BodySubscriber</code> элемент) как строку, метод <code>BodyHandlers.ofString()</code> может использоваться для создания такой реализации. Если тело ответа необходимо сохранить в файл, <code>BodyHandlers.ofFile()</code> можно использовать метод.</p>
</div>
<div class="sect3">
<h4 id="_указание_версии_http_protocol">14.1.1. Указание версии HTTP Protocol</h4>
<div class="paragraph">
<p>Чтобы создать HTTP-клиент, который предпочитает HTTP/2 (по умолчанию, поэтому его <code>version()</code> можно опустить):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">HttpClient httpClient = HttpClient.newBuilder()
               .version(Version.HTTP_2)  // this is the default
               .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если указан <strong>HTTP/2</strong>, первый запрос к исходному серверу попытается использовать его.</p>
</div>
<div class="paragraph">
<p>Если сервер поддерживает новую версию протокола, то ответ будет отправлен с использованием этой версии. Все последующие запросы/ответы на этот сервер будут использовать <strong>HTTP/2</strong>.</p>
</div>
<div class="paragraph">
<p>Если сервер не поддерживает <strong>HTTP/2</strong>, будет использоваться <strong>HTTP/1.1</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_указание_proxy">14.1.2. Указание Proxy</h4>
<div class="paragraph">
<p>Чтобы установить прокси для запроса, используется <code>builder</code> метод <code>proxy()</code>  для предоставления <code>ProxySelector</code>. Если хост и порт прокси фиксированы, селектор прокси может быть жестко закодирован в селекторе:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">HttpClient httpClient = HttpClient.newBuilder()
               .proxy(ProxySelector.of(new InetSocketAddress(proxyHost, proxyPort)))
               .build();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_get_request">14.1.3. GET Request</h4>
<div class="paragraph">
<p>Методы запроса имеют соответствующие <code>builder</code> методы, основанные на их фактических именах. В приведенном ниже примере <code>GET()</code> необязательно:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">HttpRequest request = HttpRequest.newBuilder()
               .uri(URI.create("https://http2.github.io/"))
               .GET()   // this is the default
               .build();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_post_request_с_телом_запросв">14.1.4. POST Request с телом запросв</h4>
<div class="paragraph">
<p>Чтобы создать запрос с телом, <code>BodyPublisher</code> требуется преобразовать источник тела в байты. Один из предопределенных издателей может быть создан из статических методов фабрики в <code>BodyPublishers</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">HttpRequest mainRequest = HttpRequest.newBuilder()
               .uri(URI.create("https://http2.github.io/"))
               .POST(BodyPublishers.ofString(json))
               .build();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_отправка_http_request">14.1.5. Отправка HTTP Request</h4>
<div class="paragraph">
<p>Существует два способа отправки запроса:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>синхронно (блокировка до получения ответа)</p>
</li>
<li>
<p>асинхронно</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_synchronously_http_request">Synchronously HTTP request</h5>
<div class="paragraph">
<p>Для отправки в режиме блокировки мы вызываем <code>send()</code> метод на HTTP-клиенте, предоставляя экземпляр запроса и <code>BodyHandler</code>. Вот пример, который получает ответ, представляющий тело в виде строки:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">HttpRequest request = HttpRequest.newBuilder()
               .uri(URI.create("https://http2.github.io/"))
               .build();
HttpResponse&lt;String&gt; response = httpClient.send(request, BodyHandlers.ofString());
logger.info("Response status code: " + response.statusCode());
logger.info("Response headers: " + response.headers());
logger.info("Response body: " + response.body());</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_asynchronously_http_request">Asynchronously HTTP Request</h5>
<div class="paragraph">
<p>Иногда полезно избегать блокировок, пока ответ не будет возвращен сервером. В этом случае мы можем вызвать метод <code>sendAsync()</code>, который возвращает <code>CompletableFuture</code>. A <code>CompletableFuture</code> предоставляет механизм для цепочки последующих действий, которые должны быть запущены после его завершения. В этом контексте возвращенное <code>CompletableFuture</code> завершено, когда <code>HttpResponse</code> получен.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">httpClient.sendAsync(request, BodyHandlers.ofString())
          .thenAccept(response -&gt; {
       logger.info("Response status code: " + response.statusCode());
       logger.info("Response headers: " + response.headers());
       logger.info("Response body: " + response.body());
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>В приведенном выше примере, <code>sendAsyn()</code> вернет <code>CompletableFuture&lt;HttpResponse&lt;String&gt;&gt;</code>, a метод <code>thenAccept()</code> добавляет <code>Consumer</code>, который сработает, когда вернется ответ.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_inetaddress">14.2. InetAddress</h3>
<div class="paragraph">
<p>Для работы с IP-адресами в библиотеке <code>java.net</code> имеется класс <code>InetAddress</code>. С помощью <code>InetAddress</code> можно определить адрес IP локального узла, а также адреса удаленного узла, заданного доменным именем. Наиболее распространенные методы класса <code>InetAddress</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>InetAddress getLocalHost()</code></p>
</li>
<li>
<p><code>InetAddress getByName(String host)</code></p>
</li>
<li>
<p><code>InetAddress[] getAllByName(String host)</code></p>
</li>
<li>
<p><code>byte[] getAddress()</code></p>
</li>
<li>
<p><code>String toString()</code></p>
</li>
<li>
<p><code>String getHostName()</code></p>
</li>
<li>
<p><code>boolean equals(Object obj)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>При разработке сетевых приложений на начальном этапе, как правило, используют один компьютер (<strong>host</strong>). Для этого создатели протокола IP определили специальный адрес, называемый <code>localhost</code> - это IP-адрес "<strong>локальной заглушки</strong>" (<strong>local loopback</strong>) для работы приложений без использования сети. Общий порядок получения этого адреса в Java следующий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">InetAddress address = InetAddress.getByName(null);
address = InetAddress.getByName("localhost");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если методу <code>getByName()</code> передать значение <code>null</code>, то по умолчанию будет использоваться <code>localhost</code>. Cодержимым <code>InetAddress</code> нельзя манипулировать. Для создания <code>InetArddress</code> можно использовать один из перегруженных статических методов класса <code>getByName()</code>, <code>getAllByName()</code> или <code>getLocalHost()</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_networking">14.3. TCP networking</h3>
<div class="paragraph">
<p>Java для работы в сети имеет специальный пакет <code>java.net</code>, содержащий класс <code>Socket</code>, что в переводе означает «гнездо». Ключевыми классами для реализации взаимодействия программ по протоколу TCP являются:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ServerSocket</code> - класс реализует серверный сокет, который ожидает запросы, приходящие от клиентов по сети, и может отправлять ответ</p>
</li>
<li>
<p><code>Socket</code> - класс реализует клиентский сокет</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_socket">14.3.1. Socket</h4>
<div class="paragraph">
<p>Клиентский сокет <code>Socket</code> можно создать с использованием одного из следующих конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Socket()</code></p>
</li>
<li>
<p><code>Socket(String host, int port)</code></p>
</li>
<li>
<p><code>Socket(InetAddress address, int port)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В строковой константе <code>host</code> можно указать как <strong>IP</strong> адрес сервера, так и его <strong>DNS</strong> имя. При этом программа автоматически выберет свободный порт на локальном компьютере и свяжет его с сокетом. При этом могут быть вызваны одно из двух видов исключений, связанного с неизвестным адресом хоста (в сети компьютер не будет найден) или отсутствием связи с этим сокетом.</p>
</div>
<div class="paragraph">
<p>Наиболее важные методы класса <code>Socket</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>InputStream getInputStream()</code></p>
</li>
<li>
<p><code>OutputStream getOutputStream()</code></p>
</li>
<li>
<p><code>void close()</code></p>
</li>
<li>
<p><code>void setSoTimeout(int timeout) throws SocketException</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>где <code>timeout</code> время ожидания в секундах. Если в течение этого времени никаких действий с сокетом не произведено (получение и отправка данных), то он самоликвидируется. Исключением является сокет с <code>timeout</code> равным <code>0</code> - "вечный" сокет.</p>
</div>
<div class="paragraph">
<p>Пример использования:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.DataOutputStream;
import java.net.Socket;

public class MyClient {
    public static void main(String[] args) {
        try {
            Socket s = new Socket("localhost", 6666);
            DataOutputStream dout = new DataOutputStream(s.getOutputStream());
            dout.writeUTF("Hello Server");
            dout.flush();
            dout.close();
            s.close();
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_serversocket">14.3.2. ServerSocket</h4>
<div class="paragraph">
<p>Для создания серверного сокета <code>ServerSocket</code> можно использовать один из следующих конструкторов :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>public ServerSocket() throws IOException</code></p>
</li>
<li>
<p><code>public ServerSocket(int port) throws IOException</code></p>
</li>
<li>
<p><code>public ServerSocket(int port, int backlog) throws IOException</code></p>
</li>
<li>
<p><code>public ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Первым параметров в конструктор необходимо передать порт <code>port</code>, который будет привязан к серверному сокету. Если порт занят или запрещён к использованию политикой безопасности компьютера, то вызывается исключение <code>IOException</code>. Если значение передавамого порта равно <code>0</code>, то система сама выделит номер свободного порта. Значение полученного порта можно узнать через вызов функции <code>getLocalPort()</code>. Несвязанный серверный сокет <code>ServerSocket()</code> необходимо «связывать» с IP-адресом и портом c помощью метода <code>bind()</code>.</p>
</div>
<div class="paragraph">
<p>Параметр <code>backlog</code> устанавливает максимальное количество клиентских подключений. Если количество подключений достигло предела, то следующему клиенту в подключении будет отказано.</p>
</div>
<div class="paragraph">
<p>Наиболее часто используемые методы серверного сокета <code>ServerSocket</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Socket accept()</code> - ожидание подключения клиента</p>
</li>
<li>
<p><code>void bind(SocketAddress endpoint)</code> - связывание <code>ServerSocket</code> c определенным адресом (IP-адрес и порт)</p>
</li>
<li>
<p><code>void close()</code> - закрытие сокета</p>
</li>
<li>
<p><code>ServerSocketChannel getChannel()</code> - получение объекта <code>ServerSocketChannel</code>, связанного с сокетом</p>
</li>
<li>
<p><code>InetAddress getInetAddress()</code> - получение локального адреса</p>
</li>
<li>
<p><code>int getLocalPort()</code> - получение номера порта, который серверный сокет слушает</p>
</li>
<li>
<p><code>SocketAddress getLocalSocketAddress()</code>- получение адреса в виде объекта <code>SocketAddress</code></p>
</li>
<li>
<p><code>int getReceiveBufferSize()</code>- получение размера буфера</p>
</li>
<li>
<p><code>boolean isClosed()</code> - проверка, закрыт ли серверный сокет</p>
</li>
<li>
<p><code>void setReceiveBufferSize(int size)</code> - определение размера буфера</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>После создания в приложении серверного сокета <code>ServerSocket</code> необходимо вызвать функцию <code>accept()</code>, которая переводит приложение в режим ожидания подключения клиента. Дальнейший код не выполняется, пока клиент не подключится. Как только клиент подключается функция возвращает объект класса <code>Socket</code>, который следует использовать для взаимодействия сервера с клиентом.</p>
</div>
<div class="paragraph">
<p>Пример использования:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.io.DataInputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class MyServer {
    public static void main(String[] args) {
        try {
            ServerSocket ss = new ServerSocket(6666);
            Socket s = ss.accept(); // establishes connection
            DataInputStream dis = new DataInputStream(s.getInputStream());
            String str = (String) dis.readUTF();
            System.out.println("message= " + str);
            ss.close();
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_udp_networking">14.4. UDP networking</h3>
<div class="paragraph">
<p>Классы <code>DatagramSocket</code> и <code>DatagramPacket</code> используются для программирования сокетов без подключения.</p>
</div>
<div class="sect3">
<h4 id="_datagramsocket">14.4.1. DatagramSocket</h4>
<div class="paragraph">
<p>Класс <code>DatagramSocket</code> представляет сокет без соединения для отправки и приема пакетов <strong>datagram</strong>.</p>
</div>
<div class="paragraph">
<p><strong>Datagram</strong> - это в основном информация, но нет гарантии что она что-то содержит, когда она доставится или доставится ли вообще.</p>
</div>
<div class="paragraph">
<p>Конструкторы класса <code>DatagramSocket</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DatagramSocket() throws SocketExeption</code> - создает сокет datagram и связывает его с доступным номером порта на <strong>localhost</strong>.</p>
</li>
<li>
<p><code>DatagramSocket(int port) throws SocketExeption</code> - создает сокет datagram и связывает его с данным номером <code>port</code>.</p>
</li>
<li>
<p><code>DatagramSocket(int port, InetAddress address) throws SocketExeption</code> - создает сокет datagram и связывает его с указанным номером <code>port</code> и адресом хоста <code>InetAddress</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_datagrampacket">14.4.2. DatagramPacket</h4>
<div class="paragraph">
<p><code>DatagramPacket</code> - это сообщение, которое может быть отправлено или получено. Если вы отправляете несколько пакетов, он может поступать в любом порядке. Кроме того, доставка пакетов не гарантируется.</p>
</div>
<div class="paragraph">
<p>Чаще используют следующие конструкторы класса <code>DatagramPacket</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DatagramPacket(byte [] barr, int length)</code> - используется для приема пакетов</p>
</li>
<li>
<p><code>DatagramPacket(byte [] barr, int length, адрес InetAddress, int port)</code> - используется для отправки пакетов</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример отправки <code>DatagramPacket</code> по <code>DatagramSocket</code></p>
</div>
<div class="paragraph">
<p>Отправитель:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

public class DSender {
    public static void main(String[] args) throws Exception {
        DatagramSocket ds = new DatagramSocket();
        String str = "Welcome java";
        InetAddress ip = InetAddress.getByName("127.0.0.1");

        DatagramPacket dp = new DatagramPacket(str.getBytes(), str.length(), ip, 3000);
        ds.send(dp);
        ds.close();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Получатель:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.net.DatagramPacket;
import java.net.DatagramSocket;

public class DReceiver {
    public static void main(String[] args) throws Exception {
        DatagramSocket ds = new DatagramSocket(3000);
        byte[] buf = new byte[1024];
        DatagramPacket dp = new DatagramPacket(buf, 1024);
        ds.receive(dp);
        String str = new String(dp.getData(), 0, dp.getLength());
        System.out.println(str);
        ds.close();
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_javadoc_2">15. Javadoc</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_введение_2">15.1. Введение</h3>
<div class="paragraph">
<p><strong>Javadoc</strong> является стандартным выводом для <strong>Java API</strong>. Создание <strong>Javadoc</strong> довольно простое. Javadoc генерируется с помощью так называемого <em>doclet</em>. Различные <em>doclets</em> могут по-разному анализировать аннотации Java и создавать разные выходные данные. Но по большому счету почти каждая документация по Java использует стандартный <em>doclet</em>. Выходные данные <strong>Javadoc</strong> знакомы разработчикам Java и приветствуются ими.</p>
</div>
<div class="paragraph">
<p><strong>Javadoc</strong> поддерживается <strong>Oracle</strong>. Разработчики могут интегрировать вывод <strong>Javadoc</strong> непосредственно в свою <strong>IDE</strong>, что делает документацию удобной и легко доступной. Фактически, <strong>Javadoc</strong> часто доставляется таким образом, а не разворачивается и загружается на сервер. <strong>Javadoc</strong> содержит только справочную документацию. В документацию нельзя добавлять какие-либо концептуальные файлы справки или изменять макет.</p>
</div>
<div class="sect3">
<h4 id="_javadoc_и_проверка_ошибок">15.1.1. <strong>Javadoc</strong> и проверка ошибок</h4>
<div class="paragraph">
<p><strong>Javadoc</strong> можно генерировать вручную с помощью IDE.</p>
</div>
<div class="paragraph">
<p><strong>Javadoc</strong> также проверяет теги по фактическому коду. Если есть параметры, исключения или возвраты, которые не соответствуют параметрам, исключениям или возвратам в фактическом коде, то <strong>Javadoc</strong> будет показывать предупреждения.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/img/java/core/javadoc/error.png" alt="Error">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_изучение_параметров_javadoc">15.1.2. Изучение параметров <strong>Javadoc</strong></h4>
<div class="paragraph">
<p>Можно попробовать удалять некоторые параметры из метода и снова генерировать Javadoc. Перед этим нужно убедиться, что окно консоли открыто, чтобы можно было видеть предупреждения об ошибках.</p>
</div>
</div>
<div class="sect3">
<h4 id="_автоматическое_создание_javadoc">15.1.3. Автоматическое создание <strong>Javadoc</strong></h4>
<div class="paragraph">
<p>В большинстве проектов файл <strong>Javadoc</strong> никогда не создается вручную. <strong>Javadoc</strong> позволяет строить его из командной строки, передавая ему файл конфигурации. У большинства разработчиков есть инструмент управления сборкой, где они могут настраивать выходные данные из своего кода, включая <strong>Javadoc</strong>. Если разработчики попросят собрать <strong>Javadoc</strong>, скорее всего, их система управления сборкой может быть несколько примитивной. Тем не менее, может быть полезно создать выходные данные <strong>Javadoc</strong> самостоятельно, чтобы протестировать и просмотреть выходные данные, прежде чем создавать их с помощью инструмента управления сборкой.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_тэги_javadoc">15.2. Тэги <strong>Javadoc</strong></h3>
<div class="paragraph">
<p><strong>Javadoc</strong> - это генератор документов, который просматривает исходные файлы Java для конкретных аннотаций. Он анализирует аннотации в выводе <strong>Javadoc</strong>. Знать аннотации очень важно, потому что именно так создается <strong>Javadoc</strong>.</p>
</div>
<div class="sect3">
<h4 id="_комментарии_или_тэги_javadoc">15.2.1. Комментарии или тэги <strong>Javadoc</strong></h4>
<div class="paragraph">
<p>Обычно комментарии в Java выглядят так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">// sample comment...

/*
sample comment
*/</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Javadoc</strong> ничего не делает с такими комментариями.</p>
</div>
<div class="paragraph">
<p>Чтобы включить контент в <strong>Javadoc</strong>, добавляем две звездочки в начале, перед классом или методом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">/**
*
*
*
*
*/</code></pre>
</div>
</div>
<div class="paragraph">
<p>Формат для добавления различных элементов выглядит следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">/**
* [short description]
* &lt;p&gt;
* [long description]
*
* [author, version, params, returns, throws, see, other tags]
* [see also]
*/</code></pre>
</div>
</div>
<div class="paragraph">
<p>Реальный пример комментариев метода в <strong>Javadoc</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">/**
* Zaps the roadrunner with the number of volts you specify.
* &lt;p&gt;
* Do not exceed more than 30 volts or the zap function will backfire.
* For another way to kill a roadrunner, see the {@link Dynamite#blowDynamite()} method.
*
* @exception IOException if you don't enter a data type amount for the voltage
* @param voltage the number of volts you want to send into the roadrunner's body
* @see #findRoadRunner
* @see Dynamite#blowDynamite
*/
public void zapRoadRunner(int voltage) throws IOException {
   if (voltage &lt; 31) {
       System.out.println("Zapping roadrunner with " + voltage + " volts!!!!");
   }
   else {
    System.out.println("Backfire!!! zapping coyote with 1,000,000 volts!!!!");
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Описание <strong>Javadoc</strong> и тэги помещаем перед классом или методом (нет необходимости в пробелах между описанием и классом или методом).</p>
</div>
</div>
<div class="sect3">
<h4 id="_общие_тэги_javadoc">15.2.2. Общие тэги <strong>Javadoc</strong></h4>
<div class="paragraph">
<p>Ниже приведены наиболее распространенные тэги, используемые в <strong>Javadoc</strong>. У каждого тэга есть слово, которое следует за ним. Например, <code>@param latitude</code> означает, что параметром является «широта».</p>
</div>
<div class="paragraph">
<p><a href="https://www.oracle.com/technetwork/java/javase/documentation/index-137868.html#examples">Длинный пример тэгов Javadoc на сайте Oracle</a></p>
</div>
<div class="paragraph">
<p>Рассмотрим несколько общих тэгов <strong>Javadoc</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@author</code> - человек, который внес значительный вклад в код. Применяется только на уровне класса, пакета или обзора. Не включен в вывод <strong>Javadoc</strong>. Не рекомендуется включать этот тэг, поскольку авторство часто меняется.</p>
</li>
<li>
<p><code>@param</code> - параметр, который принимает метод или конструктор.</p>
</li>
<li>
<p><code>@deprecated</code> - этим тэгом помечаются класс или метод, которые больше не используются. Такой тэг будет размещен на видном месте в <strong>Javadoc</strong>. Сопровождается тэгом <code>@see</code> или <code>{@link}</code>.</p>
</li>
<li>
<p><code>@return</code> - что возвращает метод.</p>
</li>
<li>
<p><code>@see</code> - создает список "см.также". Используется в паре с тэгом <code>{@link}</code> для связи с содержимым.</p>
</li>
<li>
<p><code>{@link}</code> - используется для создания ссылок на другие классы или методы. Пример: <code>{@link Foo# bar}</code> ссылается на метод <code>bar</code>, который принадлежит классу <code>Foo</code>. Для ссылки на метод в том же классе, просто добавляется <code>#bar</code>.</p>
</li>
<li>
<p><code>@since 2.0</code> - версия с момента добавления функции.</p>
</li>
<li>
<p><code>@throws</code> - вид исключения, которое выдает метод. Обратим внимание, что для проверки этого тэга в коде должно быть указано исключение. В противном случае <strong>Javadoc</strong> выдаст ошибку. Тэг <code>@exception</code> является альтернативным тэгом.</p>
</li>
<li>
<p><code>@Override</code> - используется с интерфейсами и абстрактными классами. Выполняет проверку, чтобы увидеть, является ли метод переопределением.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_к_каким_элементам_добавлять_тэги_javadoc">15.2.3. К каким элементам добавлять тэги <strong>Javadoc</strong>?</h4>
<div class="paragraph">
<p>Тэги <strong>Javadoc</strong> добавляют к классам, методам и полям:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>тэги <code>@author</code> и <code>@version</code> добавляются только к классам и интерфейсам</p>
</li>
<li>
<p>тэг <code>@param</code> только для методов и конструкторов</p>
</li>
<li>
<p>тэг <code>@return</code> только для методов</p>
</li>
<li>
<p>тэг <code>@throws</code> для классов и методов</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_модификаторы_public_и_private_в_javadoc">15.2.4. Модификаторы <code>public</code> и <code>private</code> в <strong>Javadoc</strong></h4>
<div class="paragraph">
<p><strong>Javadoc</strong> включает классы, методы и т.д., модификатором <code>public</code>. Элементы, помеченные как <code>private</code>, не включаются в <strong>Javadoc</strong>, если специально не выбран <code>private</code> при создании <strong>Javadoc</strong>. Если опустить <code>public</code> из исходного кода, по умолчанию класс или метод доступны только для пакета. В этом случае он не будет включен в <strong>Javadoc</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_описание">15.2.5. Описание</h4>
<div class="paragraph">
<p><strong>Javadoc</strong> предоставляет как краткое, так и длинное описание. Вот пример, показывающий, как отформатирована часть описания:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">/**
* Short one line description.
* &lt;p&gt;
* Longer description. If there were any, it would be
* here.
* &lt;p&gt;
* And even more explanations to follow in consecutive
* paragraphs separated by HTML paragraph breaks.
*
* @param variable Description text text text.
* @return Description text text text.
*/
public int methodName (...) {
// method body with a return statement
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот пример взят из <a href="https://en.wikipedia.org/wiki/Javadoc">статьи в Википедии</a></p>
</div>
<div class="paragraph">
<p>Краткое описание является первым предложением с кратким описанием класса или метода в <strong>Javadoc</strong>. После точки анализатор перемещает остальную часть описания в длинное описание. Для обозначения начала нового абзаца используется html-тэг <code>&lt;p&gt;</code>. Окружать абзацы открывающими и закрывающими тэгами <code>&lt;p&gt;</code> не нужно, потому что компилятор <strong>Javadoc</strong> автоматически добавляет их. HTML можно использовать в описаниях, таких как неупорядоченный список, кодовые тэги, полужирные тэги или другие.</p>
</div>
<div class="paragraph">
<p>После описания вводится пустая строка (для удобства чтения), а затем добавляются тэги. Под тэгами добавить описание контента невозможно. Только методы и классы могут иметь тэги, а не поля. Поля (переменные) имеют только описания.</p>
</div>
<div class="paragraph">
<p>Первое предложение в примере очень похоже на элемент <code>shortdesc</code> в DITA. Предполагается, что это первое предложение является кратким описанием всего класса или метода. Если в одном из ваших слов есть точка (например, <code>Dr. Jones</code>), после точки нужно удалить пробел, добавив <code>Dr.&amp;nbsp;Jones</code> для его соединения.</p>
</div>
<div class="paragraph">
<p>Лучше избегать использования ссылок в первом предложении. После точки следующее предложение будет длинным абзацем, поэтому нужно загрузить первое предложение, чтобы оно было описательным. Время глаголов должно быть в настоящем времени, например, <em>получает, помещает, отображает, вычисляет</em> …</p>
</div>
<div class="paragraph">
<p>Если метод настолько очевиден (например, <code>printPage()</code>), что описание <em>печатает страницу</em> становится избыточным и выглядит бесполезным? В этих случаях <strong>Oracle</strong> говорит, что можно опустить фразу <em>печатать страницу</em> и вместо этого попытаться предложить другое понимание. Oracle предлагает:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Добавить описание под именем API. Лучшие имена API являются «само документируемыми», то есть они в основном говорят вам, что делает API. Если комментарий к документу просто повторяет имя API в форме предложения, он не предоставляет больше информации. Например, если в описании метода используются только слова, которые встречаются в имени метода, то это вообще ничего не добавляет к тому, что вы могли бы вывести. Идеальный комментарий выходит за рамки этих слов и всегда должен вознаградить вас некоторой информацией, которая не сразу была очевидна из названия API.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Oracle<br>
<cite>https://www.oracle.com/technetwork/articles/java/index-137868.html</cite>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_избегаем_author">15.2.6. Избегаем <code>@author</code></h4>
<div class="paragraph">
<p>Комментируя лучшие практики <strong>Javadoc</strong>, некоторые люди рекомендуют использовать <code>@author</code>, потому что значение автора легко теряет актуальность, а элемент управления исходным кодом обеспечивает лучшее указание на последнего автора. (См. <a href="https://blog.joda.org/2012/11/javadoc-coding-standards.html">Javadoc coding standards</a> для подробной информации.)</p>
</div>
</div>
<div class="sect3">
<h4 id="_порядок_тэгов">15.2.7. Порядок тэгов</h4>
<div class="paragraph">
<p><strong>Oracle</strong> предлагает следующий порядок тэгов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">@author (classes and interfaces)
@version (classes and interfaces)
@param (methods and constructors)
@return (methods)
@throws (@exception is an older synonym)
@see
@since
@serial
@deprecated</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_param_тэги">15.2.8. <code>@param</code> тэги</h4>
<div class="paragraph">
<p>Тэги <code>@param</code> применяются только к методам и конструкторам, которые принимают параметры. После тэга <code>@param</code> добавляется имя параметра, а затем описание параметра в нижнем регистре без точки, например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">@param url the web address of the site</code></pre>
</div>
</div>
<div class="paragraph">
<p>Описание параметра — это фраза, а не полное предложение. Порядок нескольких тэгов <code>@param</code> должен соответствовать их порядку в методе или конструкторе.</p>
</div>
<div class="paragraph">
<p><a href="https://blog.joda.org/2012/11/javadoc-coding-standards.html">Стивен Коулборн рекомендует</a> добавить дополнительный пробел после имени параметра, чтобы повысить удобочитаемость.</p>
</div>
<div class="paragraph">
<p>Что касается включения типа данных в описание параметра, <strong>Oracle</strong> говорит:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>По соглашению, первым существительным в описании является тип данных параметра. (Артикли «a», «an» и «the» могут предшествовать существительному.) Исключение делается для примитива <code>int</code>, где тип данных обычно опускается.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Oracle<br>
<cite>https://www.oracle.com/technetwork/java/javase/documentation/index-137868.html#tag</cite>
</div>
</div>
<div class="paragraph">
<p>Пример, который дает <strong>Oracle</strong>, выглядит следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">@param ch the character to be tested</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тип данных также виден и из параметров в методе. Поэтому, даже если не включать типы данных, пользователям будет видно, что они собой представляют.</p>
</div>
<div class="paragraph">
<p>После имени параметра может быть несколько пробелов, чтобы все определения параметров были выстроены в линию.</p>
</div>
<div class="paragraph">
<p>Тэги <code>@param</code> должны быть предоставлены для каждого параметра в методе или конструкторе. Невыполнение этого требования приведет к ошибке и предупреждению при рендеринге <strong>Javadoc</strong>.</p>
</div>
<div class="paragraph">
<p>Обычно у классов нет параметров. Есть одно исключение: дженерики. Универсальные классы (дженерики) — это классы, которые работают с различными типами объектов. Объект указывается в качестве параметра в классе в скобках: <code>&lt;&gt;</code>. Хотя руководство <strong>Javadoc</strong> от Oracle не упоминает их, можно добавить тэг <code>@param</code> для универсального класса, чтобы отметить параметры для универсального класса. Детали в <a href="https://stackoverflow.com/questions/2015972/is-there-a-javadoc-tag-for-documenting-generic-type-parameters">посте на StackOverflow</a>. Вот пример с этой страницы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">/**
* @param &lt;T&gt; This describes my type parameter
    */
    class MyClass&lt;T&gt;{

        }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_return_тэги">15.2.9. <code>@return</code> тэги</h4>
<div class="paragraph">
<p>Возвращают значения только методы, поэтому только методы получают тэг <code>@return</code>. Если метод имеет модификатор <code>void</code>, он ничего не возвращает. Если в нем нет <code>void</code>, нужно включить тэг <code>@return</code>, чтобы избежать ошибки при компиляции <strong>Javadoc</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_throws_тэги">15.2.10. <code>@throws</code> тэги</h4>
<div class="paragraph">
<p>Тэги <code>@throws</code> добавляются в методы или классы только в том случае, если метод или класс генерируют ошибку определенного типа. Вот пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">@throws IOException if your input format is invalid</code></pre>
</div>
</div>
<div class="paragraph">
<p>Стивен Коулборн рекомендует начинать описание тэга throws с предложения «if» для удобства чтения. Он говорит:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>За функцией`@throws` обычно следует if … и остальная часть фразы, описывающая условие. Например, <code>@throws, if the file could not be found</code>. Это способствует удобочитаемости исходного кода и при его создании.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Стивен Коулборн
</div>
</div>
<div class="paragraph">
<p>Несколько тэгов <code>@throws</code> располагают в алфавитном порядке.</p>
</div>
</div>
<div class="sect3">
<h4 id="_комментарии_к_конструкторам">15.2.11. Комментарии к конструкторам</h4>
<div class="paragraph">
<p>Рекомендуется включать конструктор в класс. Однако, если конструктор отсутствует, <strong>Javadoc</strong> автоматически создает конструктор в <strong>Javadoc</strong>, но исключает любое описание конструктора.</p>
</div>
<div class="paragraph">
<p>Конструкторы имеют тэги <code>@param</code>, но не тэги <code>@return</code>. Все остальное так же, как и с методами.</p>
</div>
</div>
<div class="sect3">
<h4 id="_комментарии_к_полям">15.2.12. Комментарии к полям</h4>
<div class="paragraph">
<p>Поля имеют только описания. Можно добавлять комментарии в поле, если бы поле было чем-то, что пользователь будет использовать.</p>
</div>
</div>
<div class="sect3">
<h4 id="_кейсы_где_комментарии_не_нужны">15.2.13. Кейсы, где комментарии не нужны</h4>
<div class="paragraph">
<p>Oracle говорит, что есть три сценария, где комментарии к документу наследуются, поэтому вам не нужно включать комментарии в эти сценарии:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>когда метод в классе переопределяет метод в суперклассе;</p>
</li>
<li>
<p>когда метод в интерфейсе переопределяет метод в суперинтерфейсе;</p>
</li>
<li>
<p>когда метод в классе реализует метод в интерфейсе</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>См. <a href="https://www.oracle.com/technetwork/java/javase/documentation/index-137868.html#tag">How to write Javadoc comments</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_see_тэги">15.2.14. <code>@see</code> тэги</h4>
<div class="paragraph">
<p>Тэг <code>@see</code> предоставляет ссылку. Существуют различные способы обозначить то, на что надо ссылаться, чтобы создать ссылку. При ссылке на поле, конструктор или метод в том же поле, используется <code>#</code>.</p>
</div>
<div class="paragraph">
<p>При ссылке на другой класс, сначала пишется имя этого класса, затем <code>#</code> и имя конструктора, метода или поля.</p>
</div>
<div class="paragraph">
<p>При ссылке на класс в другом пакете, сначала указывается имя пакета, затем класс и так далее. Пример из <strong>Oracle</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">@see #field
@see #Constructor(Type, Type...)
@see #Constructor(Type id, Type id...)
@see #method(Type, Type,...)
@see #method(Type id, Type, id...)
@see Class
@see Class#field
@see Class#Constructor(Type, Type...)
@see Class#Constructor(Type id, Type id)
@see Class#method(Type, Type,...)
@see Class#method(Type id, Type id,...)
@see package.Class
@see package.Class#field
@see package.Class#Constructor(Type, Type...)
@see package.Class#Constructor(Type id, Type id)
@see package.Class#method(Type, Type,...)
@see package.Class#method(Type id, Type, id)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для подробной информации см. <a href="https://www.oracle.com/technetwork/java/javase/documentation/index-137868.html#tag">How to write Javadoc comments</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_ссылки">15.2.15. Ссылки</h4>
<div class="paragraph">
<p>Создавать ссылки на другие классы и методы можно используя тэг <code>{@link}</code>.</p>
</div>
<div class="paragraph">
<p>Пример создания ссылки из <a href="https://blog.joda.org/2012/11/javadoc-coding-standards.html">Javadoc coding standards</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">/**
* First paragraph.
* &lt;p&gt;
* Link to a class named 'Foo': {@link Foo}.
* Link to a method 'bar' on a class named 'Foo': {@link Foo#bar}.
* Link to a method 'baz' on this class: {@link #baz}.
* Link specifying text of the hyperlink after a space: {@link Foo the Foo class}.
* Link to a method handling method overload {@link Foo#bar(String,int)}.
*/
public ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для ссылки на другой метод в том же классе используется формат: <code>{@link #baz}</code>. Чтобы связать метод с другим классом, используется формат: <code>{@link Foo # baz}</code>. Тем не менее, не надо мудрить с гиперссылкой. При обращении к другим классам можно использовать тэги <code>&lt;code&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Для изменения связанного текста, после слова <code>#baz</code> пишется: <code>@see #baz Baz Method</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_предпросмотр_комментариев_javadoc">15.2.16. Предпросмотр комментариев <strong>Javadoc</strong></h4>
<div class="paragraph">
<p>Во многих IDE присутствует вкладка <strong>Javadoc</strong>, которую можно использовать для просмотра информации <strong>Javadoc</strong>, включенную для просматриваемого класса.</p>
</div>
</div>
<div class="sect3">
<h4 id="_зачем_такие_подробности_о_тэгах_javadoc">15.2.17. Зачем такие подробности о тэгах <strong>Javadoc</strong>?</h4>
<div class="paragraph">
<p>Для чего здесь добавлено много конкретных деталей и рекомендаций по стилю тэгов <strong>Javadoc</strong>? Для понимания того, что аннотации для <strong>Javadoc</strong> следуют множеству стилевых соглашений и лучших практик. Эти соглашения и рекомендации не всегда могут быть очевидны или соблюдаются в файлах Java, с которыми приходится работать. Можно добавить большую ценность, просто убедившись, что содержимое соответствует таким стилевым соглашениям.</p>
</div>
</div>
<div class="sect3">
<h4 id="_дополнительная_информация_о_javadoc">15.2.18. Дополнительная информация о <strong>Javadoc</strong></h4>
<div class="paragraph">
<p><a href="https://www.oracle.com/technetwork/articles/java/index-137868.html">Oracle’s explanation of Javadoc tags</a></p>
</div>
<div class="paragraph">
<p><a href="https://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html">Javadoc</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_изучение_вывода_javadoc">15.3. Изучение вывода <strong>Javadoc</strong></h3>
<div class="paragraph">
<p>Выходные данные <strong>Javadoc</strong> не сильно изменились за последние 20 лет, поэтому в некотором смысле они предсказуемы и знакомы. С другой стороны, выходные данные устарели и в них отсутствуют некоторые важные функции, такие как поиск или возможность добавления дополнительных страниц. Как же организован <strong>Javadoc</strong>?</p>
</div>
<div class="sect3">
<h4 id="_резюме_класса">15.3.1. Резюме класса</h4>
<div class="paragraph">
<p>Открываем файл `index.html`в директории с <strong>Javadoc</strong>, которую сгенерировали.</p>
</div>
<div class="paragraph">
<p>Вкладка "Резюме класса" показывает краткую версию каждого из классов. Описание, которое писали для каждого класса, отображается здесь. Это своего рода краткое справочное руководство по API.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/img/java/core/javadoc/class-summary.png" alt="Class summary">
</div>
</div>
<div class="paragraph">
<p>Для отображения деталей класса кликаем по его имени (в нашем примере это <code>ACMESmartphone</code> или <code>Dynamite</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="_детали_класса">15.3.2. Детали класса</h4>
<div class="paragraph">
<p>При просмотре страницы класса, мы получаем сводку полей, конструкторов и методов для класса. Опять же, это просто обзор. Если прокрутить вниз, то увидим полную информацию о каждом из этих элементов.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/img/java/core/javadoc/class-details.png" alt="Class details">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_другая_навигация">15.3.3. Другая навигация</h4>
<div class="paragraph">
<p>Если кликнуть на вкладку <strong>Package</strong> вверху, можно просмотреть классы по пакетам. Или можно перейти к классу, щелкнув имя класса в левом столбце. Также можно просмотреть все, кликнув <strong>Index</strong>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/img/java/core/javadoc/navigation.png" alt="Navigation">
</div>
</div>
<div class="paragraph">
<p>Для получения справки по организации <strong>Javadoc</strong> нужно кликнуть на вкладку <strong>Help</strong> вверху на навигационной панели.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_редактирование_тэгов_javadoc">15.4. Редактирование тэгов <strong>Javadoc</strong></h3>
<div class="paragraph">
<p>Разработчики довольно часто добавляют тэги <strong>Javadoc</strong> и краткие комментарии, когда они создают код Java. Фактически, если они не добавляют некоторые аннотации, среда IDE обычно выдает предупреждение об ошибке.</p>
</div>
<div class="paragraph">
<p>Однако комментарии, которые добавляют разработчики, могут быть плохими, неполными или непонятными. Работа технического писателя с <strong>Javadoc</strong> часто заключается в редактировании уже существующего контента, обеспечивая большую ясность, структуру, вставляя правильные теги и многое другое.</p>
</div>
<div class="sect3">
<h4 id="_на_что_обращать_внимание_при_редактировании_javadoc">15.4.1. На что обращать внимание при редактировании <strong>Javadoc</strong></h4>
<div class="paragraph">
<p>При редактировании <strong>Javadoc</strong> обращаем внимание на:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>отсутствие документации (большая часть <strong>Javadoc</strong> неполная, нужно искать недостающую документацию)</p>
</li>
<li>
<p>последовательный стиль (соответствуют ли существующие тэги соглашениям стиля Java с аннотациями)</p>
</li>
<li>
<p>ясность (некоторые описания неразборчивы из-за проклятия знаний, и без хорошего понимания Java может быть трудно разобраться в них)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_редактируем_javadoc">15.4.2. Редактируем <strong>Javadoc</strong></h4>
<div class="paragraph">
<p>Сделаем несколько изменений в классе и методе. Затем заново сгенерируем <strong>Javadoc</strong> и посмотрим на изменения, как они отображаются на выходе.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_localization_and_internationalization">16. Localization and Internationalization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Вопрос интернационализации пользовательского интерфейса - один из важных вопросов при разработке приложения. Для этого недостаточно использовать Unicode и перевести на нужный язык все сообщения пользовательского интерфейса. Интернационализация приложения означает нечто большее, чем поддержка Unicode. Дата, время, денежные суммы и даже числа могут по-разному представляться на различных языках.</p>
</div>
<div class="paragraph">
<p>Широкое распространение получили условные сокращения терминов <strong>интернационализации</strong> и <strong>локализации</strong> приложений <strong>i18n</strong> и <strong>l10n</strong>, в которых, цифра означает количество символов между первой и последней позицией:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>l10n</strong> - <strong>локализация</strong> (<strong>localization</strong>).</p>
</li>
<li>
<p><strong>i18n</strong> - <strong>интернационализация</strong> (<strong>internationalization</strong>);</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В отдельной литературе делают акцент на этих двух определениях, под которыми понимается:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Интернационализация</strong> - это процесс разработки приложения такой структуры, при которой дополнение нового языка не требует перестройки и компиляции (сборки) всего приложения.</p>
</li>
<li>
<p><strong>Локализация</strong> предполагает адаптацию интерфейса приложения под несколько языков. Добавление нового языка может внести определенные сложности в локализацию интерфейса.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Java</strong> - первый язык программирования, в котором изначально были предусмотрены средства интернационализации. Строки формируются из символов <em>Unicode</em>. Поддержка этого стандарта кодирования позволяет создавать Java-приложения, обрабатывающие тексты на любом из существующих в мире языков.</p>
</div>
<div class="sect2">
<h3 id="_региональные_стандарты_locale">16.1. Региональные стандарты Locale</h3>
<div class="paragraph">
<p>Приложение, которое адаптировано для международного рынка, легко определить по возможности выбора языка, для работы с ним. Но профессионально адаптированные приложения могут иметь разные региональные настройки даже для тех стран, в которых используется одинаковый язык. В любом случае команды меню, надписи на кнопках и программные сообщения должны быть переведены на местный язык, возможно с использованием специального национального алфавита. Но существует еще много других более тонких различий, которые касаются:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>форматов представления вещественных чисел (разделители целой и дробной частей, разделителей групп тысяч)</p>
</li>
<li>
<p>денежных сумм (включение и местоположения денежного знака)</p>
</li>
<li>
<p>формата даты (порядок следования и символы разделители дней, месяцев и лет)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Существует ряд классов, которые выполняют форматирование, принимая во внимание указанные выше различия. Для управления форматированием используется класс <code>Locale</code>.</p>
</div>
<div class="paragraph">
<p>Региональный стандарт <code>Locale</code> определяет язык. Кроме этого могут быть указаны географическое расположение и вариант языка. Например, в <em>США</em> используется следующий региональный стандарт:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>language=English, location=United States</pre>
</div>
</div>
<div class="paragraph">
<p>В Германии региональный стандарт имеет вид:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>language=German, location=Germany</pre>
</div>
</div>
<div class="paragraph">
<p>В Швейцарии используются четыре официальных языка:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>немецкий</p>
</li>
<li>
<p>французский</p>
</li>
<li>
<p>итальянский</p>
</li>
<li>
<p>ретороманский</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Поэтому немецкие пользователи в Швейцарии, вероятно, захотят использовать следующий региональный стандарт:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>language=German, location=Switzerland</pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае текст, даты и числа будут форматироваться так же, как и для Германии, но денежные суммы будут отображаться в швейцарских франках, а не в евро. Если задавать только язык, например <code>language=German</code>, то особенности конкретной страны (например, формат представления денежных единиц) не будут учтены.</p>
</div>
<div class="paragraph">
<p>Вариант языка используется довольно редко. Например, в настоящее время в норвежском языке (производном от датского) определены два набора правил правописания</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Bokmel</strong></p>
</li>
<li>
<p>новый <strong>Nynorsk</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В этом случае, для задания традиционных правил орфографии используется параметр, определяющий вариант:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>language=Norwegian, location=Norway, variant=Bokmel</pre>
</div>
</div>
<div class="paragraph">
<p>Для выражения языка и расположения в компактной и стандартной форме в Java используются коды, определенные <strong>Международной организацией по стандартизации</strong> (<strong>ISO</strong>). Язык обозначается двумя строчными буквами в соответствии со стандартом <strong>ISO-639</strong>, а страна(расположение) — двумя прописными буквами согласно стандарту <strong>ISO-3166</strong>.</p>
</div>
<div class="paragraph">
<p>Чтобы задать региональный стандарт, необходимо объединить код языка, код страны и вариант (если он есть), а затем передать полученную строку в конструктор класса Locale.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Locale german = new Locale("de");
Locale germanGermany = new Locale("de", "DE");
Locale germanSwitzerland = new Locale("de", "CH");
Locale norwegianNorwayBokmel = new Locale("no", "NO", "B");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для удобства пользователей в <strong>JDK</strong> предусмотрено несколько предопределенных объектов с региональными настройками, а для некоторых языков также имеются объекты, позволяющие указать язык без указания страны:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Предопределенные объекты с региональными установками</th>
<th class="tableblock halign-left valign-top">Объекты, позволяющие указать язык без указания страны</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Locale.CHINA</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Locale.CHINESE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Locale.FRANCE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Locale.FRENCH</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Locale.GERMANY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Locale.GERMAN</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Locale.ITALY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Locale.ITALIAN</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Locale.JAPAN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Locale.JAPANESE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Locale.US</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Locale.ENGLISH</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Помимо вызова конструктора или выбора предопределенных объектов, существует еще два пути получения объектов с региональными настройками. Статический метод <code>getDefault()</code> класса <code>Locale</code> позволяет определить региональную настройку, которая используется в операционной системе по-умолчанию. Изменить настройку по-умолчанию можно вызвав метод <code>setDefault()</code>. Однако следует помнить, что данный метод воздействует только на Java-программу, а не на операционную систему в целом.</p>
</div>
<div class="sect3">
<h4 id="_региональные_настройки_getavailablelocales">16.1.1. Региональные настройки, <code>getAvailableLocales()</code></h4>
<div class="paragraph">
<p>Метод <code>getLocale()</code> возвращает региональные настройки того компьютера, на котором он запущен. И наконец, все зависимые от региональных настроек вспомогательные классы могут возвращать массив поддерживаемых региональных стандартов. Например, приведенный ниже метод возвращает все региональные настройки, поддерживаемые классом <code>DateFormat</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Locale [] supportedLocales = DateFormat.getAvailableLocales();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Какие действия можно выполнять на основе полученных региональных настроек? Выбор невелик. Единственными полезными методами класса Locale являются методы определения кодов языка и страны. Наиболее важными из них является метод <code>getDisplayName()</code>, возвращающий строку с описанием региональной настройки, которая содержит не какие-то двух-буквенные загадочные коды, а вполне понятные пользователю обозначения</p>
</div>
<div class="listingblock">
<div class="content">
<pre>German(Switzerland)</pre>
</div>
</div>
<div class="paragraph">
<p>Но данная строка отображается на используемом по умолчанию языке, что далеко не всегда бывает удобно. Если пользователь выбрал немецкий язык интерфейса, то строку описания следует отобразить именно на немецком языке, для чего можно передать в качестве параметра соответствующую региональную настройку так, как представлено в следующих строках кода:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Locale loc = new Locale("de", "CH");
System.out.println (loc.getDisplayName(Locale.GERMAN));</code></pre>
</div>
</div>
<div class="paragraph">
<p>В результате выполнения этого кода описание региональной настройки будет выведено на указанном в ней языке:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Deutsch(Schweiz)</pre>
</div>
</div>
<div class="paragraph">
<p>Данный пример поясняет, зачем нужны объекты <code>Locale</code>. Передавая их методам, способным реагировать на региональные настройки, можно отображать текст на языке, понятном пользователю.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_форматирование_числовых_значений_numberformat">16.2. Форматирование числовых значений NumberFormat</h3>
<div class="paragraph">
<p>Ранее упоминалось, что в разных странах и регионах используются различные способы представления чисел и денежных сумм. В пакете <code>java.text</code> содержатся классы, позволяющие форматировать числа и выполнять разбор их строкового представления. Для форматирования чисел в соответствии с конкретным региональным стандартом необходимо выполнить ряд действий:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Получить объект регионального стандарта, как было описано в предыдущем разделе.</p>
</li>
<li>
<p>Использовать фабричный метод для получения объекта форматирования.</p>
</li>
<li>
<p>Применить полученный объект форматирования для формирования числа или разбора его строкового представления.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>В качестве <strong>фабричных методов</strong> (<strong>factory method</strong>) используются статические методы <code>getNumberInstance()</code>, <code>getCurrencyInstance()</code>, <code>getPercentInstance()</code> класса <code>NumberFormat</code>. Они получают в качестве параметра объект <code>Locale</code> и возвращают объекты, предназначенные для форматирования чисел, денежных сумм и значений, выраженных в процентах. Например, для отображения денежной суммы в формате, принятом в Германии, можно использовать приведенный ниже фрагмент кода:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Locale loc = new Locale("de", "DE");
NumberFormat currFmt;
currFmt = NumberFormat.getCurrencyInstance(loc);
double amt = 123456.78;
System.out.println (currFmt.format(amt));</code></pre>
</div>
</div>
<div class="paragraph">
<p>В результате выполнения этого кода будет получена следующая строка:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>123.456,78€</pre>
</div>
</div>
<div class="paragraph">
<p>Для обозначения евро здесь используется знак <code>€</code>, который располагается в конце строки. Кроме этого, следует обратить внимание на символы, применяемые для обозначения дробной части и разделения десятичных разрядов.</p>
</div>
<div class="paragraph">
<p>Для преобразования строки, записанной в соответствии с определенным региональным стандартом, в число предусмотрен метод <code>parse()</code>, который выполняет синтаксический анализ строки с автоматическим использованием заданного по умолчанию регионального стандарта. В приведенном ниже примере показан способ преобразования строки, введенной пользователем в поле редактирования, в число. Метод <code>parse()</code> способен преобразовывать числа, в которых в качестве разделителя используется точка и запятая.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">TextField inputField;
// ...
NumberFormat fmt = NumberFormat.getNumberInstance();
// Получить объект форматирования для используемого по умолчанию регионального стандарта
Number input = fmt.parse(inputField.getText().trim());
double x = input.doubleValue();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>parse()</code> возвращает результат абстрактного типа <code>Number</code>. На самом деле возвращаемый объект является экземпляром класса <code>Long</code> или <code>Double</code>, в зависимости от того, представляет исходная строка целое число или число с плавающей точкой. Если это не важно, то для получения числового значения достаточно использовать метод <code>doubleValue()</code> класса <code>Number</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Для объектов типа <code>Number</code> не поддерживается автоматическое приведение к простым типам.
Необходимо явным образом вызывать метод <code>doubleValue()</code> или <code>intValue()</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Если число представлено в некорректном формате, генерируется исключение <code>ParseException</code>. Например, не допускается наличие символа пробела в начале строки, преобразуемой в число (для их удаления следует использовать метод <code>trim()</code>). Любые символы, которые располагаются в строке после числа, лишь игнорируются и исключение в этом случае не возникает.</p>
</div>
<div class="paragraph">
<p>Очевидно, что классы, возвращаемые методами <code>get***Instance()</code>, являются экземплярами не абстрактного класса <code>NumberFormat</code>, а одного из его подклассов. Фабричным методам известно лишь то, как найти объект, представляющий определенный региональный стандарт.</p>
</div>
<div class="paragraph">
<p>Для получения списка поддерживаемых региональных стандартов можно использовать статистический метод <code>getAvailableLocales()</code>, возвращающий массив региональных стандартов, для которых существуют объекты форматирования.</p>
</div>
<div class="sect3">
<h4 id="_методы_пакета_java_text_numberformat">16.2.1. Методы пакета <code>java.text.NumberFormat</code></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Метод</th>
<th class="tableblock halign-left valign-top">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static Locale[] getAvailableLocales()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает массив объектов <code>Locale</code>, для которых доступны объекты форматирования</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static NumberFormat getNumberFormatInstance()</code></p></td>
<td class="tableblock halign-left valign-top" rowspan="6"><p class="tableblock">Возвращает объект форматирования чисел, денежных сумм или величин, представленных в процентах, для текущего или заданного регионального стандарта</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static NumberFormat getNumberFormatInstance(Locale l)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static NumberFormat getNumberCurrency()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static NumberFormat getNumberCurrencyInstance(Locale l)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static NumberFormat getNumberPercent()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static NumberFormat getNumberPercentInstance(Locale l)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String format(double x)</code></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock">Возвращает строку, полученную в результате форматирования заданного числа с плавающей точкой или целого числа.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String format(long x)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Number parse(String s)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает число, полученное после преобразования строки. Это число может иметь тип <code>Long</code> или <code>Double</code>. Строка не должна начинаться с пробелов. Любые символы в строке после числа игнорируются. Если преобразование закончилось неудачей, то метод генерирует исключение <code>ParseException</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void setParseIntegerOnly(boolean b)</code></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock">Устанавливает или возвращает признак того, что данный объект форматирования предназначен для преобразования только целочисленных значений.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean isParseIntegerOnly()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void setGroupingUsed(boolean b)</code></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock">Устанавливает или возвращает флаг, указывающий на то, что данный объект форматирования распознает символы разделения групп десятичных разрядов (например, <code>100</code>, <code>000</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean isGroupingUsed()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void setMinimumIntegerDigits(int n)</code></p></td>
<td class="tableblock halign-left valign-top" rowspan="8"><p class="tableblock">Устанавливает или возвращает максимальное либо минимальное количество цифр в целой или дробной части числа</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void setMaximumIntegerDigits(int n)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void setMinimumFractionDigits(int n)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void setMaximumFractionDigits(int n)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int getMinimumIntegerDigits()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int getMaximumIntegerDigits()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int getMinimumFractionDigits()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int getMaximumFractionDigits()</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_денежные_суммы">16.3. Денежные суммы</h3>
<div class="paragraph">
<p>Для форматирования денежных сумм используется метод <code>getCurrencyInstance()</code> класса <code>NumberFormat</code>. Однако этот метод не обеспечивает достаточной гибкости — он возвращает форматированную строку для одной валюты. Допустим, Вы выписываете счет для иностранного потребителя, в котором одни суммы представлены в долларах, а другие в евро. Использование двух приведенных ниже объектов форматирования не является решением задачи.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">NumberFormat dollarFormatter = NumberFormat.getCurrencyInstance(Locale.US);
NumberFormat euroFormatter = NumberFormat.getCurrencyInstance(Locale.GERMANY);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Счет, содержащий такие значения, как <code>$100,000</code> и <code>100.000€</code>, будет выглядеть достаточно странно, поскольку символы разделителей групп разрядов отличаются.</p>
</div>
<div class="paragraph">
<p>Для управления форматированием денежных сумм следует использовать класс <code>Currency</code>. Для получения объекта Currency необходимо передать статическому методу <code>Currency.getInstance()</code> идентификатор валюты. Затем необходимо вызвать метод <code>setCurrency()</code> каждого объекта форматирования. Ниже показано, как настроить объект форматирования евро для американского потребителя.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">NumberFormat euroFormatter = NumberFormat.getCurrencyInstance(Locale.US);
euroFormatter.setCurrency(Currency.getInstance("EUR"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Идентификаторы валют определены стандартом <strong>ISO 4217</strong>. Некоторые из них приведены в таблице.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Наименование валюты</th>
<th class="tableblock halign-left valign-top">Обозначение</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Белоруский рубль</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>BYR</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Доллар США</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>USD</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Евро</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>EUR</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Английский фунт</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>GBR</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Японская йена</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>JPY</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Индийская рупия</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>INR</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Российский рубль</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>RUB</strong></p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_методы_пакета_java_util_currency">16.3.1. Методы пакета java.util.Currency</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Метод</th>
<th class="tableblock halign-left valign-top">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static Currency getInstance(String currencyCode)</code></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock">Возвращает экземпляр класса <code>Currency</code>, соответствующий заданному коду <strong>ISO 4217</strong> или стране, указанной посредством объекта <code>Locale</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static Currency getInstance(Locale locale)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String toString()</code></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock">Возвращает код <strong>ISO 4217</strong> для данной валюты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String getCurrencyCode()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String getSymbol()</code></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock">Возвращает символ, обозначающий данную валюту в соответствии или заданными региональными настройками. Например, в зависимости от объекта <code>Locale</code>, доллар США (USD) может обозначаться как <code>$</code> или <code>US$</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String getSymbol(Locale locale)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int getDefaultFractionDigits()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает число цифр в дробной части для данной валюты, принятое по умолчанию</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_форматирование_даты_и_времени_dateformat">16.4. Форматирование даты и времени DateFormat</h3>
<div class="paragraph">
<p>При форматировании даты и времени в соответствии с региональными стандартами следует иметь в виду четыре особенности:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>названия месяцев и дней недели должны быть представлены на местном языке;</p>
</li>
<li>
<p>последовательность указания года, месяца и числа различаются для разных стран и регионов;</p>
</li>
<li>
<p>для отображения дат можно использовать календарь, отличный от григорианского;</p>
</li>
<li>
<p>следует учитывать часовые пояса.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Для учета перечисленных возможностей в Java имеется класс <code>DateFormat</code>, который используется почти также, как и класс <code>NumberFormat</code>. В первую очередь следует сформировать объект регионального стандарта. Для получения массива региональных стандартов, поддерживающих формат даты, можно использовать предлагаемый по умолчанию статический метод <code>getAvailableLocales()</code>. Далее необходимо вызвать один из трех фабричных методов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">fmt = DateFormat.getDateInstance(dateStyle, loc);
fmt = DateFormat.getTimeInstance(timeStyle, loc);
fmt = DateFormat.getDateTimeInstance(dateStyle, timeStyle, loc);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для указания нужного стиля предусмотрен параметр, в качестве которого задается одна из следующих констант:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">DateFormat.DEFAULT;
DateFormat.FULL; // `Wednesday, Septemer 15 2004, 8:15:03 pm` для регионального стандарта США
DateFormat.LONG; // `Septemer 15, 2004 8:15:03 pm` для регионального стандарта США
DateFormat.MEDIUM; // `Sep 15, 2004 8:15:03 pm` для регионального стандарта США
DateFormat.SHORT; // `9/15/04 8:15 pm` для регионального стандарта США</code></pre>
</div>
</div>
<div class="paragraph">
<p>Представленные выше фабричные методы возвращают объект, который можно использовать для форматирования даты.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Date date = new Date();
String s = fmt.format(date);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для преобразования строки в дату используется метод <code>parse()</code>, который работает аналогично одноименному методу класса <code>NumberFormat</code>. Например, приведенный ниже код преобразует строку, введенную пользователем в поле редактирования; при этом учитываются региональный настройки по умолчанию:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">TextField inputField;
// ...
DateFormat fmt;
fmt = DateFormat.getDateInstance(DateFormat.MEDIUM);
Date input = fmt.parse(inputField.getText().trim());</code></pre>
</div>
</div>
<div class="paragraph">
<p>В случае некорректного ввода даты попытка преобразования приведет к генерации исключения <code>ParseException</code>. Следует отметить, что в начале строки, подлежащей преобразованию в дату также не допускаются пробелы. Для их удаления следует вызвать метод <code>trim()</code>. Любые символы, которые располагаются после даты, игнорируются. К сожалению, пользователь должен вводить дату в конкретном формате. Например, если установлен тип представления даты <code>MEDIUM</code> в региональном стандарте США, то предполагается, что введенная строка должна иметь вид <code>Sep 18, 1997</code>. Но если пользователь введет строку <code>Sep 18 1997</code> (без запятой) или <code>9/18/97</code> (в кратком формате), то это приведет к ошибке преобразования.</p>
</div>
<div class="paragraph">
<p>Для интерпретации неточно указанных дат предусмотрен флаг <code>lenient</code>. Если данный флаг установлен, то неверно заданная дата <code>February 30, 1999</code> будет автоматически преобразована в дату <code>March 2, 1999</code>. Такое поведение вряд ли можно считать безопасным, поэтому данный флаг следует отключить. В этом случае, при попытке пользователя ввести некорректное сочетание дня, месяца и года во время преобразования строки в дату будет сгенерировано исключение <code>IllegalArgumentException</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_пакеты_ресурсов_resources">16.5. Пакеты ресурсов resources</h3>
<div class="paragraph">
<p>При локализации приложений необходимо переводить огромное количество сообщений, надписей интерфейса и т.п. Для упрощения задачи рекомендуется собрать все локализуемые строки в отдельном месте, которое называется <strong>ресурсом</strong> (<strong>resource</strong>). В этом случае достаточно отредактировать файлы ресурсов, не трогая исходный код программы.</p>
</div>
<div class="paragraph">
<p>В Java для определения строковых ресурсов используются файлы свойств, а для ресурсов других типов создаются классы ресурсов.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Технология использования ресурсов в Java отличается от технологии использования ресурсов в операционных системах <em>Windows</em> и <em>Macintosh</em>. В выполняемой программе системы <em>Windows</em> такие ресурсы, как меню, диалоговые окна, пиктограммы и сообщения, хранятся отдельно от программы. Поэтому специальный редактор ресурсов позволяет просматривать и модифицировать их без изменения программного кода.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
В Java технологии применяется концепция использования ресурсов, позволяющая размещать файлы данных, аудио файлы и изображения в JAR-архивах. Метод <code>getResource()</code> класса <code>Class</code> находит файл, открывает его и возвращает <code>URL</code>, указывающий на ресурс. При размещении файлов в JAR-архивах задачу поиска файлов решает загрузчик классов. Данный механизм обеспечивает поддержку региональных стандартов.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_определение_файла_ресурсов_resourcebundle">16.6. Определение файла ресурсов <code>ResourceBundle</code></h3>
<div class="paragraph">
<p>Для локализации приложений создаются так называемые <strong>пакеты ресурсов</strong> (<strong>resource bundle</strong>). Каждый пакет представляет собой файл свойств или класс, который описывает элементы, специфические для конкретного регионального стандарта (например, сообщения, надписи и т.д.). В каждый пакет помещаются ресурсы для всех региональных стандартов, поддержка которых предполагается в программе.</p>
</div>
<div class="paragraph">
<p>Для именования пакетов ресурсов используются специальные соглашения. Например, ресурсы, специфические для Германии, помещаются в файл с именем <code>имяПакета_de_DE</code>, а ресурсы, общие для стран, в которых используется немецкий язык, размещаются в классе <code>имяПакета_de</code>. Общие правила таковы: ресурсы для конкретной страны именуются по принципу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>имяПакета_язык_СТРАНА</pre>
</div>
</div>
<div class="paragraph">
<p>Имя файла ресурсов для конкретного языка формируется так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>имяПакета_язык</pre>
</div>
</div>
<div class="paragraph">
<p>Ресурсы, применяемые по умолчанию, помещаются в файл, имя которого не содержит суффикса. Для загрузки пакета ресурсов используется метод <code>getBundle()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ResourceBundle bundle;
bundle = ResourceBundle.getBundle("ProgramResources", currentLocale)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>getBundle()</code> пытается загрузить информацию из пакета ресурсов, которая соответствует языку, расположению и варианту текущего регионального стандарта. Если попытка загрузки окончилась неудачей, последовательно отбрасывается вариант, страна и язык. Затем осуществляется поиск ресурса, соответствующего текущему региональному стандарту, и происходит обращение к пакету ресурсов по умолчанию. Если и эта попытка завершается неудачей, генерируется исключение <code>MissingResourceException</code>. Таким образом, метод <code>getBundle()</code> пытается загрузить первый доступный ресурс из перечисленных пакетов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>имяПакета_трс_язык_трс_СТРАНА_трс_вариант
имяПакета_трс_язык_трс_СТРАНА
имяПакета_трс_язык

имяПакета_рсу_язык_рсу_СТРАНА_рсу_вариант
имяПакета_рсу_язык_рсу_СТРАНА
имяПакета_рсу_язык

имяПакета</pre>
</div>
</div>
<div class="paragraph">
<p>Здесь используются сокращения:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>трс</code> - текущий региональный стандарт;</p>
</li>
<li>
<p><code>рсу</code> - региональный стандарт по умолчанию.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Даже, если метод <code>getBundle()</code> находит пакет, например <code>имяПакета_de_DE</code>, он продолжает искать пакеты <code>имяПакета_de</code>, <code>имяПакета</code>. Если такие пакеты существуют, то они становятся родительскими по отношению к пакету <code>имяПакета_de_DE</code> в иерархии ресурсов. Родительские классы нужны в тех случаях, когда необходимый ресурс не найден в пакете <code>имяПакета_de_DE</code>, и выполняется поиск ресурса в пакетах <code>имяПакета_de</code>, <code>имяПакета</code>. Другими словами, поиск ресурса проверяется последовательно во всех пакетах до первого вхождения.</p>
</div>
<div class="paragraph">
<p>Очевидно, что это очень полезный механизм, однако для его реализации вручную программисту пришлось бы выполнить большой объем рутинной работы. Средства поддержки пакетов ресурсов Java автоматически находят ресурсы, наилучшим образом соответствующие конкретному региональному стандарту. Для включения в существующую программу новых локальных настроек необходимо всего лишь дополнить соответствующие пакеты ресурсов.</p>
</div>
<div class="paragraph">
<p>Создавая приложения, необязательно помещать все ресурсы в один пакет. Можно создать один пакет для надписей на кнопках, другой - для сообщений об ошибках и т.д.</p>
</div>
</div>
<div class="sect2">
<h3 id="_файлы_свойств_properties">16.7. Файлы свойств <code>properties</code></h3>
<div class="paragraph">
<p>Для интернационализации строк необходимо все строки поместить в файл свойств, например <code>MyPackage.properties</code>. Файл свойств - это обычный текстовый файл, каждая строка которого содержит ключ и значение. Пример содержимого такого файла приведен ниже:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="properties">colorName=black
PageSize=210x297
buttonName=Insert</code></pre>
</div>
</div>
<div class="paragraph">
<p>Имя файла выбирается по принципу, описанному в предыдущем разделе.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>MyPackage.properties
MyPackage_en.properties
MyPackage_de_DE.properties</pre>
</div>
</div>
<div class="paragraph">
<p>Для загрузки пакета ресурсов из файла свойств применяется приведенное ниже выражение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ResourceBundle bundle;
bundle = ResourceBundle.getBundle("MyPackage", locale);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Поиск конкретной строки выполняется следующим образом :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String label = bundle.getString ("PageSize");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Файлы свойств могут содержать только <strong>ASCII</strong>-символы. Для размещения в них сомволов в кодировке Unicode следует использовать формат <code>\uxxxx</code>. Например, строка <code>colorName=Зеленый</code> для кириллицы будет иметь вид</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="properties">colorName=\u0417\u0435\u043B\u0435\u043D\u044B\u0439</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_классы_реализующие_пакеты_ресурсов">16.8. Классы, реализующие пакеты ресурсов</h3>
<div class="paragraph">
<p>Для поддержки ресурсов, не являющихся строками, необходимо определить классы, являющиеся подклассами класса <code>ResourceBundle</code>. Выбор имен таких классов осуществляется в соответствии с соглашениями об именовании, например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>MyProgramResource.java
MyProgramResource_en.java
MyProgramResource_de_DE.java</pre>
</div>
</div>
<div class="paragraph">
<p>Для загрузки класса используется тот же метод <code>getBundle()</code>, что и для загрузки свойств.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">ResourceBoundle boundle = ResourceBoundle.getBundle ("MyProgrammResource", locale);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если два пакета ресурсов, один из которых реализован в виде класса, а другой в виде файла свойств имеют одинаковые имена, то при загрузке предпочтение отдается классу. В каждом классе, реализующем пакет ресурсов, поддерживается таблица поиска. Для получения значения используется строка-ключ.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Color background;
double[] paperSize;
background = (Color) bundle.getObject("backgroundColor");
paperSize = (double[])bundle.getObject("defaultPaperSize");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Самый простой способ реализации пакета ресурсов — создание подкласса <code>ListResourceBundle</code>. Класс <code>ListResourceBundle</code> позволяет помещать все ресурсы в массив объектов и выполнять поиск. Подкласс класса <code>ListResourceBundle</code> должен иметь следующую структуру:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class имяПакета_язык_СТРАНА extends ListResourceBundle {
    private static final Objects[][] contents = {
        {ключ1, значение1},
        {ключ2, значение2},
        // ...
    };

    public Object[][] getContents() {
        return contents;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Пример классов, созданных на базе <code>ListResourceBundle</code>, приведен ниже.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class ProgramResources_de extends ListResourceBundle {
    private static final Objects[][] contents = {
        {"backgroundColor", Color.black},
        {defaultPaperSize, new double[] {210, 297}}
    };

    public Object[][] getContents() {
        return contents;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class ProgramResources_en_US extends ListResourceBundle {
    private static final Objects[][] contents = {
        {"backgroundColor", Color.blue},
        {defaultPaperSize, new double[] {216, 279}}
    };

    public Object[][] getContents() {
        return contents;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Класс пакета ресурсов можно также создать как подкласс класса <code>ResourceBundle</code>. В этом случае необходимо реализовывать два метода, предназначенные для получения объекта <code>Enumeration</code>, содержащего ключи, и для извлечения значения, соответствующего конкретному ключу.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">Enumeration &lt;String&gt; getKeys ();
Object handleGetObject (String key);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>getObject()</code> класса <code>ResourceBundle</code> вызывает определяемый разработчиком метод <code>handleGetObject ()</code>.</p>
</div>
<div class="sect3">
<h4 id="_методы_пакета_java_util_resourcebundle">16.8.1. Методы пакета <code>java.util.ResourceBundle</code></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static ResourceBundle getBundle (String baseName, Locale loc)</code></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock">Загружает класс пакета ресурсов с заданным именем, а также его родительские классы для указанного регионального стандарта. Если классы пакетов расположены в Java-пакете, то должно быть указано полное имя, например, <code>intl.ProgramResources</code>. Классы пакетов ресурсов должны быть объявлены открытыми (<code>public</code>), чтобы метод <code>getBundle()</code> мог обращаться к ним.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static ResourceBundle getBundle (String baseName)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Object getObject (String name)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Извлекает объект из пакета ресурсов или его родительских пакетов.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String getString (String name)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Извлекает объект из пакета ресурсов или его родительских пакетов и приводит к типу <code>String</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String[] getStringArray (String name)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Извлекает объект из пакета ресурсов или его родительских пакетов и представляет в виде массива строк.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Enumeration &lt;String&gt; getKeys()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает объект <code>Enumeration</code>, содержащий ключи текущего пакета ресурсов. При этом в объект <code>Enumeration</code> также помещаются ключи из родительских пакетов ресурсов.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Object handleGetObject(String key)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">При реализации собственного механизма поиска ресурсов, данный метод следует переопределить так, чтобы он возвращал значение, соответствующее указанному ключу.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_форматирование_сообщений_messageformat">16.9. Форматирование сообщений <code>MessageFormat</code></h3>
<div class="paragraph">
<p>В библиотеке Java содержится класс MessageFormat, который форматирует текст, содержащий фрагменты, представленные посредством переменных. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String template = "On {2}, a {0} destroyed {1} houses and caused {3} of damage.";</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном примере номера в фигурных скобках используются как "заполнители" для реальных имен и значений. Статический метод MessageFormat.format () позволяет подставить значения переменных. В JDK 5.0 поддерживаются методы с переменным числом параметров: таким образом, подстановка может быть выполнена так, как показано ниже.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String message;
message = MessageFormat.format(template, "hurricane", 99,
                new GregorianCalendar(1999, 0, 1).getTime(), 10.0E7);</code></pre>
</div>
</div>
<div class="paragraph">
<p>В более старых версиях <strong>JDK</strong> необходимо было помещать значения в массив <code>Object[]</code>. В рассматриваемом примере переменная <code>{0}</code> замещается значением <code>hurricane</code>, переменная <code>{1}</code> заменяется значением <code>99</code> и т.д.</p>
</div>
<div class="paragraph">
<p>Статический метод <code>format()</code> форматирует значения с учетом текущего регионального стандарта. Для того, чтобы использовать класс <code>MessageFormat</code> с произвольными региональными настройками, необходимо поступить следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">MessageFormat mf = new MessageFormat(pattern locale);
String msg = mf.format(new Object[] { значения });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь вызывается метод <code>format()</code> суперкласса <code>Format</code>. К сожалению, класс <code>MessageFormat</code> не предоставляет аналогичный метод, обеспечивающий работу с переменным числом параметров. В результате обработки строки, рассматриваемой в качестве примера, будет получено следующее сообщение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>On 1/1/99 12:00 АМ, a hurricane destroyed 99 houses and caused 100,000,000 of damage.</pre>
</div>
</div>
<div class="paragraph">
<p>Результат можно преобразовать, если сумму ущерба представить в денежных единицах, а дату с учетом формата:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String template = "On {2,date,long}, a {0} destroyed {1} "
                    + "houses and caused {3,number,currency} of damage.";</code></pre>
</div>
</div>
<div class="paragraph">
<p>В результате будет получено сообщение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>On January 1, 1999, a hurricane destroyed 99 houses and caused $100,000,000 of damage.</pre>
</div>
</div>
<div class="paragraph">
<p>В составе переменной допускается задавать тип и стиль, которые разделяются запятыми. Допустимыми значениями являются следующие типы: <code>number</code>, <code>time</code>, <code>date</code>, <code>choice</code>. Если указан тип <code>number</code>, то возможны следующие стили: <code>integer</code>, <code>currency</code>, <code>percent</code>. Кроме того, в качестве стиля может быть указан шаблон числового формата, например <code>$,##0</code>. Дополнительную информацию по данному вопросу можно найти в описании класса <code>DecimalFormat</code>.</p>
</div>
<div class="paragraph">
<p>Для типа <code>time</code> и <code>date</code> может быть указан один из следующих стилей: <code>short</code>, <code>medium</code>, <code>long</code>, <code>full</code>.</p>
</div>
<div class="paragraph">
<p>Аналогично числам, в качестве стиля может быть использован шаблон даты. Допустимые форматы подробно рассматриваются в описании класса <code>SimpleDateFormat</code>.</p>
</div>
<div class="paragraph">
<p>Форматы выбора (тип <code>choice</code>) имеют более сложную структуру и подробно рассматриваются далее.</p>
</div>
<div class="sect3">
<h4 id="_методы_класса_messageformat">16.9.1. Методы класса <code>MessageFormat</code></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Наименование метода</th>
<th class="tableblock halign-left valign-top">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessageFormat(String pattern)</code></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock">Создает объект форматирования сообщения согласно указанному шаблону и региональному стандарту.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessageFormat(String pattern, Locale locale)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void applyPattern(String pattern)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Задает шаблон для объекта форматирования.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void setLocale(Locale locale)</code></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock">Устанавливает или возвращает региональный стандарт для переменных в составе сообщения. Он используется только для последующих шаблонов, заданных с помощью метода <code>applyPattern()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Locale getLocale()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static String format(String pattern, Object&#8230;&#8203; args)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Форматирует строку согласно шаблону <code>pattern</code>, заменяя в нем переменные <code>{i}</code> значениями объектов из массива <code>args[i]</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StringBuffer format(Object args, StringBuffer result, FieldPosition pos)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Форматирует шаблон данного объекта <code>MessageFormat</code>. Параметр <code>args</code> должен представлять собой массив объектов. Форматируемая строка добавляется к значению result, которое затем возвращается. Если параметр pos эквивалентен <code>new FieldPosition(MessageFormat.Field.ARGUMENT)</code>, его свойства <code>beginIndex</code> и <code>endIndex</code> устанавливаются в соответствии с расположением текста, который замещает переменную <code>{1}</code>. Если информация о расположении Вас не интересует, в качестве этого параметра следует задать значение <code>null</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Класс <code>java.text.Format</code> имеет метод <code>String format(Object object)</code>, который форматирует заданный объект в соответствии с правилами, определенными посредством текущего объекта форматирования. В процессе работы данный метод обращается к методу <code>format(object, new StringBuffer(), new FieldPosition(1)).toString()</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_формат_выбора_choice">16.9.2. Формат выбора <code>choice</code></h4>
<div class="paragraph">
<p>Использование формата выбора предполагает определение последовательности пар значений, каждая из которых содержит нижнюю границу и строку подстановки. Нижняя граница и строка подстановки разделяются символами <code>#</code>, а для разделения пар значений используется символ <code>|</code>. Ниже приведен пример переменной с указанием формата выбора.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{1, choice, 0#no houses | 1#one house | 21 houses}</pre>
</div>
</div>
<div class="paragraph">
<p>Результаты форматирования, в зависимости от значения <code>{1}</code>, представлены в следующей таблице.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">{1}</th>
<th class="tableblock halign-left valign-top">Результат</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>no houses</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>one house</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>3</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>3 houses</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>no houses</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Может возникнуть вопрос, а зачем в форматируемой строке дважды указывается переменная <code>{1}</code>? Когда для этой переменной применяется формат выбора и значение оказывается большим или равным <code>2</code>, возвращается выражение <code>{1} houses</code>. Оно форматируется снова и включается в результирующую строку.</p>
</div>
<div class="paragraph">
<p>Данный пример показывает, что разработчики формата выбора приняли не самое лучшее решение. Если есть два варианта форматируемых строк, то для их разделения достаточно двух граничных значений, но согласно формату нужно задать три таких значения. Наименьшее из них никогда не используется. Синтаксис мог бы быть более понятным, если бы границы указывались между вариантами значений, например следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>no houses | 1|one house | 2{1} houses  // к сожалению данный формат не поддерживается</pre>
</div>
</div>
<div class="paragraph">
<p>С помощью символа <code>&lt;</code> можно указать, что предполагаемый вариант должен быть выбран, если нижняя граница строго меньше значения.</p>
</div>
<div class="paragraph">
<p>Завершая пример о последствиях стихийного бедствия, необходимо поместить строку с условиями выбора внутри исходной строки сообщения. В результате получится следующая конструкция:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String pattern = "On {2, date, long}, {0} destroyed "
                    + "{1, choice, 0#no houses | 1#one house | 21 houses} "
                    + " and caused {3, number, currency} of damage.";</code></pre>
</div>
</div>
<div class="paragraph">
<p>В немецком варианте она будет выглядеть иначе.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">String pattern = "{0} zerstörte am {2, date, long} "
                    + "{1, choice, 0#kein Haus | 1#ein Haus | 21 Häuser} "
                    + " und richtete einen Shaden von {3, number, currency} an.";</code></pre>
</div>
</div>
<div class="paragraph">
<p>Примечательно, что последовательность слов в английском и немецком вариантах разная, но методу <code>format()</code> передается тот же самый массив объектов. Под требуемый порядок слов подстраивается только последовательность появления переменных.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-01-31 08:52:30 UTC
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js"></script>
</body>
</html>