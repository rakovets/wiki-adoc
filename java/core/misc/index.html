<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<title>Java Misc</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Java Misc</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_stringbuffer_и_stringbuilder"><code>StringBuffer</code> и <code>StringBuilder</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Объекты <code>String</code> являются неизменяемыми, поэтому все операции, которые изменяют строки, фактически приводят к созданию новой строки, что сказывается на производительности приложения. Для решения этой проблемы, чтобы работа со строками проходила с меньшими издержками в Java были добавлены классы <code>StringBuffer</code> и <code>StringBuilder</code>. По сути они напоминает расширяемую строку, которую можно изменять без ущерба для производительности.</p>
</div>
<div class="paragraph">
<p>Эти классы похожи, практически двойники, они имеют одинаковые конструкторы, одни и те же методы, которые одинаково используются. Единственное их различие состоит в том, что класс <code>StringBuffer</code> синхронизированный и потокобезопасный. То есть класс <code>StringBuffer</code> удобнее использовать в многопоточных приложениях, где объект данного класса может меняться в различных потоках. Если же речь о многопоточных приложениях не идет, то лучше использовать класс <code>StringBuilder</code>, который не потокобезопасный, но при этом работает быстрее, чем <code>StringBuffer</code> в однопоточных приложениях.</p>
</div>
<div class="paragraph">
<p><code>StringBuffer</code> определяет четыре конструктора:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StringBuffer()
StringBuffer(int capacity)
StringBuffer(String str)
StringBuffer(CharSequence chars)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Аналогичные конструкторы определяет <code>StringBuilder</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StringBuilder()
StringBuilder(int capacity)
StringBuilder(String str)
StringBuilder(CharSequence chars)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Рассмотрим работу этих классов на примере функциональности <code>StringBuffer</code>.</p>
</div>
<div class="paragraph">
<p>При всех операциях со строками <code>StringBuffer</code> / <code>StringBuilder</code> перераспределяет выделенную память. И чтобы избежать слишком частого перераспределения памяти, <code>StringBuffer</code>/<code>StringBuilder</code> заранее резервирует некоторую область памяти, которая может использоваться. Конструктор без параметров резервирует в памяти место для 16 символов. Если мы хотим, чтобы количество символов было иным, то мы можем применить второй конструктор, который в качестве параметра принимает количество символов.</p>
</div>
<div class="paragraph">
<p>Третий и четвертый конструкторы обоих классов принимают строку и набор символов, при этом резервируя память для дополнительных 16 символов.</p>
</div>
<div class="paragraph">
<p>С помощью метода <code>capacity()</code> мы можем получить количество символов, для которых зарезервирована память. А с помощью метода <code>ensureCapacity()</code> изменить минимальную емкость буфера символов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str = "Java";
StringBuffer strBuffer = new StringBuffer(str);
System.out.println("Емкость: " + strBuffer.capacity()); // 20
strBuffer.ensureCapacity(32);
System.out.println("Емкость: " + strBuffer.capacity()); // 42
System.out.println("Длина: " + strBuffer.length()); // 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так как в самом начале <code>StringBuffer</code> инициализируется строкой <code>"Java"</code>, то его емкость составляет 4 + 16 = 20 символов. Затем мы увеличиваем емкость буфера с помощью вызова <code>strBuffer.ensureCapacity(32)</code> повышаем минимальную емкость буфера до 32 символов. Однако финальная емкость может отличаться в большую сторону. Так, в данном случае я получаю емкость не 32 и не 32 + 4 = 36, а 42 символа. Дело в том, что в целях повышения эффективности Java может дополнительно выделять память.</p>
</div>
<div class="paragraph">
<p>Но в любом случае вне зависимости от емкости длина строки, которую можно получить с помощью метода <code>length()</code>, в <code>StringBuffer</code> остается прежней - 4 символа (так как в <code>"Java"</code> 4 символа).</p>
</div>
<div class="paragraph">
<p>Чтобы получить строку, которая хранится в <code>StringBuffer</code>, мы можем использовать стандартный метод <code>toString()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String str = "Java";
StringBuffer strBuffer = new StringBuffer(str);
System.out.println(strBuffer.toString()); // Java</code></pre>
</div>
</div>
<div class="paragraph">
<p>По всем своим операциям <code>StringBuffer</code> и <code>StringBuilder</code> напоминают класс <code>String</code>.</p>
</div>
<div class="sect2">
<h3 id="_charat_и_setcharat"><code>charAt()</code> и <code>setCharAt()</code></h3>
<div class="paragraph">
<p>Метод <code>charAt()</code> получает, а метод <code>setCharAt()</code> устанавливает символ по определенному индексу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StringBuffer strBuffer = new StringBuffer("Java");
char c = strBuffer.charAt(0); // J
System.out.println(c);
strBuffer.setCharAt(0, 'c');
System.out.println(strBuffer.toString()); // cava</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_getchars"><code>getChars()</code></h3>
<div class="paragraph">
<p>Метод <code>getChars()</code> получает набор символов между определенными индексами:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StringBuffer strBuffer = new StringBuffer("world");
int startIndex = 1;
int endIndex = 4;
char[] buffer = new char[endIndex-startIndex];
strBuffer.getChars(startIndex, endIndex, buffer, 0);
System.out.println(buffer); // orl</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_append"><code>append()</code></h3>
<div class="paragraph">
<p>Метод <code>append()</code> добавляет подстроку в конец <code>StringBuffer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StringBuffer strBuffer = new StringBuffer("hello");
strBuffer.append(" world");
System.out.println(strBuffer.toString()); // hello world</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_insert"><code>insert()</code></h3>
<div class="paragraph">
<p>Метод <code>insert()</code> добавляет строку или символ по определенному индексу в <code>StringBuffer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StringBuffer strBuffer = new StringBuffer("word");

strBuffer.insert(3, 'l');
System.out.println(strBuffer.toString()); // world

strBuffer.insert(0, "s");
System.out.println(strBuffer.toString()); // sworld</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_delete_и_deletecharat"><code>delete()</code> и <code>deleteCharAt()</code></h3>
<div class="paragraph">
<p>Метод <code>delete()</code> удаляет все символы с определенного индекса о определенной позиции, а метод <code>deleteCharAt()</code> удаляет один символ по определенному индексу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StringBuffer strBuffer = new StringBuffer("assembler");
strBuffer.delete(0,2);
System.out.println(strBuffer.toString()); // sembler

strBuffer.deleteCharAt(6);
System.out.println(strBuffer.toString()); // semble</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_substring"><code>substring()</code></h3>
<div class="paragraph">
<p>Метод <code>substring()</code> обрезает строку с определенного индекса до конца, либо до определенного индекса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StringBuffer strBuffer = new StringBuffer("hello java!");
String str1 = strBuffer.substring(6); // обрезка строки с 6 символа до конца
System.out.println(str1); //java!

String str2 = strBuffer.substring(3, 9); // обрезка строки с 3 по 9 символ
System.out.println(str2); //lo jav</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_setlength"><code>setLength()</code></h3>
<div class="paragraph">
<p>Для изменения длины <code>StringBuffer</code> (не емкости буфера символов) применяется метод <code>setLength()</code>. Если <code>StringBuffer</code> увеличивается, то его строка просто дополняется в конце пустыми символами, если уменьшается - то строка по сути обрезается:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StringBuffer strBuffer = new StringBuffer("hello");
strBuffer.setLength(10);
System.out.println(strBuffer.toString()); // "hello     "

strBuffer.setLength(4);
System.out.println(strBuffer.toString()); // "hell"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_replace"><code>replace()</code></h3>
<div class="paragraph">
<p>Для замены подстроки между определенными позициями в <code>StringBuffer</code> на другую подстроку применяется метод <code>replace()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StringBuffer strBuffer = new StringBuffer("hello world!");
strBuffer.replace(6, 11, "java");
System.out.println(strBuffer.toString()); // hello java!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Первый параметр метода <code>replace()</code> указывает, с какой позиции надо начать замену, второй параметр - до какой позиции, а третий параметр указывает на подстроку замены.</p>
</div>
</div>
<div class="sect2">
<h3 id="_reverse"><code>reverse()</code></h3>
<div class="paragraph">
<p>Метод <code>reverse()</code> меняет порядок в <code>StringBuffer</code> на обратный:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StringBuffer strBuffer = new StringBuffer("assembler");
strBuffer.reverse();
System.out.println(strBuffer.toString()); // relbmessa</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_форматирование_строк">Форматирование строк</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_класс_formatter">Класс <code>Formatter</code></h3>
<div class="paragraph">
<p>Базовой частью поддержки создания форматированного вывода в языке Java служит класс <code>Formatter</code>, включенный в пакет <code>java.util</code>. Он обеспечивает <strong>преобразования формата</strong> (<strong>format conversions</strong>) позволяющие выводить числа, строки и время и даты практически в любом понравившемся вам формате.</p>
</div>
<div class="paragraph">
<p>В классе <code>Formatter</code> объявлен метод <code>format()</code>, который преобразует переданные в него параметры в строку заданного формата и сохраняет в объекте типа <code>Formatter</code>.</p>
</div>
<div class="paragraph">
<p>Рассмотрим использование класса <code>Formatter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.Formatter;

public class SimpleFormatString {
    public static void main(String[] args) {
        Formatter f = new Formatter();
        f.format("This %s is about %n%S %c", "book", "java", '8');
        System.out.print(f);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>где <code>%s</code> называется <strong>спецификатором формата</strong>.</p>
</div>
<div class="paragraph">
<p>Следующий пример использует класс <code>Formatter</code> для отображения дробного числа:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.Formatter;

public class FormatDemo1 {
    public static void main(String[] args) {
        double x = 1000.0 / 3.0;
        System.out.println("Строка без форматирования: " + x);

        Formatter formatter = new Formatter();
        formatter.format("Строка c форматированием: %.2f%n", x);
        formatter.format("Строка c форматированием: %8.2f%n", x);
        formatter.format("Строка c форматированием: %16.2f%n", x);
        System.out.println(formatter);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_метод_format_классов_string_printstream_и_printwriter">Метод <code>format()</code> классов <code>String</code>, <code>PrintStream</code> и <code>PrintWriter</code></h3>
<div class="paragraph">
<p>Аналогичный метод <code>format()</code> объявлен у классов <code>PrintStream</code> и <code>PrintWriter</code>. <code>System.out</code> это статическая переменная типа <code>PrintStream</code>.</p>
</div>
<div class="paragraph">
<p>В Java 5 для классов <code>PrintStream</code> и <code>PrintWriter</code> добавлен метод <code>printf()</code>. Методы <code>printf()</code> и <code>format()</code> автоматически используют класс <code>Formatter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class FormatDemo4 {
    public static void main(String[] args) {
        System.out.printf("Строка c форматированием: %.2f%n", 1000.0 / 3.0);
        System.out.format("%s, в следующем году вам будет %d", "Джон", 23);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>С помощью метода <code>String.format()</code> тоже возможно форматирование:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class StringFormatDemo {
    public static void main(String[] args) {
        String str = String.format("Строка c форматированием: %16.2f", 1000.0 / 3.0);
        System.out.println(str);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_спецификаторы_формата">Спецификаторы формата</h3>
<div class="ulist">
<ul>
<li>
<p><code>%a</code> Шестнадцатеричное значение с плавающей точкой</p>
</li>
<li>
<p><code>%b</code> Логическое (булево) значение аргумента</p>
</li>
<li>
<p><code>%c</code> Символьное представление аргумента</p>
</li>
<li>
<p><code>%d</code> Десятичное целое значение аргумента</p>
</li>
<li>
<p><code>%h</code> Хэш-код аргумента</p>
</li>
<li>
<p><code>%e</code> Экспоненциальное представление аргумента</p>
</li>
<li>
<p><code>%f</code> Десятичное значение с плавающей точкой</p>
</li>
<li>
<p><code>%g</code> Выбирает более короткое представление из двух: <code>%е</code> или <code>%f</code></p>
</li>
<li>
<p><code>%o</code> Восьмеричное целое значение аргумента</p>
</li>
<li>
<p><code>%n</code> Вставка символа новой строки</p>
</li>
<li>
<p><code>%s</code> Строковое представление аргумента</p>
</li>
<li>
<p><code>%t</code> Время и дата</p>
</li>
<li>
<p><code>%x</code> Шестнадцатеричное целое значение аргумента</p>
</li>
<li>
<p><code>%%</code> Вставка знака <code>%</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_флаги_формата">Флаги формата</h3>
<div class="ulist">
<ul>
<li>
<p><code>-</code> выравнивание влево</p>
</li>
<li>
<p><code>#</code> изменяет формат преобразования</p>
</li>
<li>
<p><code>0</code> выводит значение, дополненное нулями вместо пробелов. Применим только к числам</p>
</li>
<li>
<p>` ` положительные числа предваряются пробелом</p>
</li>
<li>
<p><code>+</code> положительные числа предваряются знаком +. Применим только к числам</p>
</li>
<li>
<p><code>,</code> числовые значения включают разделители групп. Применим только к числам</p>
</li>
<li>
<p><code>(</code> отрицательные числовые значения заключаются в скобки. Применим только к числам</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Рассмотрим пример использования флагов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class FormatterDemo2 {
    public static void main(String[] args) {
        System.out.printf("%,.2f%n", 10000.0 / 3.0);
        System.out.printf("%, (.2f%n", -10000.0 / 3.0);
        System.out.printf("%09.2f%n", 10000.0 / 3.0);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В строке, определяющей формат, может задаваться индекс форматируемого параметра. Индекс должен следовать непосредственно за символом <code>%</code> и завершаться знаком <code>$</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class FormatterDemo3 {
    public static void main(String[] args) {
        System.out.printf("Hello %1$s!%n%1$s, how are you?%n"
                        + "Welcome to the site %2$s",
                "John", "www.site.com");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Общий синтаксис можно описать так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">%[аргумент_индекс][флаги][ширина][.точность]символ_преобразования</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_перечисления">Перечисления</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Кроме отдельных примитивных типов данных и классов в <strong>Java</strong> есть такой тип как <code>enum</code> или <strong>перечисление</strong>. Перечисления представляют набор логически связанных констант. Объявление перечисления происходит с помощью оператора <code>enum</code>, после которого идет название перечисления. Затем идет список элементов перечисления через запятую:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">enum Day {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Перечисление фактически представляет новый тип, поэтому мы можем определить переменную данного типа и использовать ее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String[] args) {
        Day current = Day.MONDAY;
        System.out.println(current); // MONDAY
    }
}

enum Day {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Перечисления могут использоваться в классах для хранения данных:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String[] args) {
        Book b1 = new Book("War and Peace", "L. Tolstoy", Type.BELLETRE);
        System.out.printf("Book '%s' has a type %s", b1.name, b1.bookType);

        switch (b1.bookType) {
            case BELLETRE:
                System.out.println("Belletre");
                break;
            case SCIENCE:
                System.out.println("Science");
                break;
            case SCIENCE_FICTION:
                System.out.println("Science fiction");
                break;
            case PHANTASY:
                System.out.println("Phantasy");
                break;
        }
    }
}

class Book {
    String name;
    Type bookType;
    String author;

    Book(String name, String author, Type type) {
        bookType = type;
        this.name = name;
        this.author = author;
    }
}

enum Type {
    SCIENCE,
    BELLETRE,
    PHANTASY,
    SCIENCE_FICTION
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Само перечисление объявлено вне класса, оно содержит четыре жанра книг. Класс <code>Book</code> кроме обычных переменных содержит также переменную типа нашего перечисления. В конструкторе мы ее также можем присвоить, как и обычные поля класса.</p>
</div>
<div class="paragraph">
<p>С помощью конструкции <code>switch..case</code> можно проверить принадлежность значения <code>bookType</code> определенной константе перечисления.</p>
</div>
<div class="sect2">
<h3 id="_методы_перечислений">Методы перечислений</h3>
<div class="paragraph">
<p>Каждое перечисление имеет статический метод <code>values()</code>. Он возвращает массив всех констант перечисления:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String[] args) {
        Type[] types = Type.values();
        for (Type s : types) {
            System.out.println(s);
        }
    }
}

enum Type {
    SCIENCE,
    BELLETRE,
    PHANTASY,
    SCIENCE_FICTION
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>ordinal()</code> возвращает порядковый номер определенной константы (нумерация начинается с <code>0</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">System.out.println(Type.BELLETRE.ordinal()); // 1</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_конструкторы_поля_и_методы_перечисления">Конструкторы, поля и методы перечисления</h3>
<div class="paragraph">
<p>Перечисления, как и обычные классы, могут определять конструкторы, поля и методы. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String[] args) {
        System.out.println(Color.RED.getCode()); // #FF0000
        System.out.println(Color.GREEN.getCode()); // #00FF00
    }
}

enum Color {
    RED("#FF0000"), BLUE("#0000FF"), GREEN("#00FF00");
    private String code;

    Color(String code) {
        this.code = code;
    }

    public String getCode() {
        return code;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Перечисление <code>Color</code> определяет приватное поле <code>code</code> для хранения кода цвета, а с помощью метода <code>getCode()</code> оно возвращается. Через конструктор передается для него значение. Следует отметить, что конструктор по умолчанию приватный, то есть имеет модификатор <code>private</code>. Любой другой модификатор будет считаться ошибкой. Поэтому создать константы перечисления с помощью конструктора мы можем только внутри перечисления.</p>
</div>
<div class="paragraph">
<p>Также можно определять методы для отдельных констант:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String[] args) {
        Operation op = Operation.SUM;
        System.out.println(op.action(10, 4)); // 14
        op = Operation.MULTIPLY;
        System.out.println(op.action(6, 4)); // 24
    }
}

enum Operation {
    SUM {
        public int action(int x, int y) {
            return x + y;
        }
    },
    SUBTRACT {
        public int action(int x, int y) {
            return x - y;
        }
    },
    MULTIPLY {
        public int action(int x, int y) {
            return x * y;
        }
    };

    public abstract int action(int x, int y);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_класс_object">Класс <code>Object</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Хотя мы можем создать обычный класс, который не является наследником, но фактически все классы наследуют от класса <code>Object</code>. Все остальные классы, даже те, которые мы добавляем в свой проект, являются неявно производными от класса <code>Object</code>. Поэтому все типы и классы могут реализовать те методы, которые определены в классе <code>Object</code>.</p>
</div>
<div class="sect2">
<h3 id="_hashcode"><code>hashCode()</code></h3>
<div class="sect3">
<h4 id="_что_такое_хеш_код">Что такое хеш-код?</h4>
<div class="paragraph">
<p>Если очень просто, то (<strong>хеш-код</strong>) — это число. Если более точно, то это <em>битовая строка фиксированной длины</em>, <em>полученная из массива произвольной длины</em>.</p>
</div>
<div class="paragraph">
<p>Выполним следующий код:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Main {
    public static void main(String[] args) {
        Object object = new Object();
        int hCode;
        hCode = object.hashCode();
        System.out.println(hCode);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В результате выполнения программы в консоль выведется целое 10-ти значное число. Это число и есть <em>битовая строка фиксированной длины</em>. В java она представлена в виде числа примитивного типа <code>int</code>, который равен 4-м байтам, и может помещать числа от <code>-2_147_483_648</code> до <code>2_147_483_647</code>. На данном этапе важно понимать, что <strong>хеш-код</strong> это число, у которого есть свой предел, который для java ограничен примитивным целочисленным типом <code>int</code>.</p>
</div>
<div class="paragraph">
<p>Вторая часть объяснения гласит: <em>полученная из массива произвольной длины</em>. Под массивом произвольной длины будет понимать объект. В примере выше в качестве массива произвольной длины выступает объект типа <code>Object</code>.</p>
</div>
<div class="paragraph">
<p>В итоге в терминах Java, <strong>хеш-код</strong> — это целочисленный результат работы метода, которому в качестве входного параметра передан объект.</p>
</div>
<div class="paragraph">
<p>Этот метод реализован таким образом, что для одного и того-же входного объекта, хеш-код всегда будет одинаковым. Следует понимать, что множество возможных хеш-кодов ограничено примитивным типом <code>int</code>, а множество объектов ограничено только нашей фантазией. Отсюда следует утверждение: <em>Множество объектов мощнее множества хеш-кодов</em>. Из-за этого ограничения, вполне возможна ситуация, что хеш-коды разных объектов могут совпасть.</p>
</div>
<div class="paragraph">
<p>Здесь главное понять, что:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Если хеш-коды разные, то и входные объекты гарантированно будут разные.</p>
</li>
<li>
<p>Если хеш-коды равны, то входные объекты не всегда равны.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ситуация, когда у разных объектов одинаковые хеш-коды называется — <strong>коллизией</strong>. <em>Вероятность возникновения коллизии</em> зависит от используемого <em>алгоритма генерации хеш-кода</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_hashcode_2"><code>hashCode()</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Person tom = new Person("Tom");
System.out.println(tom.hashCode()); // 2036368507</code></pre>
</div>
</div>
<div class="paragraph">
<p>Но мы можем задать свой алгоритм определения хэш-кода объекта:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    @Override
    public int hashCode(){
        return 11 * name.hashCode() + 7;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_подведём_итог">Подведём итог</h4>
<div class="paragraph">
<p><strong>Одинаковые объекты</strong> — это объекты одного класса с одинаковым содержимым полей.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Для одного и того-же объекта, хеш-код всегда будет одинаковым</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../assets/img/java/core/misc/class-object/hash-code-1.png" alt="Hash Code">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Если объекты одинаковые, то и хеш-коды будут одинаковые, но не наоборот.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../assets/img/java/core/misc/class-object/hash-code-2.png" alt="Hash Code">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Если хеш-коды равны, то входные объекты не всегда равны (коллизия).</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../assets/img/java/core/misc/class-object/hash-code-3.png" alt="Hash Code">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Если хеш-коды разные, то и объекты гарантированно будут разные.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../assets/img/java/core/misc/class-object/hash-code-4.png" alt="Hash Code">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_понятие_эквивалентности_метод_equals">Понятие эквивалентности. Метод equals()</h3>
<div class="paragraph">
<p>В java, каждый вызов оператора <code>new</code> порождает новый объект в памяти. Для иллюстрации создадим какой-нибудь класс, пускай он будет называться <code>BlackBox</code>.</p>
</div>
<div class="paragraph">
<p>Выполним следующий код:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class BlackBox {
    int varA;
    int varB;

    BlackBox(int varA, int varB){
        this.varA = varA;
        this.varB = varB;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Создадим класс для демонстрации <code>BlackBox</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class DemoBlackBox {
    public static void main(String[] args) {
        BlackBox object1 = new BlackBox(5, 10);
        BlackBox object2 = new BlackBox(5, 10);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом примере, в памяти создастся два объекта.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../assets/img/java/core/misc/class-object/equals.png" alt="Equals">
</div>
</div>
<div class="paragraph">
<p>Но, как вы уже обратили внимание, содержимое этих объектов одинаково, то есть эквивалентно. Для проверки эквивалентности в классе <code>Object</code> существует метод <code>equals()</code>, который сравнивает содержимое объектов и выводит значение типа <code>boolean</code> <code>true</code>, если содержимое эквивалентно, и <code>false</code> — если нет.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">object1.equals(object2); // должно быть true, поскольку содержимое объектов эквивалентно</code></pre>
</div>
</div>
<div class="paragraph">
<p>Эквивалентность и хеш-код тесно связанны между собой, поскольку хеш-код вычисляется на основании содержимого объекта (значения полей) и <em>если у двух объектов одного и того же класса содержимое одинаковое, то и хеш-коды должны быть одинаковые</em>.</p>
</div>
<div class="paragraph">
<p>Иными словами:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">object1.equals(object2); // должно быть true
object1.hashCode() == object2.hashCode(); // должно быть true</code></pre>
</div>
</div>
<div class="paragraph">
<p>"Должно быть", потому что если вы выполните предыдущий пример, то на самом деле результатом выполнения всех операций будет <code>false</code>. Для пояснения причин, заглянем в исходные коды класса <code>Object</code>.</p>
</div>
<div class="sect3">
<h4 id="_пример">Пример</h4>
<div class="paragraph">
<p>Метод <code>equals()</code> сравнивает два объекта на равенство:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String[] args) {
        Person tom = new Person("Tom");
        Person bob = new Person("Bob");
        System.out.println(tom.equals(bob)); // false

        Person tom2 = new Person("Tom");
        System.out.println(tom.equals(tom2)); // true
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Person) {
            Person p = (Person) obj;
            return (this.name == p.name);
        }
        return false;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>equals()</code> принимает в качестве параметр объект любого типа, который мы затем приводим к текущему, если они являются объектами одного класса.</p>
</div>
<div class="paragraph">
<p>Оператор <code>instanceof</code> позволяет выяснить, является ли переданный в качестве параметра объект объектом определенного класса, в данном случае класса <code>Person</code>.
Затем сравниваем по именам. Если они совпадают, возвращаем <code>true</code>, что будет говорить, что объекты равны.</p>
</div>
<div class="paragraph">
<p>Если объекты принадлежат к разным классам, то их сравнение не имеет смысла, и возвращается значение <code>false</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_класс_object_2">Класс <code>Object</code></h3>
<div class="paragraph">
<p>Как известно, все java-классы наследуются от класса <code>Object</code>. В этом классе уже определены методы <code>hashCode()</code> и <code>equals()</code>.</p>
</div>
<div class="paragraph">
<p>Определяя свой класс, вы автоматически наследуете все методы класса <code>Object</code>. И в ситуации, когда в вашем классе не переопределены (<strong>overriding</strong>) <code>hashCode()</code> и <code>equals()</code>, то используется их реализация из <code>Object</code>.</p>
</div>
<div class="paragraph">
<p>Рассмотрим исходный код метода <code>equals()</code> в классе <code>Object</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public boolean equals(Object obj) {
    return (this == obj);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>При сравнении объектов, операция <code>==</code> вернет <code>true</code> лишь в одном случае — когда ссылки указывают на один и тот-же объект. В данном случае не учитывается содержимое полей.</p>
</div>
<div class="paragraph">
<p>Выполнив приведённый ниже код, <code>equals()</code> вернет <code>true</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class DemoBlackBox {
    public static void main(String[] args) {
        BlackBox object3 = new BlackBox(5, 10);
        BlackBox object4 = object3; // Переменная object4 ссылается на
        // тот-же объект что и переменная object3
        object3.equals(object4); // true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь понято, почему <code>Object.equals()</code> работает не так как нужно, ведь он сравнивает ссылки, а не содержимое объектов.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../assets/img/java/core/misc/class-object/equals-objects.png" alt="Equals">
</div>
</div>
<div class="paragraph">
<p>Далее на очереди <code>hashCode()</code>, который тоже работает не так как полагается.</p>
</div>
<div class="paragraph">
<p>Заглянем в исходный код метода <code>hashCode()</code> в классе <code>Object</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public native int hashCode();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вот собственно и вся реализация. Ключевое слово <code>native</code> означает, что реализация данного метода выполнена на другом языке, например на C, C или *ассемблере*. Конкретный `native int hashCode()` реализован на C, вот исходники функции <a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/tip/src/share/vm/runtime/synchronizer.cpp"><code>get_next_hash</code></a>.</p>
</div>
<div class="paragraph">
<p>При вычислении хэш-кода для объектов класса <code>Object</code> по умолчанию используется <strong>Park-Miller RNG</strong> алгоритм. В основу работы данного алгоритма положен генератор случайных чисел. Это означает, что при каждом запуске программы у объекта будет разный хэш-код.</p>
</div>
<div class="paragraph">
<p>Получается, что используя реализацию метода <code>hashCode()</code> от класса <code>Object</code>, мы при каждом создании объекта класса new <code>BlackBox()</code>, будем получать разные хеш-коды. Мало того, перезапуская программу, мы будем получать абсолютно разные значения, поскольку это просто случайное число.</p>
</div>
<div class="paragraph">
<p>Но, как мы помним, должно выполняться правило: <em>если у двух объектов одного и того же класса содержимое одинаковое, то и хеш-коды должны быть одинаковые</em>. Поэтому, при создании пользовательского класса, принято переопределять методы <code>hashCode()</code> и <code>equals()</code> таким образом, что бы учитывались поля объекта.
Это можно сделать вручную либо воспользовавшись средствами генерации исходного кода в <strong>IDE</strong>. Например, в <strong>Eclipse</strong> это <em>Source</em> &#8594; <em>Generate hashCode() and equals()&#8230;&#8203;</em></p>
</div>
<div class="paragraph">
<p>В итоге класс <code>BlackBox</code> приобретает вид:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class BlackBox {
    int varA;
    int varB;

    BlackBox(int varA, int varB) {
        this.varA = varA;
        this.varB = varB;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + varA;
        result = prime * result + varB;
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        BlackBox other = (BlackBox) obj;
        if (varA != other.varA)
            return false;
        if (varB != other.varB)
            return false;
        return true;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь методы <code>hashCode()</code> и <code>equals()</code> работают корректно и учитывают содержимое полей объекта:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">object1.equals(object2); // true
object1.hashCode() == object2.hashCode(); // true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Поэтому создавая пользовательский класс, нужно переопределять методы <code>hashCode()</code> и <code>equals()</code>, что бы они корректно работали и учитывали данные объекта. Кроме того, если оставить реализацию из <code>Object</code>, то при использовании <code>java.util.HashMap</code> возникнут проблемы, поскольку <code>HashMap</code> активно используют <code>hashCode()</code> и <code>equals()</code> в своей работе.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tostring"><code>toString()</code></h3>
<div class="paragraph">
<p>Метод <code>toString()</code> служит для получения представления данного объекта в виде строки. При попытке вывести строковое представления какого-нибудь объекта, как правило, будет выводиться полное имя класса. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String[] args) {
        Person tom = new Person("Tom");
        System.out.println(tom.toString()); // Будет выводить что-то наподобие Person@7960847b
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Полученное мной значение (в данном случае <code>Person@7960847b</code>) вряд ли может служить хорошим строковым описанием объекта. Поэтому метод <code>toString()</code> нередко переопределяют. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String[] args) {
        Person tom = new Person("Tom");
        System.out.println(tom.toString()); // Person Tom
    }
}

class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Person " + name;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_getclass"><code>getClass()</code></h3>
<div class="paragraph">
<p>Метод <code>getClass()</code> позволяет получить тип данного объекта:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Person tom = new Person("Tom");
System.out.println(tom.getClass()); // class Person</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ссылочные_типы_и_клонирование_объектов">Ссылочные типы и клонирование объектов</h2>
<div class="sectionbody">
<div class="paragraph">
<p>При работе с объектами классов надо учитывать, что они все представляют ссылочные типы, то есть указывают на какой-то объект, расположенный в памяти. Чтобы понять возможные трудности, с которыми мы можем столкнуться, рассмотрим пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Program {
    public static void main(String[] args) {
        Person tom = new Person("Tom", 23);
        tom.display(); // Person Tom
        Person bob = tom;
        bob.setName("Bob");
        tom.display(); // Person Bob
    }
}

class Person {
    private String name;
    private int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void setName(String name) {
        this.name = name;
    }

    void setAge(int age) {
        this.age = age;
    }

    void display() {
        System.out.printf("Person Name: %s \n", name);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь создаем два объекта <code>Person</code> и один присваиваем другому. Но, несмотря на то, что мы изменяем только объект <code>bob</code>, вместе с ним изменяется и объект <code>tom</code>. Потому что после присвоения они указывают на одну и ту же область в памяти, где собственно данные об объекте <code>Person</code> и его полях и хранятся.</p>
</div>
<div class="paragraph">
<p>Чтобы избежать этой проблемы, необходимо создать отдельный объект для переменной <code>bob</code>, например, с помощью метода <code>clone</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person implements Cloneable {
    private String name;
    private int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void setName(String name) {
        this.name = name;
    }

    void setAge(int age) {
        this.age = age;
    }

    void display() {
        System.out.printf("Person %s \n", name);
    }

    public Person clone() throws CloneNotSupportedException {
        return (Person) super.clone();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для реализации клонирования класс <code>Person</code> должен применить интерфейс <code>Cloneable</code>, который определяет метод <code>clone()</code>. Реализация этого метода просто возвращает вызов метода <code>clone()</code> для родительского класса - то есть класса <code>Object</code> с преобразованием к типу <code>Person</code>.</p>
</div>
<div class="paragraph">
<p>Кроме того, на случай если класс не поддерживает клонирование, метод должен выбрасывать исключение <code>CloneNotSupportedException</code>, что определяется с помощью оператора <code>throws</code>.</p>
</div>
<div class="paragraph">
<p>Затем с помощью вызова этого метода мы можем осуществить копирование:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
    Person tom = new Person("Tom", 23);
    Person bob = tom.clone();
    bob.setName("Bob");
    tom.display(); // Person Tom
} catch (CloneNotSupportedException ex) {
    System.out.println("Clonable not implemented");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Однако данный способ осуществляет неполное копирование и подойдет, если клонируемый объект не содержит сложных объектов. Например, пусть класс <code>Book</code> имеет следующее определение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Book implements Cloneable {
    private String name;
    private Author author;

    public void setName(String n) {
        name = n;
    }

    public String getName() {
        return name;
    }

    public void setAuthor(String n) {
        author.setName(n);
    }

    public String getAuthor() {
        return author.getName();
    }

    Book(String name, String author) {
        this.name = name;
        this.author = new Author(author);
    }

    public String toString() {
        return "Книга '" + name + "' (автор " + author + ")";
    }

    public Book clone() throws CloneNotSupportedException {
        return (Book) super.clone();
    }
}

class Author {
    private String name;

    public void setName(String n) {
        name = n;
    }

    public String getName() {
        return name;
    }

    public Author(String name) {
        this.name = name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если мы попробуем изменить автора книги, нас последует неудача:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
    Book book = new Book("War and Peace", "Leo Tolstoy");
    Book book2 = book.clone();
    book2.setAuthor("Ivan Turgenev");
    System.out.println(book.getAuthor());
} catch (CloneNotSupportedException ex) {
    System.out.println("Cloneable not implemented");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом случае, хотя переменные <code>book</code> и <code>book2</code> будут указывать на разные объекты в памяти, но эти объекты при этом будут указывать на один объект <code>Author</code>.</p>
</div>
<div class="paragraph">
<p>И в этом случае нам необходимо выполнить полное копирование. Для этого, во-первых, надо определить метод клонирования у класса <code>Author</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Author implements Cloneable {
    // остальной код класса

    public Author clone() throws CloneNotSupportedException {
        return (Author) super.clone();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>И затем исправим метод <code>clone()</code> в классе <code>Book</code> следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public Book clone() throws CloneNotSupportedException {
    Book newBook = (Book) super.clone();
    newBook.author = (Author) author.clone();
    return newBook;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_wrapper_classes">Wrapper Classes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_wrapper_classes_2">Wrapper Classes</h3>
<div class="paragraph">
<p>Очень часто необходимо создать класс, основное назначение которого содержать в себе какое-то примитивное значение.
Например, как мы увидим в следующих занятиях, обобщенные классы и в частности коллекции работают только с объектами.
Поэтому, чтобы каждый разработчик не изобретал велосипед, в Java уже добавлены такие классы, которые называются <strong>Wrapper Classes</strong> (<strong>оболочки типов</strong>/<strong>классы обертки</strong>/<strong>wrappers</strong>).</p>
</div>
<div class="paragraph">
<p>К оболочкам типов относятся классы <code>Double</code>, <code>Float</code>, <code>Long</code>, <code>Integer</code>, <code>Short</code>, <code>Byte</code>, <code>Character</code>, <code>Boolean</code>, <code>Void</code>.
Для каждого примитивного значения и ключевого слова <code>void</code> есть свой класс-двойник.
Имя класса, как вы видите, совпадает с именем примитивного значения.
Исключения составляют класс <code>Integer</code> (примитивный тип <code>int</code>) и класс <code>Character</code> (примитивный тип <code>char</code>).
Кроме содержания в себе значения, классы оболочки предоставляют обширный ряд методов.</p>
</div>
<div class="paragraph">
<p>Объекты классов оболочек <strong>неизменяемые</strong> (<strong>immutable</strong>).
Это значит, что объект не может быть изменен.</p>
</div>
<div class="paragraph">
<p>Все классы-обертки числовых типов имеют переопределенный метод <code>equals(Object)</code>, сравнивающий примитивные значения объектов.</p>
</div>
<div class="sect3">
<h4 id="_конструкторы_оболочек">Конструкторы оболочек</h4>
<div class="paragraph">
<p>В следующей таблицы для каждого класса оболочки указан соответствующий примитивный тип и варианты конструкторов.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Примитивный тип</th>
<th class="tableblock halign-left valign-top">Оболочка</th>
<th class="tableblock halign-left valign-top">Аргументы конструктора</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code> or <code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>byte</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Byte</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>byte</code> or <code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>char</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Character</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>char</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>double</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Double</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>double</code> or <code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Float</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float</code>, double, or <code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Integer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code> or <code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>long</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Long</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>long</code> or <code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>short</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Short</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>short</code> or <code>String</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Как вы видите каждый класс имеет два конструктора, которые принимаю значения типа:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>соответствующего примитива</p>
</li>
<li>
<p><code>String</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Исключения: класс <code>Character</code>, у которого только один конструктор с аргументом <code>char</code> и класс <code>Float</code>, объявляющий три конструктора - для значения <code>float</code>, <code>String</code> и еще <code>double</code>.</p>
</div>
<div class="paragraph">
<p>Рассмотрим варианты вызова конструкторов на примере.
Чтобы создать объект класса <code>Integer</code>, передаем в конструктор либо значение типа <code>int</code> либо <code>String</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Integer i1 = new Integer(42);
Integer i2 = new Integer("42");

Float f1 = new Float(3.14f);
Float f2 = new Float("3.14f");

Character c1 = new Character('c');</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если передаваемая в конструктор строка не содержит числового значения, то выбросится исключение <code>NumberFormatException</code>.</p>
</div>
<div class="paragraph">
<p>При вызове конструктора с аргументом <code>String</code> класса <code>Boolean</code>, не обязательно передавать строки <code>true</code> или <code>false</code>.
Если аргумент содержит любую другую строку, просто будет создан объект, содержащий значение <code>false</code>.
Исключение выброшено не будет:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class WrapperDemo1 {
    public static void main(String[] args) {
        Boolean boolean1 = new Boolean(true);
        Boolean boolean2 = new Boolean("Some String");

        System.out.println(boolean2);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_методы_классов_оболочек">Методы классов оболочек</h4>
<div class="paragraph">
<p>Как уже было сказано, классы оболочки содержат обширный ряд методов.
Рассмотрим их.</p>
</div>
<div class="sect4">
<h5 id="_методы_valueof">Методы <code>valueOf()</code></h5>
<div class="paragraph">
<p>Метод <code>valueOf()</code> предоставляет второй способ создания объектов оболочек.
Метод перегруженный, для каждого класса существует два варианта - один принимает на вход значение соответствующего типа, а второй - значение типа <code>String</code>.
Так же как и с конструкторами, передаваемая строка должна содержать числовое значение.
Исключение составляет опять же класс <code>Character</code> - в нем объявлен только один метод, принимающий на вход значение <code>char</code>.</p>
</div>
<div class="paragraph">
<p>И в целочисленные классы <code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code> добавлен еще один метод, в который можно передать строку, содержащую число в любой системе исчисления.
Вторым параметром вы указываете саму систему исчисления.</p>
</div>
<div class="paragraph">
<p>В следующем примере показано использование всех трех вариантов для создания объектов класса <code>Integer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class WrapperValueOf {
    public static void main(String[] args) {
        Integer integer1 = Integer.valueOf("6");
        Integer integer2 = Integer.valueOf(6);
        // преобразовывает 101011 к 43
        Integer integer3 = Integer.valueOf("101011", 2);

        System.out.println(integer1);
        System.out.println(integer2);
        System.out.println(integer3);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_методы_parse">Методы <code>parse()</code></h5>
<div class="paragraph">
<p>В каждом классе оболочке содержатся методы, позволяющие преобразовывать строку в соответствующее примитивное значение.
В классе <code>Double</code> - это метод <code>parseDouble()</code>, в классе <code>Long</code> - <code>parseLong()</code> и так далее.
Разница с методом <code>valueOf()</code> состоит в том, что метод <code>valueOf()</code> возвращает объект, а <code>parse()</code> - примитивное значение.</p>
</div>
<div class="paragraph">
<p>Также в целочисленные классы <code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code> добавлен метод, в который можно передать строку, содержащую число в любой системе исчисления.
Вторым параметром вы указываете саму систему исчисления.
Следующий пример показывает использование метода <code>parseLong()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class WrapperDemo3 {
    public static void main(String[] args) {
        Long long1 = Long.valueOf("45");
        long long2 = Long.parseLong("67");
        long long3 = Long.parseLong("101010", 2);

        System.out.println("long1 = " + long1);
        System.out.println("long2 = " + long2);
        System.out.println("long3 = " + long3);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_методы_tostring">Методы <code>toString()</code></h5>
<div class="paragraph">
<p>Все типы-оболочки переопределяют <code>toString()</code>.
Этот метод возвращает читабельную для человека форму значения, содержащегося в оболочке.
Это позволяет выводить значение, передавая объект оболочки типа методу <code>println()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Double double1 = Double.valueOf("4.6");
System.out.println(double1);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Также все числовые оболочки типов предоставляют статический метод <code>toString()</code>, на вход которого передается примитивное значение.
Метод возвращает значение <code>String</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String string1 = Double.toString(3.14);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Integer</code> и <code>Long</code> предоставляют третий вариант <code>toString()</code> метода, позволяющий представить число в любой системе исчисления.
Он статический, первый аргумент – примитивный тип, второй - основание системы счисления:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String string2 = Long.toString(254, 16); // string2 = "fe"</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_методы_tohexstring_tooctalstring_tobinarystring">Методы <code>toHexString()</code>, <code>toOctalString()</code>, <code>toBinaryString()</code></h5>
<div class="paragraph">
<p><code>Integer</code> и <code>Long</code> позволяют преобразовывать числа из десятичной системы исчисления к шестнадцатеричной, восьмеричной и двоичной.
Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class WrapperToXString {
    public static void main(String[] args) {
        String string1 = Integer.toHexString(254);
        System.out.println("254 в 16-ой системе = " + string1);

        String string2 = Long.toOctalString(254);
        System.out.println("254 в  8-ой системе = " + string2);

        String string3 = Long.toBinaryString(254);
        System.out.println("254 в  2-ой системе = " + string3);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В классы <code>Double</code> и <code>Float</code> добавлен только метод <code>toHexString()</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_класс_number">Класс <code>Number</code></h4>
<div class="paragraph">
<p>Все оболочки числовых типов наследуют абстрактный класс <code>Number</code>. <code>Number</code> объявляет методы, которые возвращают значение объекта в каждом из различных числовых форматов.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../assets/img/java/core/misc/wrapper-classes/wrapper-classes.png" alt="Класс Number">
</div>
</div>
<div class="paragraph">
<p>Пример приведения типов</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class WrapperDemo2 {
    public static void main(String[] args) {
        Integer iOb = new Integer(1000);
        System.out.println(iOb.byteValue());
        System.out.println(iOb.shortValue());
        System.out.println(iOb.intValue());
        System.out.println(iOb.longValue());
        System.out.println(iOb.floatValue());
        System.out.println(iOb.doubleValue());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_статические_константы_классов_оболочек">Статические константы классов оболочек</h4>
<div class="paragraph">
<p>Каждый класс оболочка содержит статические константы, содержащие максимальное и минимальное значения для данного типа.</p>
</div>
<div class="paragraph">
<p>Например в классе <code>Integer</code> есть константы <code>Integer.MIN_VALUE</code> – минимальное <code>int</code> значение и <code>Integer.MAX_VALUE</code> – максимальное <code>int</code> значение.</p>
</div>
<div class="paragraph">
<p>Классы-обертки числовых типов <code>Float</code> и <code>Double</code>, помимо описанного для целочисленных примитивных типов, дополнительно содержат определения следующих констант:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NEGATIVE_INFINITY</code> – отрицательная бесконечность</p>
</li>
<li>
<p><code>POSITIVE_INFINITY</code> – положительная бесконечность</p>
</li>
<li>
<p><code>NaN</code> – не числовое значение (расшифровывается как <strong>Not a Number</strong>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Следующий пример демонстрирует использование трех последних переменных.
При делении на ноль возникает ошибка - на ноль делить нельзя.
Чтобы этого не происходило, и ввели переменные <code>NEGATIVE_INFINITY</code> и <code>POSITIVE_INFINITY</code>.
Результат умножения бесконечности на ноль - это значение <code>NaN</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class InfinityDemo {
    public static void main(String[] args) {
        int a = 7;
        double b = 0.0;
        double c = -0.0;
        double g = Double.NEGATIVE_INFINITY;
        System.out.println("7 / 0.0 = " + a / b);
        System.out.println("7 / -0.0 = " + a / c);
        System.out.println("0.0 == -0.0 = " + (b == c));
        System.out.println("-Infinity * 0 = " + g * 0);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Результат выполнения кода:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-out" data-lang="out">7 / 0.0 = Infinity
7 / -0.0 = -Infinity
0.0 == -0.0 =  true
-Infinity * 0 = NaN</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_autoboxing_and_unboxing">Autoboxing and unboxing</h3>
<div class="paragraph">
<p><strong>Autoboxing</strong> and <strong>unboxing</strong> (<strong>авто-упаковка</strong> и <strong>распаковка</strong>) — это процесс преобразования примитивных типов в объектные и наоборот.
Весь процесс выполняется автоматически средой выполнения Java (<strong>JRE</strong>).
Эта возможность доступна в Java версии 5 и выше.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class AutoBoxDemo1 {
    public static void main(String[] args) {
        Integer iOb = 100; // упаковать значение int
        int i = iOb; // распаковать
        System.out.println(i + " " + iOb);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Autoboxing</strong> происходит при прямом присвоении примитива классу-обертке (с помощью оператора <code>=</code>), либо при передаче примитива в параметры метода.</p>
</div>
<div class="paragraph">
<p><strong>Unboxing</strong> происходит при прямом присвоении классу-обертке примитива.</p>
</div>
<div class="paragraph">
<p>Компилятор использует метод <code>valueOf()</code> для упаковки, а методы <code>intValue()</code>, <code>doubleValue()</code> и так далее, для распаковки.</p>
</div>
<div class="paragraph">
<p><strong>Autoboxing</strong> в <strong>классы-обертки</strong> могут быть подвергнуты как переменные примитивных типов, так и литералы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Integer iOb1 = 100;
int i = 200;
Integer iOb2 = i;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Autoboxing</strong> переменных примитивных типов требует точного соответствия типа исходного примитива — типу <strong>класса-обертки</strong>.</p>
</div>
<div class="paragraph">
<p>Например, попытка <strong>autoboxing</strong> переменную типа <code>byte</code> в <code>Short</code>, без предварительного явного приведения <code>byte</code> в <code>short</code> вызовет ошибку компиляции:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">byte b = 4;
// Short s1 = b;
Short s2 = (short) b;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Автоупаковку можно использовать при вызове метода:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class AutoBoxAndMethods {
    static int someMethod(Integer value) {
        return value;
    }

    public static void main(String[] args) {
        Integer iOb = someMethod(100);
        System.out.println(iOb);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Внутри выражения числовой объект автоматически распаковывается.
Выходной результат выражения при необходимости упаковывается заново:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class AutoBoxAndOperations {
    public static void main(String[] args) {
        Integer iOb1, iOb2;
        int i;

        iOb1 = 100;

        iOb2 = iOb1 + iOb1 / 3;
        System.out.println("iOb2 после выражения: " + iOb2);

        i = iOb1 + iOb1 / 3;
        System.out.println("i после выражения: " + i);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>C появлением <strong>autoboxing</strong>/<strong>unboxing</strong> стало возможным применять объекты <code>Boolean</code> для управления в операторе <code>if</code> и других циклических конструкциях Java:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class AutoBoxAndCharacters {
    public static void main(String[] args) {
        Boolean b = true;

        if (b) {
            System.out.println("В if тоже можно использовать распаковку.");
        }

        Character ch = 'x';
        char ch2 = ch;

        System.out.println("ch2 = " + ch2);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>До Java 5 работа с классами обертками была более трудоемкой:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class AutoBoxDemo2 {
    public static void main(String[] args) {
        Integer y = new Integer(567);
        int x = y.intValue();
        x++;
        y = new Integer(x);
        System.out.println("y = " + y);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Перепишет тот же пример для работы с классами начиная с Java 5:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class AutoBoxDemo3 {
    public static void main(String[] args) {
        Integer y = new Integer(567);
        y++;
        System.out.println("y = " + y);
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_объекты_классов_оболочек_неизменяемые">Объекты классов оболочек неизменяемые</h4>
<div class="paragraph">
<p>Объекты классов оболочек <strong>неизменяемые</strong> (<strong>immutable</strong>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class AutoBoxImmutability {
    public static void main(String[] args) {
        Integer y = 567;
        Integer x = y;
        // проверяем, что x и y указывают на один объект
        System.out.println(y == x);

        y++;
        System.out.println(x + " " + y);
        // проверяем, что x и y указывают на один объект
        System.out.println(y == x);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Рассмотрим следующий пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Integer y = 567;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Переменная <code>y</code> указывает на объект в памяти:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../../assets/img/java/core/misc/wrapper-classes/immutable1.png" alt="Объекты классов оболочек неизменяемы"></span></p>
</div>
<div class="paragraph">
<p>Если мы попытаемся изменить <code>y</code>, у нас создастся еще один объект в памяти, на который теперь и будет указывать <code>y</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Integer y = 567;
y++;</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../../assets/img/java/core/misc/wrapper-classes/immutable2.png" alt="Объекты классов оболочек неизменяемы"></span></p>
</div>
</div>
<div class="sect3">
<h4 id="_кэширование_объектов_классов_оболочек">Кэширование объектов классов оболочек</h4>
<div class="paragraph">
<p>Метод <code>valueOf()</code> не всегда создает новый объект.
Он кэширует следующие значения:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Boolean</code>,</p>
</li>
<li>
<p><code>Byte</code>,</p>
</li>
<li>
<p><code>Character</code> от <code>\u0000</code> до <code>\u007f</code> (<code>7f</code> это <code>127</code>),</p>
</li>
<li>
<p><code>Short</code> и <code>Integer</code> от <code>-128</code> до <code>127</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если передаваемое значение выходит за эти пределы, то новый объект создается, а если нет, то нет.</p>
</div>
<div class="paragraph">
<p>Если мы пишем <code>new Integer()</code>, то гарантированно создается новый объект.</p>
</div>
<div class="paragraph">
<p>Рассмотрим это на следующем примере:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class AutoBoxDemoCaching {
    public static void main(String[] args) {
        Integer i1 = 23;
        Integer i2 = 23;
        System.out.println(i1 == i2);
        System.out.println(i1.equals(i2));

        Integer i3 = 2300;
        Integer i4 = 2300;
        System.out.println(i3 == i4);
        System.out.println(i3.equals(i4));
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_перегрузка_с_дополнительными_факторами">Перегрузка с дополнительными факторами</h3>
<div class="paragraph">
<p>Перегрузка методов усложняется при одновременном использовании следующих факторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>расширение</p>
</li>
<li>
<p>автоупаковка/распаковка</p>
</li>
<li>
<p>аргументы переменной длины</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_расширение_примитивных_типов">Расширение примитивных типов</h4>
<div class="paragraph">
<p>При расширение примитивных типов используется наименьший возможный вариант из всех методов.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class EasyOver {
    static void go(int x) {
        System.out.print("int ");
    }

    static void go(long x) {
        System.out.print("long ");
    }

    static void go(double x) {
        System.out.print("double ");
    }

    public static void main(String[] args) {
        byte b = 5;
        short s = 5;
        long l = 5;
        float f = 5.0f;
        go(b);
        go(s);
        go(l);
        go(f);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_расширение_и_boxing">Расширение и boxing</h4>
<div class="paragraph">
<p>Между расширением примитивных типов и boxing всегда выигрывает расширение.
Исторически это более старый вид преобразования.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class AddBoxing {
    public static void go(Integer x) {
        System.out.println("Integer");
    }

    public static void go(long x) {
        System.out.println("long");
    }

    public static void main(String[] args) {
        int i = 5;
        go(i); // какой go() вызовется?
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_упаковка_и_расширение">Упаковка и расширение</h4>
<div class="paragraph">
<p>Можно упаковать, а потом расширить.
Значение типа <code>int</code> может стать <code>Object</code>, через преобразование <code>Integer</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class BoxAndWiden {
    public static void go(Object o) {
        Byte b2 = (Byte) o;
        System.out.println(b2);
    }

    public static void main(String[] args) {
        byte b = 5;
        go(b); // можно ли преобразовать byte в Object?
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_расширение_и_упаковка">Расширение и упаковка</h4>
<div class="paragraph">
<p>Нельзя расширить и упаковать.
Значение типа <code>byte</code> не может стать <code>Long</code>.
Нельзя расширить от одного класса обертки к другой.
(<strong>IS-A</strong> не работает.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class WidenAndBox {
    static void go(Long x) {
        System.out.println("Long");
    }

    public static void main(String[] args) {
        byte b = 5;
        // go(b); // нужно расширить до long и упаковать, что невозможно
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_расширение_и_аргументы_переменной_длины">Расширение и аргументы переменной длины</h4>
<div class="paragraph">
<p>Между расширением примитивных типов и <strong>var-args</strong> всегда проигрывает <strong>var-args</strong>:</p>
</div>
<div class="paragraph">
<p>public class AddVarargs {
public static void go(int x, int y) {
System.out.println("int,int"); }</p>
</div>
<div class="literalblock">
<div class="content">
<pre>public static void go(byte... x) {
    System.out.println("byte... ");
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    public static void main(String[] args) {
        byte b = 5;
        go(b, b); // какой go() вызовется?
    }
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_упаковка_и_аргументы_переменной_длины">Упаковка и аргументы переменной длины</h4>
<div class="paragraph">
<p>Упаковка и <strong>var-args</strong> совместимы с перегрузкой методов.
<strong>Var-args</strong> всегда проигрывает:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class BoxOrVararg {
    public static void go(Byte x, Byte y) {
        System.out.println("Byte, Byte");
    }

    public static void go(byte... x) {
        System.out.println("byte... ");
    }

    public static void main(String[] args) {
        byte b = 5;
        go(b, b); // какой go() вызовется?
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_правила_перегрузки_методов_при_использовании_расширения_упаковки_и_аргументов_переменной_длины">Правила перегрузки методов при использовании расширения, упаковки и аргументов переменной длины</h4>
<div class="paragraph">
<p>Подытожим все правила:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>При расширение примитивных типов используется наименьший возможный вариант из всех методов.</p>
</li>
<li>
<p>Между расширением примитивных типов и упаковкой всегда выигрывает расширение.
Исторически это более старый вид преобразования.</p>
</li>
<li>
<p>Можно упаковать, а потом расширить.
(Значение типа <code>int</code> может стать <code>Object</code>, через преобразование <code>Integer</code>.)</p>
</li>
<li>
<p>Нельзя расширить и упаковать.
Значение типа <code>byte</code> не может стать <code>Long</code>.
Нельзя расширить от одного класса обертки к другой.
(<strong>IS-A</strong> не работает.)</p>
</li>
<li>
<p>Можно комбинировать <strong>var-args</strong> с расширением или упаковкой. <strong>var-args</strong> всегда проигрывает.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_введение_в_лямбда_выражения">Введение в лямбда-выражения</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_введение">Введение</h3>
<div class="paragraph">
<p>Среди новшеств, которые были привнесены в язык Java с выходом JDK 8, особняком стоят <strong>лямбда-выражения</strong>. Лямбда-выражение представляет набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.</p>
</div>
<div class="paragraph">
<p>Основу лямбда-выражения составляет <strong>лямбда-оператор</strong>, который представляет стрелку <strong>&#8594;</strong>. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит <strong>список параметров выражения</strong>, а правая собственно представляет <strong>тело лямбда-выражения</strong>, где выполняются все действия.</p>
</div>
<div class="paragraph">
<p>Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.</p>
</div>
<div class="paragraph">
<p>Рассмотрим пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class LambdaApp {
    public static void main(String[] args) {
        Operationable operation;
        operation = (x, y) -&gt; x + y;

        int result = operation.calculate(10, 20);
        System.out.println(result); //30
    }
}

interface Operationable {
    int calculate(int x, int y);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В роли функционального интерфейса выступает интерфейс <code>Operationable</code>, в котором определен один метод без реализации - метод <code>calculate</code>. Данный метод принимает два параметра - целых числа, и возвращает некоторое целое число.</p>
</div>
<div class="paragraph">
<p>По факту <strong>лямбда-выражения являются</strong> в некотором роде <strong>сокращенной формой внутренних анонимных классов</strong>, которые ранее применялись в Java. В частности, предыдущий пример мы можем переписать следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class LambdaApp {
    public static void main(String[] args) {
        Operationable op = new Operationable() {
            public int calculate(int x, int y) {
                return x + y;
            }
        };
        int z = op.calculate(20, 10);
        System.out.println(z); // 30
    }
}

interface Operationable {
    int calculate(int x, int y);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы объявить и использовать лямбда-выражение, основная программа разбивается на ряд этапов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Определение ссылки на функциональный интерфейс:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Operationable operation;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Создание лямбда-выражения:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">operation = (x, y) -&gt; x + y;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Использование лямбда-выражения в виде вызова метода интерфейса:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int result = operation.calculate(10, 20);</code></pre>
</div>
</div>
<div class="paragraph">
<p>На втором этапе параметры лямбда-выражения соответствуют параметрам единственного метода интерфейса <code>Operationable</code>, а результат соответствует возвращаемому результату метода интерфейса. При этом нам не надо использовать ключевое слово <code>return</code> для возврата результата из лямбда-выражения.</p>
</div>
<div class="paragraph">
<p>Так, в методе интерфейса оба параметра представляют тип <code>int</code>, значит, в теле лямбда-выражения мы можем применить к ним сложение. Результат сложения также представляет тип <code>int</code>, объект которого возвращается методом интерфейса.</p>
</div>
<div class="paragraph">
<p>На третьем этапе результатом будет сумма чисел <code>10</code> и <code>20</code>, так как в лямбда-выражении определена операция сложения параметров.</p>
</div>
<div class="paragraph">
<p>При этом для одного функционального интерфейса мы можем определить множество лямбда-выражений. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Operationable operation1 = (int x, int y)-&gt; x + y;
Operationable operation2 = (int x, int y)-&gt; x - y;
Operationable operation3 = (int x, int y)-&gt; x * y;

System.out.println(operation1.calculate(20, 10)); //30
System.out.println(operation2.calculate(20, 10)); //10
System.out.println(operation3.calculate(20, 10)); //200</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_отложенное_выполнение">Отложенное выполнение</h3>
<div class="paragraph">
<p>Одним из ключевых моментов в использовании лямбд является <strong>отложенное выполнение</strong> (<strong>deferred execution</strong>). То есть мы определяем в одном месте программы лямбда-выражение и затем можем его вызывать при необходимости неопределенное количество раз в различных частях программы. Отложенное выполнение может потребоваться, к примеру, в следующих случаях:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>выполнение кода отдельном потоке</p>
</li>
<li>
<p>выполнение одного и того же кода несколько раз</p>
</li>
<li>
<p>выполнение кода в результате какого-то события</p>
</li>
<li>
<p>выполнение кода только в том случае, когда он действительно необходим и если он необходим</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_передача_параметров_в_лямбда_выражение">Передача параметров в лямбда-выражение</h4>
<div class="paragraph">
<p>Параметры лямбда-выражения должны соответствовать по тип параметрам метода из функционального интерфейса. При написании самого лямбда-выражения тип параметров писать необязательно, хотя в принципе это можно сделать, например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">operation = (int x, int y) -&gt; x + y;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если метод не принимает никаких параметров, то пишутся пустые скобки, например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">() -&gt; 30 + 20;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если метод принимает только один параметр, то скобки можно опустить:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">n -&gt; n * n;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_терминальные_лямбда_выражения">Терминальные лямбда-выражения</h3>
<div class="paragraph">
<p>Выше рассмотрены лямбда-выражения, которые возвращают определенное значение. Но также могут быть и <strong>терминальные лямбды</strong>, которые не возвращают никакого значения. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface Printable {
    void print(String s);
}

public class LambdaApp {
    public static void main(String[] args) {
        Printable printer = s -&gt; System.out.println(s);
        printer.print("Hello Java!");
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_лямбды_и_локальные_переменные">Лямбды и локальные переменные</h3>
<div class="paragraph">
<p>Лямбда-выражение может использовать переменные, которые объявлены во вне в более общей области видимости - на уровне класса или метода, в котором лямбда-выражение определено. Однако в зависимости от того, как и где определены переменные, могут различаться способы их использования в лямбдах. Рассмотрим первый пример - использования переменных уровня класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class LambdaApp {
    static int x = 10;
    static int y = 20;

    public static void main(String[] args) {
        Operation op = () -&gt; {
            x = 30;
            return x + y;
        };
        System.out.println(op.calculate()); // 50
        System.out.println(x); // 30 - значение x изменилось
    }
}

interface Operation {
    int calculate();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Переменные <code>x</code> и <code>y</code> объявлены на уровне класса, и в лямбда-выражении мы их может получить и даже изменить. Так, в данном случае после выполнения выражения изменяется значение переменной <code>x</code>.</p>
</div>
<div class="paragraph">
<p>Теперь рассмотрим другой пример - локальные переменные на уровне метода:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    int n = 70;
    int m = 30;
    Operation op = () -&gt; {
        // n = 100; - так нельзя сделать
        return m + n;
    };
    // n = 100;  - так тоже нельзя
    System.out.println(op.calculate()); // 100
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Локальные переменные уровня метода мы также может использовать в лямбдах, но изменять их значение мы уже не сможем. Если мы попробуем это сделать, то среда разработки может нам высветить ошибку и то, что такую переменную надо пометить с помощью ключевого слова <code>final</code>, то есть сделать константой: <code>final int n = 70;</code>. Однако это необязательно.</p>
</div>
<div class="paragraph">
<p>Более того, мы не сможем изменить значение переменной, которая используется в лямбда-выражении, вне этого выражения. То есть даже если такая переменная не объявлена как константа, по сути она является константой.</p>
</div>
</div>
<div class="sect2">
<h3 id="_блоки_кода_в_лямбда_выражениях">Блоки кода в лямбда-выражениях</h3>
<div class="paragraph">
<p>Существуют два типа лямбда-выражений:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>однострочное выражение</p>
</li>
<li>
<p>блок кода</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Примеры однострочных выражений демонстрировались выше. Блочные выражения обрамляются фигурными скобками. В блочных лямбда-выражениях можно использовать внутренние вложенные блоки, циклы, конструкции <code>if</code>, <code>switch</code>, создавать переменные и т.д. Если блочное лямбда-выражение должно возвращать значение, то явным образом применяется оператор <code>return</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Operationable operation = (int x, int y) -&gt; {
    if(y == 0)
        return 0;
    else
        return x / y;
};

System.out.println(operation.calculate(20, 10)); //2
System.out.println(operation.calculate(20, 0)); //0</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_обобщенный_функциональный_интерфейс">Обобщенный функциональный интерфейс</h3>
<div class="paragraph">
<p>Функциональный интерфейс может быть обобщенным, однако в лямбда-выражении использование обобщений не допускается. В этом случае нам надо типизировать объект интерфейса определенным типом, который потом будет применяться в лямбда-выражении. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class LambdaApp {
    public static void main(String[] args) {
        Operationable&lt;Integer&gt; operation1 = (x, y) -&gt; x + y;
        Operationable&lt;String&gt; operation2 = (x, y) -&gt; x + y;

        System.out.println(operation1.calculate(20, 10)); //30
        System.out.println(operation2.calculate("20", "10")); //2010
    }
}

interface Operationable&lt;T&gt; {
    T calculate(T x, T y);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Таким образом, при объявлении лямбд-выражения ему уже известно, какой тип параметры будут представлять и какой тип они будут возвращать.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_лямбды_как_параметры_и_результаты_методов">Лямбды как параметры и результаты методов</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_лямбды_как_параметры_методов">Лямбды как параметры методов</h3>
<div class="paragraph">
<p>Одним из преимуществ лямбд в java является то, что их можно передавать в качестве параметров в методы. Рассмотрим пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class LambdaApp {
    public static void main(String[] args) {
        Expression func = (n) -&gt; n % 2 == 0;
        int[] nums = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        System.out.println(sum(nums, func)); // 20
    }

    private static int sum(int[] numbers, Expression func) {
        int result = 0;
        for (int i : numbers) {
            if (func.isEqual(i))
                result += i;
        }
        return result;
    }
}

interface Expression {
    boolean isEqual(int n);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функциональный интерфейс <code>Expression</code> определяет метод <code>isEqual()</code>, который возвращает <code>true</code>, если в отношении числа <code>n</code> действует какое-нибудь равенство.</p>
</div>
<div class="paragraph">
<p>В основном классе программы определяется метод <code>sum()</code>, который вычисляет сумму всех элементов массива, соответствующих некоторому условию. А само условие передается через параметр <code>Expression func</code>. Причем на момент написания метода <code>sum</code> мы можем абсолютно не знать, какое именно условие будет использоваться. Само же условие определяется в виде лямбда-выражения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Expression func = (n) -&gt; n % 2 == 0;</code></pre>
</div>
</div>
<div class="paragraph">
<p>То есть в данном случае все числа должны быть четными или остаток от их деления на <code>2</code> должен быть равен <code>0</code>. Затем это лямбда-выражение передается в вызов метода <code>sum</code>.</p>
</div>
<div class="paragraph">
<p>При этом можно не определять переменную интерфейса, а сразу передать в метод лямбда-выражение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
int x = sum(nums, (n)-&gt; n &gt; 5); // сумма чисел, которые больше 5
System.out.println(x);  // 30</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ссылки_на_метод_как_параметры_методов">Ссылки на метод как параметры методов</h3>
<div class="paragraph">
<p>Начиная с JDK 8 в Java можно в качестве параметра в метод передавать ссылку на другой метод. В принципе данный способ аналогичен передаче в метод лямбда-выражения.</p>
</div>
<div class="paragraph">
<p>Ссылка на метод передается в виде <code>имя_класса::имя_статического_метода</code> (если метод статический) или <code>объект_класса::имя_метода</code> (если метод нестатический). Рассмотрим на примере:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface Expression {
    boolean isEqual(int n);
}

class ExpressionHelper {
    static boolean isEven(int n) {
        return n % 2 == 0;
    }

    static boolean isPositive(int n) {
        return n &gt; 0;
    }
}

public class LambdaApp {
    public static void main(String[] args) {
        int[] nums = {-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5};
        System.out.println(sum(nums, ExpressionHelper::isEven));

        Expression expr = ExpressionHelper::isPositive;
        System.out.println(sum(nums, expr));
    }

    private static int sum(int[] numbers, Expression func) {
        int result = 0;
        for (int i : numbers) {
            if (func.isEqual(i))
                result += i;
        }
        return result;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь также определен функциональный интерфейс <code>Expression</code>, который имеет один метод. Кроме того, определен класс <code>ExpressionHelper</code>, который содержит два статических метода. В принципе их можно было определить и в основном классе программы, но я вынес их в отдельный класс.</p>
</div>
<div class="paragraph">
<p>В основном классе программы <code>LambdaApp</code> определен метод <code>sum()</code>, который возвращает сумму элементов массива, соответствующих некоторому условию. Условие передается в виде объекта функционального интерфейса <code>Expression</code>.</p>
</div>
<div class="paragraph">
<p>В методе <code>main</code> два раза вызываем метод <code>sum</code>, передавая в него один и тот же массив чисел, но разные условия. Первый вызов метода <code>sum</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">System.out.println(sum(nums, ExpressionHelper::isEven));</code></pre>
</div>
</div>
<div class="paragraph">
<p>На место второго параметра передается <code>ExpressionHelper::isEven</code>, то есть ссылка на статический метод <code>isEven()</code> класса <code>ExpressionHelper</code>. При этом методы, на которые идет ссылка, должны совпадать по параметрам и результату с методом функционального интерфейса.</p>
</div>
<div class="paragraph">
<p>При втором вызове метода <code>sum</code> отдельно создается объект <code>Expression</code>, который затем передается в метод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Expression expr = ExpressionHelper::isPositive;
System.out.println(sum(nums, expr));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Использование ссылок на методы в качестве параметром аналогично использованию лямбда-выражений.</p>
</div>
<div class="paragraph">
<p>Если нам надо вызвать нестатические методы, то в ссылке вместо имени класса применяется имя объекта этого класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface Expression {
    boolean isEqual(int n);
}

class ExpressionHelper {
    boolean isEven(int n) {
        return n % 2 == 0;
    }
}

public class LambdaApp {
    public static void main(String[] args) {
        int[] nums = {-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5};
        ExpressionHelper exprHelper = new ExpressionHelper();
        System.out.println(sum(nums, exprHelper::isEven)); // 0
    }

    private static int sum(int[] numbers, Expression func) {
        int result = 0;
        for (int i : numbers) {
            if (func.isEqual(i))
                result += i;
        }
        return result;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ссылки_на_конструкторы">Ссылки на конструкторы</h3>
<div class="paragraph">
<p>Подобным образом мы можем использовать конструкторы: <code>название_класса::new</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class LambdaApp {
    public static void main(String[] args) {
        UserBuilder userBuilder = User::new;
        User user = userBuilder.create("Tom");
        System.out.println(user.getName());
    }
}

interface UserBuilder {
    User create(String name);
}

class User {
    private String name;

    String getName() {
        return name;
    }

    User(String n) {
        this.name = n;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>При использовании конструкторов методы функциональных интерфейсов должны принимать тот же список параметров, что и конструкторы класса, и должны возвращать объект данного класса.</p>
</div>
</div>
<div class="sect2">
<h3 id="_лямбды_как_результат_методов">Лямбды как результат методов</h3>
<div class="paragraph">
<p>Также метод в Java может возвращать лямбда-выражение. Рассмотрим следующий пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface Operation {
    int execute(int x, int y);
}

public class LambdaApp {
    public static void main(String[] args) {
        Operation func = action(1);
        int a = func.execute(6, 5);
        System.out.println(a); // 11

        int b = action(2).execute(8, 2);
        System.out.println(b); // 6
    }

    private static Operation action(int number) {
        switch (number) {
            case 1:
                return (x, y) -&gt; x + y;
            case 2:
                return (x, y) -&gt; x - y;
            case 3:
                return (x, y) -&gt; x * y;
            default:
                return (x, y) -&gt; 0;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае определен функциональный интерфейс <code>Operation</code>, в котором метод <code>execute</code> принимает два значения типа <code>int</code> и возвращает значение типа <code>int</code>.</p>
</div>
<div class="paragraph">
<p>Метод <code>action</code> принимает в качестве параметра число и в зависимости от его значения возвращает то или иное лямбда-выражение. Оно может представлять либо сложение, либо вычитание, либо умножение, либо просто возвращает <code>0</code>. Стоит учитывать, что формально возвращаемым типом метода <code>action</code> является интерфейс <code>Operation</code>, а возвращаемое лямбда-выражение соответствует этому интерфейсу.</p>
</div>
<div class="paragraph">
<p>В методе <code>main</code> мы можем вызвать этот метод <code>action</code>. Например, сначала получить его результат - лямбда-выражение, которое присваивается переменной <code>Operation</code>. А затем через метод <code>execute</code> выполнить это лямбда-выражение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Operation func = action(1);
int a = func.execute(6, 5);
System.out.println(a); // 11</code></pre>
</div>
</div>
<div class="paragraph">
<p>Либо можно сразу получить и тут же выполнить лямбда-выражение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int b = action(2).execute(8, 2);
System.out.println(b); // 6</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_аннотации">Аннотации</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Аннотации</strong> представляют собой некую мета-информацию. Они не выполняют какого-либо действия сами по себе, но они могут предоставлять дополнительную информацию, которая может быть использована компилятором, различными утилитами сборки и генерации кода, а также они могут обрабатываться во время выполнения программы.</p>
</div>
<div class="paragraph">
<p>Аннотации предваряются символом <code>@</code>. Пример часто используемой аннотации <code>@Override</code>, которая указывает компилятору, что этот метод переопределяет базовый метод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Override
public void someMethod() {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Аннотации могут иметь элементы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SuppressWarnings(value = "unchecked")
public void method() {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если элементов много, то они разделяются запятой, если элемент только один, и его имя <code>value</code>, то его название можно не указывать:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SuppressWarnings("unchecked")
void myMethod() {
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_объявление_аннотаций">Объявление аннотаций</h3>
<div class="paragraph">
<p>Предположим, что при объявлении каждого нового класса необходимо записывать в комментариях информацию об авторах в таком виде:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Goblin {
    // author : John Clark
    // sprites : Izabella Simpson
    // sound : Michael Lermontov
    // code : Pushkin A.
    // createdAt : 2016-03-30
    // description : Goblin is lurking creature.
    // comments :

    // ... code
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Можно записывать эту информацию с помощью аннотаций. Для этого вам сперва нужно объявить эту аннотацию:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@interface Monstr {
    String author();
    String sprites();
    String sound();
    String code();
    String createdAt() default "0000-00-00";
    String description();

    // Example of array use
    String[] comments();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь можно применить его к нашему классу <code>Goblin</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Monstr(
    author="John Clark",
    sprites = "Izabella Simpson",
    sound = "Michael Lermontov",
    code = "Pushkin A.",
    createdAt = "2016-03-30",
    description = "Goblin is lurking creature",
    comments = {"lol", "gg", "Аффтар жжёт"}
)
class Goblin {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание на запись элементов аннотации (<code>author</code>, <code>sprites</code>, <code>sound</code>) и на запись массива элементов с использованием фигурных скобок (<code>comments</code>).</p>
</div>
<div class="paragraph">
<p>Можно использовать предопределённую аннотацию <code>@Documented</code>, чтобы наша аннотация попадала в документацию, сгенерированную утилитой <strong>JavaDoc</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.lang.annotation.Documented;

@Documented
@interface Monstr {
    String author();
    String sprites();
    String sound();
    String code();
    String createdAt() default "0000-00-00";
    String description();

    // Example of array use
    String[] comments();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_предопределённые_аннотации">Предопределённые аннотации</h3>
<div class="sect3">
<h4 id="_deprecated"><code>@Deprecated</code></h4>
<div class="paragraph">
<p><code>@Deprecated</code> указывает, что элемент устарел и не должен использоваться. Компилятор Java генерирует предупреждение, если вы используете класс, метод или поле, помеченные аннотацией <code>@Deprecated</code>. Устаревший элемент должен быть также помечен тегом <strong>JavaDoc</strong> <code>@deprecated</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">/*
 * @deprecated
 * explanation of why it was deprecated
 */
 @Deprecated
 static void deprecatedMethod() { }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_override"><code>@Override</code></h4>
<div class="paragraph">
<p><code>@Override</code> указывает, что метод переопределяет метод базового класса. Эту аннотацию использовать не обязательно, но рекомендуется.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Override
public int myMethod(double x) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если метод с <code>@Override</code> не может корректно переопределить метод базового класса, то компилятор генерирует ошибку.</p>
</div>
</div>
<div class="sect3">
<h4 id="_suppresswarnings"><code>@SuppressWarnings</code></h4>
<div class="paragraph">
<p><code>@SuppressWarnings</code> подавляет предупреждения. Пример подавления предупреждения об устаревшем методе:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Указываем компиляторе не генерировать
// предупреждение о использовании
// устаревшего метода.
@SuppressWarnings("deprecation")
void useDeprecatedMethod() {
    // Используем устаревший метод.
    objectOne.deprecatedMethod();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Каждое предупреждение принадлежит какой-либо категории. В спецификации Java описано две категории. В <code>@SupressWarnings</code> можно указывать несколько категорий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SuppressWarnings({"unchecked", "deprecation"})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Различные реализации компиляторов и различные IDE могут добавлять свои категории предупреждений. Неподдерживаемые названия категорий пропускаются при использовании <code>@SuppressWarnings</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_safevarargs"><code>@SafeVarargs</code></h4>
<div class="paragraph">
<p><code>@SafeVarargs</code> применяется к методу или конструктору и указывает, что код не осуществляет потенциально опасных операций со своим <code>varargs</code>-параметром (параметр, принимающий произвольное число параметров).</p>
</div>
</div>
<div class="sect3">
<h4 id="_functionalinterface"><code>@FunctionalInterface</code></h4>
<div class="paragraph">
<p><code>@FunctionalInterface</code> указывает, что это объявление типа будет функциональным интерфейсом Java 8.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_мета_аннотации">Мета-аннотации</h3>
<div class="paragraph">
<p>Аннотации, применяемые к другим аннотациям, называются <strong>мета-аннотациями</strong>. Есть несколько мета-аннотаций в пакете <code>java.lang.annotation</code>:</p>
</div>
<div class="sect3">
<h4 id="_retention"><code>@Retention</code></h4>
<div class="paragraph">
<p><code>@Retention</code> определяет, как аннотация будет сохранена:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RetentionPolicy.SOURCE</code> - аннотация будет только в исходном коде, и она будет игнорироваться компилятором.</p>
</li>
<li>
<p><code>RetentionPolicy.CLASS</code> - аннотация будет доступна компилятору, но но будет игнорироваться виртуальной машиной Java.</p>
</li>
<li>
<p><code>RetentionPolicy.RUNTIME</code> - аннотация будет сохраняться JVM и будет доступна во время выполнения.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_documented"><code>@Documented</code></h4>
<div class="paragraph">
<p><code>@Documented</code> - указывает, что элементы, помеченные этой аннотацией, должны документироваться JavaDoc. По умолчанию аннотации не включаются в документацию.</p>
</div>
</div>
<div class="sect3">
<h4 id="_target"><code>@Target</code></h4>
<div class="paragraph">
<p><code>@Target</code> - указывает какие элементы можно помечать этой аннотацией:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ElementType.ANNOTATION_TYPE</code> - данная аннотация может быть применена к другой аннотации.</p>
</li>
<li>
<p><code>ElementType.CONSTRUCTOR</code> - может быть применена к конструктору.</p>
</li>
<li>
<p><code>ElementType.FIELD</code> - может быть применена к полю.</p>
</li>
<li>
<p><code>ElementType.LOCAL_VARIABLE</code> - может быть применена к локальной переменной.</p>
</li>
<li>
<p><code>ElementType.METHOD</code> - может быть применена к методу.</p>
</li>
<li>
<p><code>ElementType.PACKAGE</code> - может быть применена к пакету.</p>
</li>
<li>
<p><code>ElementType.PARAMETER</code> - может быть применена к параметрам метода.</p>
</li>
<li>
<p><code>ElementType.TYPE</code> - может быть применена классу, интерфейсу, аннотации или перечислению.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_inherited"><code>@Inherited</code></h4>
<div class="paragraph">
<p><code>@Inherited</code> — аннотация может быть унаследована от базового класса (по умолчанию не наследуются). Когда запрашивается аннотация класса, и у класса нет такой аннотации, то запрашивается аннотация базового класса. Эта аннотация может быть применена только к классам.</p>
</div>
</div>
<div class="sect3">
<h4 id="_repeatable"><code>@Repeatable</code></h4>
<div class="paragraph">
<p><code>@Repeatable</code> - аннотация может быть применена несколько раз.</p>
</div>
<div class="paragraph">
<p>Допустим мы хотим применить аннотацию <code>@Author</code> несколько раз для указания нескольких авторов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Author("Petya")
@Author("Vasya")
@Author("Suslik")
class Goblin {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тогда необходимо объявить такую аннотацию следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.lang.annotation.Repeatable;

@Repeatable(Authors.class)
@interface Author {
    String value();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание, что добавлена аннотация <code>@Repeatable</code> с указанием <code>Authors.class</code>, который мы должны объявить как аннотацию с массивом аннотация <code>Author</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@interface Authors{
    Author[] value();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь можно указывать аннотацию <code>@Author</code> столько раз, сколько необходимо, для любого класса.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reflection">Reflection</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Рефлексия</strong> (от reflexio - обращение назад) - это механизм исследования данных о программе во время её выполнения. Рефлексия в Java осуществляется с помощью <strong>Java Reflection API</strong>, состоящий из классов пакетов <code>java.lang</code> и <code>java.lang.reflect</code>. В информатике рефлексия означает процесс, во время которого программа может отслеживать и модифицировать собственную структуру и поведение во время выполнения.</p>
</div>
<div class="paragraph">
<p><strong>Java Reflection API</strong> позволяет получать информацию о конструкторах, методах и полях классов и выполнять следующие операции над полями и методами объекта/класса:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>определение класса объекта</p>
</li>
<li>
<p>получение информации о полях, методах, конструкторах и суперклассах</p>
</li>
<li>
<p>получение информации о модификаторах полей и методов</p>
</li>
<li>
<p>создание экземпляра класса, имя которого неизвестно до момента выполнения программы</p>
</li>
<li>
<p>определение и изменение значений свойств объекта/класса</p>
</li>
<li>
<p>вызов методов объекта/класса</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>В исходном коде используется объект/класс. При работе с объектом (реализацией класса) можно обращаться к полям и методам класса напрямую, если они доступны (не private). При работе с классом можно обращаться к методам класса с использованием Java Reflection API. Но класс необходимо получить из объекта.</p>
</div>
</blockquote>
</div>
<div class="sect2">
<h3 id="_определение_свойств_класса">Определение свойств класса</h3>
<div class="paragraph">
<p>В работающем приложении для получения класса необходимо использовать метод <code>forName(String className)</code>. Следующий код демонстрирует возможность создания класса без использования и с использованием Reflection :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Без использования Reflection
Foo foo = new Foo();

// С использованием Reflection
Class foo = Class.forName("Foo");

// Загрузка JDBC-драйвера
Class.forName("com.mysql.jdbc.Driver");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод класса <code>forName(className)</code> часто используется для загрузки JDBC-драйвера.</p>
</div>
<div class="paragraph">
<p>Методом <code>getName()</code> объекта <code>Class</code> можно получить наименование класса, включающего пакет (<code>package</code>) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Class aclass = foo.getClass();
System.out.println (aclass.getName());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для получения значения модификатора класса используется метод <code>getModifiers()</code>. Класс <code>java.lang.reflect.Modifier</code> содержит статические методы, возвращающие логическое значения проверки модификатора класса :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Class cls = foo.getClass();
int mods = cls.getModifiers();
if (Modifier.isPublic(mods)) {
    System.out.println("public");
}
if (Modifier.isAbstract(mods)) {
    System.out.println("abstract");
}
if (Modifier.isFinal(mods))    {
    System.out.println("final");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для получения суперкласса рефлексированного объекта (класса) необходимо использовать метод <code>getSuperclass()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Class cls = foo.getClass();
Class superCls = cls.getSuperClass();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Поскольку в Java отсутствует множественное наследование, то для получения всех предков следует рекурсивно вызвать метод <code>getSuperclass()</code> в цикле, пока не будет достигнут <code>Object</code>, являющийся родителем всех классов. <code>Object</code> не имеет родителей, поэтому вызов его метода <code>getSuperclass()</code> вернет <code>null</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_определение_интерфейсов_и_конструкторов_класса">Определение интерфейсов и конструкторов класса</h3>
<div class="paragraph">
<p>Для получения в режиме <strong>runtime</strong> списка реализующих классом интерфейсов, необходимо получить <code>Class</code> и использовать его метод <code>getInterfaces()</code>. В следующем примере извлекается список интерфейсов класса <code>ArrayList</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Class&lt;?&gt;   cls = ArrayList.class;
Class&lt;?&gt;[] ifs = cls.getInterfaces();

System.out.println("List of interfaces\n");
for(Class&lt;?&gt; ifc : ifs) {
    System.out.println (ifc.getName());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы IDE не предупреждала о необходимости определения типа класса</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Class is a raw type. References to generic type Class&lt;T&gt; should be parameterized</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>в коде были использованы <strong>generic</strong>. В консоль выводятся следующие интерфейсы, реализуемые классом <code>ArrayList</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-out" data-lang="out">List of interfaces

java.util.List
java.util.RandomAccess
java.lang.Cloneable
java.io.Serializable</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод класса <code>getConstructors()</code> позволяет получить массив открытых конструкторов типа <code>java.lang.reflect.Constructor</code>. После этого, можно извлекать информацию о типах параметров конструктора и генерируемых исключениях:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Class&lt;?&gt; cls = obj.getClass();
Constructor[] constructors = cls.getConstructors();
for (Constructor constructor : constructors) {
    Class&lt;?&gt;[] params = constructor.getParameterTypes();
    for (Class&lt;?&gt; param : params) {
        System.out.println(param.getName());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_определение_полей_класса">Определение полей класса</h3>
<div class="paragraph">
<p>Метод <code>getFields()</code> объекта <code>Class</code> возвращает массив открытых полей типа <code>java.lang.reflect.Field</code>, которые могут быть определены не только в данном классе, но также и в его родителях (суперклассе), либо интерфейсах, реализованных классом или его родителями. Класс <code>Field</code> позволяет получить имя поля, тип и модификаторы :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Class&lt;?&gt; cls = obj.getClass();
Field[] fields = cls.getFields();
for (Field field : fields) {
    Class&lt;?&gt; fld = field.getType();
    System.out.println("Class name : " + field.getName());
    System.out.println("Class type : " + fld.getName());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если известно наименование поля, то можно получить о нем информацию с помощью метода <code>getField()</code> объекта <code>Class</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Class&lt;?&gt; cls = obj.getClass();
Field fld = cls.getField("fieldName");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Методы <code>getField()</code> и <code>getFields()</code> возвращают только открытые члены данных класса. Чтобы получить все поля класса, включая закрытые и защищенные, необходимо использовать методы <code>getDeclaredField()</code> и <code>getDeclaredFields()</code>. Данные методы работают точно так же, как и их аналоги <code>getField()</code> и <code>getFields()</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_определение_значений_полей_класса">Определение значений полей класса</h3>
<div class="paragraph">
<p>Класс <code>Field</code> содержит специализированные методы для получения значений примитивных типов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getInt()</code></p>
</li>
<li>
<p><code>getFloat()</code></p>
</li>
<li>
<p><code>getByte()</code></p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Для установки значения поля, используется метод <code>set()</code>. Для примитивных типов имеются методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>setInt()</code></p>
</li>
<li>
<p><code>setFloat()</code></p>
</li>
<li>
<p><code>setByte()</code></p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Class&lt;?&gt; cls = obj.getClass();
Field field = cls.getField("fieldName");

String value = (String) field.get(obj);
field.set(obj, "New value");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ниже приведен пример изменения значения закрытого поля класса в runtime.</p>
</div>
</div>
<div class="sect2">
<h3 id="_определение_методов_класса">Определение методов класса</h3>
<div class="paragraph">
<p>Метод <code>getMethods()</code> объекта <code>Class</code> возвращает массив открытых методов типа <code>java.lang.reflect.Method</code>. Эти методы могут быть определены не только в классе, но также и в его родителях (суперклассе), либо интерфейсах, реализованных классом или его родителями. Класс <code>Method</code> позволяет получить имя метода, тип возвращаемого им значения, типы параметров метода, модификаторы и генерируемые исключения.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Class&lt;?&gt; cls = obj.getClass();
Method[] methods = cls.getMethods();
for (Method method : methods) {
    System.out.println("Method name : " + method.getName());
    System.out.println("Return type : " + method.getReturnType().getName());

    Class&lt;?&gt;[] params = method.getParameterTypes();
    System.out.print("Parameters : ");
    for (Class&lt;?&gt; paramType : params) {
        System.out.print(" " + paramType.getName());
    }
    System.out.println();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если известно имя метода и типы его параметров, то можно получить отдельный метод класса :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Class&lt;?&gt; cls = obj.getClass();
Class[] params = new Class[] {Integer.class, String.class};

Method method = cls.getMethod("methodName", params);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_пример_изменения_значения_закрытого_поля_класса">Пример изменения значения закрытого поля класса</h3>
<div class="paragraph">
<p>Чтобы изменить значение закрытого (<code>private</code>) поля класса необходимо получить это поле методом <code>getDeclaredField()</code> и вызвать метод <code>setAccessible(true)</code> объекта <code>Field</code>, чтобы открыть доступ к полю. После этого значение закрытого поля можно изменять, если оно не <code>final</code>. В следующем примере определен внутренний класс <code>PrivateFinalFields</code> с набором закрытых полей; одно из полей <code>final</code>. При создании объекта класса поля инициализируются. В методе <code>main()</code> примера поочередно в закрытые поля вносятся изменения и свойства объекта выводятся в консоль.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.lang.reflect.Field;

class PrivateFinalFields {
    private final String s  = "String S";
    private int i  = 1;
    private String s2 = "String S2";

    public String toString() {
        return "i = " + i + ", " + s + ", " + s2;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class ModifyngPrivateFields {
    public static void main(String[] args) throws Exception {
        PrivateFinalFields pf = new PrivateFinalFields();

        Field f = pf.getClass().getDeclaredField("i");
        f.setAccessible(true);
        f.setInt(pf, 47);
        System.out.println("1. " + pf);

        f = pf.getClass().getDeclaredField("s");
        f.setAccessible(true);
        f.set(pf, "MODIFY S");
        System.out.println("2. " + pf);

        f = pf.getClass().getDeclaredField("s2");
        f.setAccessible(true);
        f.set(pf, "MODIFY S2");

        f = pf.getClass().getDeclaredField("i");
        f.setAccessible(true);
        f.setInt(pf, 35);
        System.out.println("3. " + pf);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В результате выполнения примера в консоль будут выведены следующие сообщения :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-out" data-lang="out">1. i = 47, String S, String S2
2. i = 47, String S, String S2
3. i = 35, String S, MODIFY S2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Из приведённого примера видно что поля <code>private</code> можно изменять. Для этого необходимо получить объект типа <code>java.lang.reflect.Field</code> с помощью метода <code>getDeclaredField()</code>, вызвать его метод <code>setAccessible(true)</code> и с помощью метода <code>set()</code> установить требуемое значение поля. Необходимо иметь в виду, что наличие модификатора <code>final</code> в закрытом текстовом поле не вызывает исключений при изменении значений, а само значение поля остаётся прежним, т.е. <code>final</code> поля остаются неизменные. Если не вызвать метод открытия доступа к полю <code>setAccessible(true)</code>, то будет вызвано исключение <code>java.lang.IllegalAccessException</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_пример_вызова_метода_invoke">Пример вызова метода <code>invoke()</code></h3>
<div class="paragraph">
<p><strong>Java Reflection Api</strong> позволяет вызвать метод класса. Рассмотрим пример, в котором определим класс <code>Reflect</code>, включающий поля и методы управления ими. В runtime с помощью метода данного класса будем изменять значения полей и распечатывать их.</p>
</div>
<div class="paragraph">
<p>Класс <code>Reflect</code> включает два закрытых поля <code>id</code>, <code>name</code> и методы управления их значениями <strong>set/get</strong>. Дополнительно в класс включим метод <code>setData()</code>, который будем вызывать для изменения значений полей, и метод <code>toString()</code> для печати их значений.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Reflect {
    private String name;
    private int id;

    Reflect() {
        this.name = "Test";
        this.id = 999;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setData(final int id, String name) {
        this.id   = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Reflect [ id : " + id + ", name : " + name + "]";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для тестирования объекта типа <code>Reflect</code> с помощью <strong>Java Reflection Api</strong> создадим класс <code>ReflectionTest</code>. В этот класс включим два метода <code>getClassFields()</code> и <code>getClassMethods()</code>, которые в <strong>runtime</strong> распечатают всю информацию (описание полей и методов) о классе. Методы получают класс в качестве параметра. В процедурах сначала определяются массивы полей и методы; после этого их параметры распечатываются :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private void getClassFields(Class&lt;?&gt; cls) {
    Field[] fields = cls.getDeclaredFields();
    System.out.println("Class fields");
    for (Field field : fields) {
        Class&lt;?&gt; fld = field.getType();
        System.out.println("Class name : " + field.getName());
        System.out.println("Class type : " + fld.getName());
    }
}

private void getClassMethods(Class&lt;?&gt; cls) {
    Method[] methods = cls.getDeclaredMethods();
    System.out.println("Class methods");
    for (Method method : methods) {
        System.out.println("Method name : " + method.getName());
        System.out.println("Return type : " + method.getReturnType().getName());
        Class&lt;?&gt;[] params = method.getParameterTypes();
        System.out.print("Parameters : ");
        for (Class&lt;?&gt; param : params) {
            System.out.print(" " + param.getName());
        }
        System.out.println();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В конструкторе класса <code>ReflectionTest</code> сначала вызываются процедуры определения полей и методов объекта/класса <code>Reflect</code>. После этого вызываются методы изменения значений и печати значений с использованием <strong>Reflection API</strong>. Для определения метода <code>setData()</code> используется массив типов параметров. Вызов метода <code>setData()</code> выполняется с передачей ему массива новых значений.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class ReflectionTest {
    static Reflect reflect;

    public ReflectionTest() {
        getClassFields(reflect.getClass());
        getClassMethods(reflect.getClass());

        Class&lt;?&gt; cls = reflect.getClass();
        try {
            System.out.println("\n1. invoke method toString()\n");

            Method method = cls.getMethod("toString");
            System.out.println(method.invoke(reflect));

            Class&lt;?&gt;[] paramTypes;
            Object  [] args;

            paramTypes = new Class[] {int.class, String.class};
            method = cls.getMethod("setData", paramTypes);

            args = new Object[]{(int)123,new String("New value")};
            method.invoke(reflect, args);

            System.out.println("\n2. invoke method toString()\n");
            method = cls.getMethod("toString");
            System.out.println(method.invoke(reflect));

        } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
            System.out.println(e);
        }
    }

    private void getClassFields(Class&lt;?&gt; cls) {
        Field[] fields = cls.getDeclaredFields();
        System.out.println("Class fields");
        for (Field field : fields) {
            Class&lt;?&gt; fld = field.getType();
            System.out.println("Class name : " + field.getName());
            System.out.println("Class type : " + fld.getName());
        }
    }

    private void getClassMethods(Class&lt;?&gt; cls) {
        Method[] methods = cls.getDeclaredMethods();
        System.out.println("Class methods");
        for (Method method : methods) {
            System.out.println("Method name : " + method.getName());
            System.out.println("Return type : " + method.getReturnType().getName());
            Class&lt;?&gt;[] params = method.getParameterTypes();
            System.out.print("Parameters : ");
            for (Class&lt;?&gt; param : params) {
                System.out.print(" " + param.getName());
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        this.reflect = new Reflect();
        new ReflectionTest();
        System.exit(0);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В результате выполнения примера в консоль будут выведены представленные ниже сообщения. Методы <code>setData()</code> и <code>toString()</code>, вызываемые с помощью <strong>Java Reflection API</strong>, вносят измнения в закрытые поля класса и распечатываются их значения.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-out" data-lang="out">Class fields

Class name : name
Class type : java.lang.String
Class name : id
Class type : int

Class methods

Method name : toString
Return type : java.lang.String
Parameters  :

Method name : getId
Return type : int
Parameters  :

Method name : setId
Return type : void
Parameters :  int

Method name : getName
Return type : java.lang.String
Parameters  :

Method name : setName
Return type : void
Parameters :  java.lang.String

Method name : setData
Return type : void
Parameters :  int java.lang.String

1. invoke method toString()

Reflect [ id : 999, name : Test]

2. invoke method toString()

Reflect [ id : 123, name : New value]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_properties">Properties</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Класс <code>Properties</code> – это подкласс <code>Hashtable</code>.
Он используется для хранения списков значений, в которых ключ является <code>String</code>, а значение также является <code>String</code>.</p>
</div>
<div class="paragraph">
<p>Класс <code>Properties</code> в Java используется множеством других классов.
Например, это тип объекта, возвращаемый <code>System.getProperties()</code>, когда тот получает внешние значения.</p>
</div>
<div class="paragraph">
<p><code>Properties</code> определяет следующие переменную экземпляра.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Properties defaults;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Эта переменная содержит список свойств по умолчанию, связанный с объектом <code>Properties</code>.</p>
</div>
<div class="sect2">
<h3 id="_конструкторы">Конструкторы</h3>
<div class="paragraph">
<p>Вот список конструкторов, предоставляемые классом <code>Properties</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Properties()</code> конструктор создает объект <code>Properties</code>, который не имеет значений по умолчанию.</p>
</li>
<li>
<p><code>Properties(Properties propDefault)</code> создаёт объект, который использует propDefault для своих значений по умолчанию.
В обоих случаях список свойств пустой.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_методы">Методы</h3>
<div class="paragraph">
<p>Помимо методов, определённых <code>Hashtable</code>, <code>Properties</code> определяет следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String getProperty(String key)</code> возвращает значение, связанное с ключом.
Возвращается нулевой объект, если ключ не находится ни в списке, ни в списке свойств по умолчанию.</p>
</li>
<li>
<p><code>String getProperty(String key, String defaultProperty)</code> возвращает значение, связанное с ключом; Возвращается <code>defaultProperty</code>, если ключ не находится ни в списке, ни в списке свойств по умолчанию.</p>
</li>
<li>
<p><code>void list(PrintStream streamOut)</code> отправляет список свойств в выходной поток, связанный с <code>streamOut</code>.</p>
</li>
<li>
<p><code>void list(PrintWriter streamOut)</code> отправляет список свойств в выходной поток, связанный с <code>streamOut</code>.</p>
</li>
<li>
<p><code>void load(InputStream streamIn) throws IOException</code> вводит список свойств из входного потока, связанного с <code>streamIn</code>.</p>
</li>
<li>
<p><code>Enumeration propertyNames()</code> возвращает перечисление ключей, включая ключи, найденные в списке свойств по умолчанию.</p>
</li>
<li>
<p><code>Object setProperty(String key, String value)</code> связывает значение с ключом.
Возвращает предыдущее значение, связанное с ключом, или возвращает <code>null</code>, если такой связи не существует.</p>
</li>
<li>
<p><code>void store(OutputStream streamOut, String description)</code> после записи строки, указанной в описании, список свойств записывается в выходной поток, связанный с <code>streamOut</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_примеры">Примеры</h3>
<div class="sect3">
<h4 id="_пример_системные_свойства">Пример: системные свойства</h4>
<div class="paragraph">
<p>Получим и выведем все системные свойства:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.Map;
import java.util.Properties;
import java.util.Set;

/**
 * Java program to demonstrate Properties class to get all the system properties
 */
public class PropertiesExample2GetSystemProperties {
    /**
     * Main method for Demo
     *
     * @param args input arguments
     */
    public static void main(String[] args) {
        // get all the system properties
        Properties p = System.getProperties();

        // stores set of properties information
        Set&lt;Map.Entry&lt;Object, Object&gt;&gt; set = p.entrySet();

        // iterate over the set
        for (Map.Entry&lt;Object, Object&gt; entry : set) {
            // print each property
            System.out.printf("%s=%s\n", entry.getKey(), entry.getValue());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Будет выведено следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>java.specification.version=15
sun.management.compiler=HotSpot 64-Bit Tiered Compilers
sun.jnu.encoding=UTF-8
java.runtime.version=15.0.1+9
java.class.path=/home/rakovets/dev/course-java-basics/build/classes/java/main:/home/rakovets/dev/course-java-basics/build/resources/main
user.name=rakovets
java.vm.vendor=AdoptOpenJDK
path.separator=:
sun.arch.data.model=64
os.version=5.8.0-34-generic
user.variant=
java.runtime.name=OpenJDK Runtime Environment
file.encoding=UTF-8
java.vendor.url=https://adoptopenjdk.net/
java.vm.name=OpenJDK 64-Bit Server VM
java.vm.specification.version=15
os.name=Linux
java.vendor.version=AdoptOpenJDK
user.country=US
sun.java.launcher=SUN_STANDARD
sun.boot.library.path=/home/rakovets/.sdkman/candidates/java/15.0.1.hs-adpt/lib
sun.java.command=com.rakovets.course.javabasics.example.properties.PropertiesExample2GetSystemProperties
java.vendor.url.bug=https://github.com/AdoptOpenJDK/openjdk-support/issues
java.io.tmpdir=/tmp
jdk.debug=release
sun.cpu.endian=little
java.version=15.0.1
user.home=/home/rakovets
user.dir=/home/rakovets/dev/course-java-basics
user.language=en
os.arch=amd64
java.specification.vendor=Oracle Corporation
java.vm.specification.name=Java Virtual Machine Specification
java.version.date=2020-10-20
java.home=/home/rakovets/.sdkman/candidates/java/15.0.1.hs-adpt
file.separator=/
java.vm.compressedOopsMode=Zero based
line.separator=

java.library.path=/usr/java/packages/lib:/usr/lib64:/lib64:/lib:/usr/lib
java.vm.info=mixed mode, sharing
java.vm.specification.vendor=Oracle Corporation
java.specification.name=Java Platform API Specification
java.vendor=AdoptOpenJDK
java.vm.version=15.0.1+9
sun.io.unicode.encoding=UnicodeLittle
java.class.version=59.0</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_пример_чтение_свойств_из_файла">Пример: чтение свойств из файла</h4>
<div class="paragraph">
<p>Файл <code>account.properties</code> содержит следующий списком свойств:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-properties" data-lang="properties">username=rakovets
password=Fc9S42SMEfJbNVtM</code></pre>
</div>
</div>
<div class="paragraph">
<p>Прочитаем его и выведем все свойства:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;

/**
 * Java program to demonstrate Properties class to get information from the properties file
 */
public class PropertiesExample1 {
    /**
     * Main method for Demo
     *
     * @param args input arguments
     * @throws IOException throw IOException when work with IO
     */
    public static void main(String[] args) throws IOException {
        // get path for user.properties
        Path userPropertiesPath =
                Paths.get("src", "main", "resources", "example", "properties", "account.properties");

        // create a reader object on the properties file
        FileReader reader = new FileReader(userPropertiesPath.toFile());

        // create properties object
        Properties p = new Properties();

        // Add a wrapper around reader object
        p.load(reader);

        // access properties data
        System.out.printf("Username: '%s'\n", p.getProperty("username"));
        System.out.printf("Password: '%s'\n", p.getProperty("password"));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Будет выведено следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Username: 'rakovets'
Password: 'Fc9S42SMEfJbNVtM'</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_пример_записи_свойств_в_файл">Пример: записи свойств в файл</h4>
<div class="paragraph">
<p>Создадим свойства и запишем их в файл <code>user.properties</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;

/**
 * Java program to demonstrate Properties class to create the properties file
 */
public class PropertiesExample3CreateAndWriteToFile {
    /**
     * Main method for Demo
     *
     * @param args input arguments
     * @throws IOException throw IOException when work with IO
     */
    public static void main(String[] args) throws IOException {
        // create an instance of Properties
        Properties p = new Properties();

        // add properties to it
        p.setProperty("name", "Dmitry Rakovets");
        p.setProperty("email", "dmitryrakovets@gmail.com");

        // get path for account.properties
        Path userPropertiesPath =
                Paths.get("src", "main", "resources", "example", "properties", "user.properties");

        // store the properties to a file
        p.store(new FileWriter(userPropertiesPath.toFile()), "Properties Example");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Создастся файл <code>user.properties</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-properties" data-lang="properties">#Properties Example
#Fri Jan 08 10:05:19 MSK 2021
name=Dmitry Rakovets
email=dmitryrakovets@gmail.com</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_javadoc">Javadoc</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Наибольшая проблема, связанная с документированием кода – поддержка этой документации. Если документация и код разделены, возникают трудности, связанные с необходимостью внесения изменений в соответствующие разделы сопроводительной документации всякий раз при изменении программного кода. Среда разработки предлагает решение – связать код с документацией, поместив всё в один файл.</p>
</div>
<div class="paragraph">
<p><strong>Javadoc</strong> — генератор документации в HTML-формате из комментариев исходного кода на Java.</p>
</div>
<div class="paragraph">
<p>Комментарии документации применяют для документирования:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>классов</p>
</li>
<li>
<p>интерфейсов</p>
</li>
<li>
<p>полей (переменных)</p>
</li>
<li>
<p>конструкторов</p>
</li>
<li>
<p>методов</p>
</li>
<li>
<p>пакетов</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В каждом случае комментарий должен находиться перед документируемым элементом.</p>
</div>
<div class="paragraph">
<p>Утилита <strong>javadoc</strong> позволяет вставлять HTML тэги и использовать специальные ярлыки, <strong>дескрипторы</strong> (<strong>descriptor</strong>),  документирования.</p>
</div>
<div class="paragraph">
<p>НТМL тэги заголовков не используют, чтобы не нарушать стиль файла, сформированного утилитой.</p>
</div>
<div class="paragraph">
<p><strong>Дескрипторы javadoc</strong>, начинающиеся со знака <code>@,</code> называются автономными и должны помещаться с начала строки комментария (лидирующий символ <code>*</code> игнорируется).</p>
</div>
<div class="paragraph">
<p>Дескрипторы, начинающиеся с фигурной скобки, например <code>{@code}</code>, называются встроенными и могут применяться внутри описания.</p>
</div>
<div class="sect2">
<h3 id="_список_дескрипторов_javadoc">Список дескрипторов Javadoc</h3>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Дескриптор</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Описание</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Применим к</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@author</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Автор</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">класс, интерфейс</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@version</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Версия (Не более одного дескриптора на класс)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">класс, интерфейс</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@since</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Указывает, с какой версии доступно</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">класс, интерфейс, поле, метод</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@see</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ссылка на другое место в документации</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">класс, интерфейс, поле, метод</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@param</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Входной параметр метода</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">метод</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@return</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Описание возвращаемого значения</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">метод</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@deprecated</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Описание устаревших блоков кода</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">класс, интерфейс, поле, метод</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{@link reference}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ссылка</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">класс, интерфейс, поле, метод</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{@value}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Описание значения переменной</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">статичное поле</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_генерация_файлов">Генерация файлов</h3>
<div class="paragraph">
<p>Утилита <strong>javadoc</strong> в качестве входных данных принимает файл с исходным кодом программы. Генерирует несколько НТМL файлов, содержащих документацию по этой программе. Информация о каждом классе будет содержаться в отдельном НТМL файле. Кроме того, создается дерево индексов и иерархии. Могут быть сгенерированы и другие НТМL файлы.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_java_nio">Java NIO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java NIO (New IO) - это альтернативный API для работы с IO в Java (начиная с Java 1.4), это значит альтернативный стандартным Java IO и API Java Networking. Java NIO предлагает другой способ работы с IO, чем стандартный IO API.</p>
</div>
<div class="paragraph">
<p><strong>Java NIO: channels и buffers</strong></p>
</div>
<div class="paragraph">
<p>В стандартном IO API работают с потоками байт и потоками символов. В NIO работают с каналами и буферами. Данные всегда читаются из канала в буфер или записываются из буфера в канал.</p>
</div>
<div class="paragraph">
<p><strong>Java NIO: non-bloking IO</strong></p>
</div>
<div class="paragraph">
<p>Java NIO позволяет выполнять неблокирующие операции ввода-вывода. Например, поток может попросить канал прочитать данные в буфер. Пока канал читает данные в буфер, поток может делать что-то другое. Как только данные будут считаны в буфер, поток сможет продолжить их обработку. Аналогично и для записи данных в каналы.</p>
</div>
<div class="paragraph">
<p><strong>Java NIO: selectors</strong></p>
</div>
<div class="paragraph">
<p>Java NIO имеет понятие «селекторы». <strong>Селектор</strong> - это объект, который может отслеживать несколько каналов на наличие событий (например: соединение установлено, данные получены и т.д.). Таким образом, один поток может контролировать несколько каналов данных.</p>
</div>
<div class="sect2">
<h3 id="_обзор_java_nio">Обзор Java NIO</h3>
<div class="paragraph">
<p><strong>Java NIO</strong> состоит из следующих основных компонентов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>каналы</p>
</li>
<li>
<p>буферы</p>
</li>
<li>
<p>селекторы</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Java NIO имеет не только эти компоненты, но фактически, <code>Channel</code>, <code>Buffer</code> и <code>Selector</code> являются ключевыми классами. Остальные компоненты, такие как <code>Pipe</code> и <code>FileLock</code> являются просто служебными классами, которые используются вместе с тремя основными компонентами.</p>
</div>
<div class="sect3">
<h4 id="_каналы_и_буферы">Каналы и Буферы</h4>
<div class="paragraph">
<p>Как правило, все операции ввода-вывода в NIO начинаются с <code>Channel</code>. <code>Channel</code> немного похож на <code>Stream</code>. Из <code>Channel</code> данные можно прочитать в <code>Buffer</code>. Данные также могут быть записаны из <code>Buffer</code> в <code>Channel</code>. :</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/assets/img/java/core/nio/channels-buffers.png" alt="Java NIO: каналы и буферы"></span></p>
</div>
<div class="paragraph">
<p>Есть несколько <code>Channel</code> и <code>Buffer</code> типов. Ниже приведен список основных реализаций <code>Channel</code> в Java NIO:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FileChannel</code></p>
</li>
<li>
<p><code>DatagramChannel</code></p>
</li>
<li>
<p><code>SocketChannel</code></p>
</li>
<li>
<p><code>ServerSocketChannel</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Эти каналы охватывают сетевой ввод-вывод по протоколам <strong>UDP</strong> и <strong>TCP</strong> и файловый ввод-вывод.</p>
</div>
<div class="paragraph">
<p>А вот список основных реализаций <code>Buffer</code> в Java NIO:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ByteBuffer</code></p>
</li>
<li>
<p><code>CharBuffer</code></p>
</li>
<li>
<p><code>DoubleBuffer</code></p>
</li>
<li>
<p><code>FloatBuffer</code></p>
</li>
<li>
<p><code>IntBuffer</code></p>
</li>
<li>
<p><code>LongBuffer</code></p>
</li>
<li>
<p><code>ShortBuffer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Они <code>Buffer</code> охватывают основные типы данных, которые вы можете отправлять через IO:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>char</code></p>
</li>
<li>
<p><code>byte</code></p>
</li>
<li>
<p><code>short</code></p>
</li>
<li>
<p><code>int</code></p>
</li>
<li>
<p><code>long</code></p>
</li>
<li>
<p><code>float</code></p>
</li>
<li>
<p><code>double</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Java NIO также имеет, <code>MappedByteBuffer</code> который используется для работы с отображением файлов в оперативной памяти.</p>
</div>
</div>
<div class="sect3">
<h4 id="_селекторы">Селекторы</h4>
<div class="paragraph">
<p><code>Selector</code> позволяет одному потоку обрабатывать несколько <code>Channel</code>. Это удобно, если в вашем приложении открыто много соединений (каналов), но каждое соединении имеет небольшой трафик. Например: сервер для чата.</p>
</div>
<div class="paragraph">
<p>Ниже приведенно изображение, того как <code>Thread</code> использует <code>Selector</code> для обработки 3 <code>Channel</code>:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/assets/img/java/core/nio/selectors.png" alt="Java NIO: селекторы"></span></p>
</div>
<div class="paragraph">
<p>Чтобы использовать, <code>Selector</code> необходимо зарегистрировать <code>Channel</code> с ним. Для этого используеют вызов метода <code>select()</code>. Этот метод будет заблокирован, пока не произойдет событие для одного из зарегистрированных каналов. Как только метод разблокируется, поток может обработать события. Примерами событий являются: входящее соединение, полученные данные и т.д.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_channel"><code>Channel</code></h3>
<div class="paragraph">
<p>Каналы Java NIO похожи на потоки с некоторыми отличиями:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>можно читать/писать из/в каналы, а потоки обычно односторонние (чтение/запись)</p>
</li>
<li>
<p>каналы могут быть прочитаны/записаны асинхронно</p>
</li>
<li>
<p>каналы всегда читают/записывают из/в буфер</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_реализация_channel">Реализация <code>Channel</code></h4>
<div class="paragraph">
<p>Вот наиболее важные реализации <code>Channel</code> в Java NIO:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FileChannel</code> - считывает данные из/в файла</p>
</li>
<li>
<p><code>DatagramChannel</code> - считывает/записывает данные по сети через <strong>UDP</strong></p>
</li>
<li>
<p><code>SocketChannel</code> - считывает/записывает данные по сети через <strong>TCP</strong></p>
</li>
<li>
<p><code>ServerSocketChannel</code> - прослушивает входящие соединения <strong>TCP</strong>, как это делает web-server, т.е. для каждого входящего соединения создается <code>SocketChannel</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_пример_основного_канала">Пример основного канала</h4>
<div class="paragraph">
<p>Вот базовый пример, в котором используется <code>FileChannel</code> для чтения некоторых данных в <code>Buffer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw");
FileChannel inChannel = aFile.getChannel();

ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf);
while (bytesRead != -1) {
    System.out.println("Read " + bytesRead);
    buf.flip();

    while(buf.hasRemaining()) {
        System.out.print((char) buf.get());
    }

    buf.clear();
    bytesRead = inChannel.read(buf);
}
aFile.close();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание на вызов <code>buf.flip()</code>. Сначала из канала считывают в буфер. Затем буфер переворачивают. После чего считывают из буффера.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_buffers">Buffers</h3>
<div class="paragraph">
<p>Буферы используются при взаимодействии с каналами.</p>
</div>
<div class="paragraph">
<p>Буфер - это, по сути, блок памяти, в который можно записывать данные, которые затем можно снова прочитать. Этот блок памяти обернут в объект <code>Buffer</code>, который предоставляет набор методов, облегчающих работу с блоком памяти.</p>
</div>
<div class="sect3">
<h4 id="_основное_использование_буфера">Основное использование буфера</h4>
<div class="paragraph">
<p>Использование <code>Buffer</code> для чтения и записи данных обычно состоит из четырех шагов:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Записать данные в буфер</p>
</li>
<li>
<p>Вызов метода <code>buffer.flip()</code></p>
</li>
<li>
<p>Чтение данных из буфера</p>
</li>
<li>
<p>Вызов одного из методов <code>buffer.clear()</code> или <code>buffer.compact()</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Когда данные записывают в буфер, буфер отслеживает, сколько данных записано. Когда нужно прочитать данные, тогда нужно переключить буфер из режима записи в режим чтения с помощью вызова метода <code>flip()</code>. В режиме чтения буфер позволяет читать все данные, записанные в буфер.</p>
</div>
<div class="paragraph">
<p>После того, как все данные были прочитаны, необходимо очистить буфер, чтобы он снова был готов к записи. Это можно сделать вызвав один из двух методов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>clear()</code> - метод очищает весь буфер</p>
</li>
<li>
<p><code>compact()</code> - метод удаляет только те данные, которые уже прочитали. Любые непрочитанные данные перемещаются в начало буфера, и теперь новые данные будут записываться в буфер после непрочитанных данных</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw");
FileChannel inChannel = aFile.getChannel();

//create buffer with capacity of 48 bytes
ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf); //read into buffer.
while (bytesRead != -1) {
    buf.flip();  //make buffer ready for read

    while(buf.hasRemaining()){
        System.out.print((char) buf.get()); // read 1 byte at a time
    }

    buf.clear(); //make buffer ready for writing
    bytesRead = inChannel.read(buf);
}
aFile.close();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_capacity_position_и_limit_для_буфера">Capacity, position и limit для буфера</h4>
<div class="paragraph">
<p>У <code>Buffer</code> есть три поля, с которыми нужно ознакомиться, чтобы понять, как <code>Buffer</code> работает:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>capacity</code></p>
</li>
<li>
<p><code>position</code></p>
</li>
<li>
<p><code>limit</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Значение <code>position</code> и <code>limit</code> зависит от того, <code>Buffer</code> находится ли режим чтения или записи. Емкость всегда означает одно и то же, независимо от режима буфера.</p>
</div>
<div class="paragraph">
<p>Вот иллюстрация емкости, положения и ограничения в режимах записи и чтения. Объяснение следует в разделах после иллюстрации.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/assets/img/java/core/nio/buffers-modes.png" alt="Java NIO: capacity" width="position" height="limit для буфера в режиме записи и чтения"></span></p>
</div>
<div class="sect4">
<h5 id="_capacity">Capacity</h5>
<div class="paragraph">
<p>Будучи блоком памяти, a <code>Buffer</code> имеет определенный фиксированный размер, в который можно записывать только байты, символы и т.д. Когда буфер заполнен, тогда нужно его очистить (прочитать или очистить данные), прежде чем иметь возможность записать в него больше данных.</p>
</div>
</div>
<div class="sect4">
<h5 id="_position">Position</h5>
<div class="paragraph">
<p>Когда данные записываются в <code>Buffer</code>, то это происходит с текущей <code>position</code>. Первоначально позиция равна <code>0</code>. Когда происходит запись одного байта, символа и т.д. в <code>Buffer</code> в текущую <code>position</code>, то она перемещается вперед, чтобы указывать на следующую ячейку в буфере, куда в дальнейшем будут записываться данные. Максимальное значение <code>position</code> может быть <code>capacity - 1</code>.</p>
</div>
<div class="paragraph">
<p>Когда данные из <code>Buffer</code> читаются, то это можно делать с текущей <code>position</code>. Когда <code>Buffer</code> переключается из режима записи в режим чтения, <code>position</code> сбрасывается обратно на <code>0</code>. При чтении данных из <code>Buffer</code>, они читаются с <code>position</code> и значение <code>position</code> изменяется на следующее.</p>
</div>
</div>
<div class="sect4">
<h5 id="_limit">Limit</h5>
<div class="paragraph">
<p>В режиме записи <code>limit</code> для <code>Buffer</code> - это предел того, сколько данных можно записать в буфер. В режиме записи ограничение равно <code>capacity</code> для <code>Buffer</code>.</p>
</div>
<div class="paragraph">
<p>При переключении <code>Buffer</code> в режим чтения, <code>limit</code> означает предел того, сколько данных можно прочитать. Следовательно, при переключении <code>Buffer</code> в режим чтения <code>limit</code> задается равным <code>position</code> в режиме записи. Другими словами, можно прочитать столько байтов, сколько было записано.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_типы_буфера">Типы буфера</h4>
<div class="paragraph">
<p>Java NIO содержит следующие типы буферов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ByteBuffer</code></p>
</li>
<li>
<p><code>MappedByteBuffer</code></p>
</li>
<li>
<p><code>CharBuffer</code></p>
</li>
<li>
<p><code>DoubleBuffer</code></p>
</li>
<li>
<p><code>FloatBuffer</code></p>
</li>
<li>
<p><code>IntBuffer</code></p>
</li>
<li>
<p><code>LongBuffer</code></p>
</li>
<li>
<p><code>ShortBuffer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Эти типы <code>Buffer</code> представляют разные типы данных. Другими словами, они позволяют работать с байтами в буфере как <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code> или <code>double</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_создание_буфера">Создание буфера</h4>
<div class="paragraph">
<p>У каждого <code>Buffer</code> класса есть <code>allocate()</code> метод, который создает объект <code>Buffer</code>. Например, создание <code>ByteBuffer</code> с <code>capacity</code> 48 байт:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ByteBuffer buf = ByteBuffer.allocate(48);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Например, создание <code>CharBuffer</code> с <code>capacity</code> для размещения 1024 символов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">CharBuffer buf = CharBuffer.allocate(1024);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_запись_данных_в_буфер">Запись данных в буфер</h4>
<div class="paragraph">
<p>Данные в буфер можно записать двумя способами:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>из <code>Channel</code> в <code>Buffer</code></p>
</li>
<li>
<p>используя <code>put()</code> методы класса <code>Buffer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример, как с помощью <code>Channel</code> можно записывать данные в <code>Buffer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int bytesRead = inChannel.read(buf); // read into buffer</code></pre>
</div>
</div>
<div class="paragraph">
<p>Пример, как с помощью метода <code>put()</code> класса <code>Buffer</code> можно записывать данные в него:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">buf.put (127);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Существует много других версий метода <code>put()</code>, позволяющих записывать данные в <code>Buffer</code> различными способами. Например, запись в определенные позиции или запись массива байтов в буфер. Все это, можно посмотреть в <strong>JavaDoc</strong> для конкретной реализации буфера.</p>
</div>
</div>
<div class="sect3">
<h4 id="_flip"><code>flip()</code></h4>
<div class="paragraph">
<p>Метод <code>flip()</code> переключает <code>Buffer</code> из режима записи в режиме чтения. Вызов метода <code>flip()</code> устанавливает <code>position</code> обратно в <code>0</code> и устанавливает <code>limit</code> значение недавного <code>position</code>.</p>
</div>
<div class="paragraph">
<p>Другими словами, <code>position</code> теперь указывает на позицию чтения, а  <code>limit</code> показывает, сколько байт, символов и т.д. было записано в буфер.</p>
</div>
</div>
<div class="sect3">
<h4 id="_чтение_данных_из_буфера">Чтение данных из буфера</h4>
<div class="paragraph">
<p>Есть два способа чтения данных из <code>Buffer</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>из <code>Buffer</code> в <code>Channel</code></p>
</li>
<li>
<p>используя <code>get()</code> методы класса <code>Buffer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример, как с помощью <code>Channel</code> можно читать данные из <code>Buffer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">//read from buffer into channel.
int bytesWritten = inChannel.write(buf);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Пример, как с помощью метода <code>get()</code> класса <code>Buffer</code> можно читать данные из него:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">byte aByte = buf.get();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Существует много других версий метода <code>get()</code>, позволяющих считывать данные из <code>Buffer</code> различными способами. Например, чтение из определенных позиций или чтение массива байт из буфера. Все это, можно посмотреть в <strong>JavaDoc</strong> для конкретной реализации буфера.</p>
</div>
</div>
<div class="sect3">
<h4 id="_rewind"><code>rewind()</code></h4>
<div class="paragraph">
<p><code>Buffer.rewind()</code> устанавливает в <code>position</code> значение <code>0</code>, так что можно было перечитать все данные в буфере. При этом <code>limit</code> не изменяется.</p>
</div>
</div>
<div class="sect3">
<h4 id="_clear_и_compact"><code>clear()</code> и <code>compact()</code></h4>
<div class="paragraph">
<p>После прочтения данных из <code>Buffer</code>, его необходимо снова подготовиться к записи. Это можно сделать, вызвав методы <code>clear()</code> или <code>compact()</code>.</p>
</div>
<div class="paragraph">
<p>Если вызвать метод <code>clear()</code>, то <code>limit</code> станет равен значению <code>capacity</code>, a <code>position</code> станет <code>0</code>. Другими словами, <code>Buffer</code> очищается, но данные из него не удалены.</p>
</div>
<div class="paragraph">
<p>Если в момент вызова <code>clear()</code> были непрочитанные данные, то нельзя больше установить какие из них были прочитаны, а какие нет.</p>
</div>
<div class="paragraph">
<p>Если в <code>Buffer</code> все еще есть непрочитанные данные, и их необходимо прочитать позже, но перед этим нужно что-то еще записать в <code>Buffer</code>, тогда используют <code>compact()</code> вместо <code>clear()</code>.</p>
</div>
<div class="paragraph">
<p>Метод <code>compact()</code> копирует все непрочитанные данные в начало <code>Buffer</code>, а затем <code>position</code> устанавливается  сразу после последнего непрочитанного элемента. Для <code>limit</code> задается значение <code>capacity</code>, так же, как и для <code>clear()</code>. Теперь <code>Buffer</code> готов к записи и непрочитанные данные не будет перезаписываться.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mark_и_reset"><code>mark()</code> и <code>reset()</code></h4>
<div class="paragraph">
<p>Можно пометить данную позицию в <code>Buffer</code>, вызвав метод <code>Buffer.mark()</code>. Затем можно сбросить <code>position</code> обратно в помеченную позицию, вызвав метод <code>Buffer.reset()</code>. Вот пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">buffer.mark();
//call buffer.get() a couple of times, e.g. during parsing.
buffer.reset();  //set position back to mark.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_equals_и_compareto"><code>equals()</code> и <code>compareTo()</code></h4>
<div class="paragraph">
<p>Можно сравнить два буфера, используя <code>equals()</code> и <code>compareTo()</code>.</p>
</div>
<div class="sect4">
<h5 id="_equals"><code>equals()</code></h5>
<div class="paragraph">
<p>Два буфера равны, если:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Они одного типа (байт, символ, int и т. Д.)</p>
</li>
<li>
<p>Они имеют одинаковое количество оставшихся байтов, символов и т. Д. В буфере.</p>
</li>
<li>
<p>Все остальные байты, символы и т. Д. Равны.</p>
</li>
<li>
<p>Как вы можете видеть, функция equals сравнивает только часть `Buffer, а не каждый отдельный элемент. На самом деле, он просто сравнивает остальные элементы в `Buffer.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_compareto"><code>compareTo()</code></h5>
<div class="paragraph">
<p>Метод <code>compareTo()</code> сравнивает остальные элементы (байты, символы и т.д.) из двух буферов, для использования, например, в подпрограммах сортировки. Буфер считается «меньшим», чем другой буфер, если:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>найден элемент, который отличается от соответствующего элемента из другого буфера, и он меньше его</p>
</li>
<li>
<p>все элементы равны, но в первом буфере количество элементов меньше, чем во втором</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_java_memory_management">Java Memory Management</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_почему_необходимо_заботиться_об_управлении_памятью">Почему необходимо заботиться об управлении памятью?</h3>
<div class="paragraph">
<p>Многие разработчики не заботятся об управлении памятью, так как в Java ж е есть <strong>Garbage Collection</strong> (<strong>GC</strong>/<strong>Сборка мусора</strong>). <strong>Garbage Collection</strong> - это процесс, с помощью которого Java программы выполняют автоматическое управление памятью. По сути, код, который пишется на Java (и других языках для JVM), компилируется в byte-код (файл <code>.class</code>) и запускается на <strong>JVM</strong> (<strong>виртуальной машине Java</strong>). Когда приложение работает на <strong>JVM</strong>, большинство объектов создается в <strong>HEAP</strong> (<strong>Куча</strong>). В процессе работы, некоторые объекты больше не понадобятся (недоступные/неиспользуемые объекты). <strong>Garbage Collector</strong> (<strong>Сборщик мусора</strong>) освободит неиспользуемую память, чтобы вернуть память для программы, других приложений и операционной системы.</p>
</div>
<div class="quoteblock">
<blockquote>
Memory management is the process of allocating new objects and removing unused objects to make space for those new object allocations
</blockquote>
<div class="attribution">
&#8212; oracle.com
</div>
</div>
<div class="paragraph">
<p>В некоторых языках, таких как C, необходимо управлять памятью вручную. Таким образом, написать приложение на C очень сложно. Мы должны тщательно выделять/освобождать переменные и объекты, потому что это может привести к <strong>memory leak</strong> (<strong>утечке памяти</strong>).</p>
</div>
<div class="paragraph">
<p>Проще говоря когда в <strong>HEAP</strong> выделена память для объекта, он не используется и эта память не может освободиться, в этом случае это <strong>memory leak</strong>. <strong>Memory leak</strong> следует избегать, потому что они приводят к <em>падению</em> приложения или заставляют его работать медленно.</p>
</div>
<div class="paragraph">
<p>Предположим, нам нужно получить метаданные изображения, когда у нас есть URL-адрес этого файла. Для простоты можно использовать файл на локальном компьютере.</p>
</div>
<div class="paragraph">
<p>Основная программа:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.rakovets.jmm.main;

import com.rakovets.jmm.entity.Metadata;
import com.rakovets.jmm.utils.ImageMetadataUtils;

public class ImageMetadataExample {
    public static void main(String[] args) {
        try {
            final String url = "/home/rakovets/pics/2000x2000px_keepcalm.jpg";
            for (int i = 0; i &lt; 2000; i ++) {
                Metadata metadata = ImageMetadataUtils.getMetadataLocalFile(url);
                System.out.println(String.format("Count %d URL: %s, metadata: %s", i, url, metadata.toString()));
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>MetadataUtils</code> класс:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.rakovets.jmm.utils;

import java.awt.image.BufferedImage;
import java.io.File;
import java.util.Map;
import java.util.Set;

import javax.imageio.ImageIO;
import com.rakovets.jmm.entity.Metadata;

import lombok.experimental.UtilityClass;

@UtilityClass
public class ImageMetadataUtils {
    public static Metadata getMetadataLocalFile(String url) {
        try {
            final File outputFile = new File(url);
            final BufferedImage buf = ImageIO.read(outputFile);
            final int width = buf.getWidth();
            final int height = buf.getHeight();
            final long fileSize = outputFile.length();
            return new Metadata(url, width, height, fileSize);
        } catch (Exception e) {
            e.printStackTrace();
            System.out.printf("[ERROR] Get metadata from url %s: %s\n", url, e.getMessage());
            return null;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Класс <code>Metadata</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.rakovets.jmm.entity;

public class Metadata {
    private String url;
    private Integer width;
    private Integer height;
    private Long fileSizeInBytes;

    public Metadata(String url, Integer width, Integer height, Long fileSizeInBytes) {
        this.url = url;
        this.width = width;
        this.height = height;
        this.fileSizeInBytes = fileSizeInBytes;
    }

    public String toString() {
        return new StringBuilder()
                .append("Width ").append(width)
                .append(", Height: ").append(height)
                .append(", Size: ").append(fileSizeInBytes)
                .toString();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Есть ли в вышеприведенном коде какие-то проблемы? Как определить что в программе есть проблемы с памятью? Для этого можно использовать специализированные инструменты для мониторинга Java-приложений. Один из которых и будет далее использоваться: <strong>JVisualVM</strong>.</p>
</div>
<div class="paragraph">
<div class="title">Tab Heap</div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/j-visual-vm-1.png" alt="Tab Heap"></span></p>
</div>
<div class="paragraph">
<p>В раздел <strong>HEAP</strong> можно увидеть что небольшая программа потребляет <code>1 044 839 312</code> byte  (~ 1Gb) памяти в <strong>HEAP</strong>.</p>
</div>
<div class="paragraph">
<p>Почему?</p>
</div>
<div class="paragraph">
<p>Посмотрим <strong>Heap Dump</strong>.</p>
</div>
<div class="paragraph">
<div class="title">Object <code>BufferImage</code></div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/j-visual-vm-2.png" alt="Object <code>BufferImage</code>"></span></p>
</div>
<div class="paragraph">
<p>Объект <code>BufferImage</code> очень большой и занимает 12Mb в <strong>HEAP</strong>. Поскольку один пиксель занимает 3 байта памяти, а используется изображение размером 2000x2000 пикселей (3 * 2000 * 2000 = 12Mb).</p>
</div>
<div class="paragraph">
<p>Проблема обнаружена, соответственно можно выработать решение для данной проблемы.</p>
</div>
<div class="paragraph">
<p>Используем класс <code>com.drew.imaging.ImageMetadataReader</code> в библиотеке <a href="https://jar-download.com/artifacts/com.drewnoakes/metadata-extractor/2.11.0/source-code">metadata-extractor</a> для получения метаданных изображения.</p>
</div>
<div class="paragraph">
<p>Обновленный код для класса <code>ImageMetadataUtils</code> и основной программы будет выглядеть следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.rakovets.jmm.utils;

import java.awt.image.BufferedImage;
import java.io.File;
import java.util.Map;
import java.util.Set;

import javax.imageio.ImageIO;

import com.drew.metadata.Directory;
import com.drew.metadata.bmp.BmpHeaderDirectory;
import com.drew.metadata.exif.ExifIFD0Directory;
import com.drew.metadata.gif.GifHeaderDirectory;
import com.drew.metadata.jpeg.JpegDirectory;
import com.drew.metadata.png.PngDirectory;
import com.google.common.collect.ImmutableMap;
import com.rakovets.jmm.entity.Metadata;
import com.drew.imaging.ImageMetadataReader;

import lombok.Builder;
import lombok.Data;
import lombok.experimental.UtilityClass;

@UtilityClass
public class ImageMetadataUtils {
    @Data
    @Builder
    private static class NeededImageTag {
        private int height;
        private int width;
    }
    private static final Map&lt;Class&lt;? extends Directory&gt;, NeededImageTag&gt; SUPPORTED_TYPES_MAP
            = new ImmutableMap.Builder&lt;Class&lt;? extends Directory&gt;, NeededImageTag&gt;()
            .put(JpegDirectory.class, NeededImageTag.builder().height(JpegDirectory.TAG_IMAGE_HEIGHT).width(JpegDirectory.TAG_IMAGE_WIDTH).build())
            .put(PngDirectory.class, NeededImageTag.builder().height(PngDirectory.TAG_IMAGE_HEIGHT).width(PngDirectory.TAG_IMAGE_WIDTH).build())
            .put(GifHeaderDirectory.class, NeededImageTag.builder().height(GifHeaderDirectory.TAG_IMAGE_HEIGHT).width(GifHeaderDirectory.TAG_IMAGE_WIDTH).build())
            .put(BmpHeaderDirectory.class, NeededImageTag.builder().height(BmpHeaderDirectory.TAG_IMAGE_HEIGHT).width(BmpHeaderDirectory.TAG_IMAGE_WIDTH).build())
            .put(ExifIFD0Directory.class, NeededImageTag.builder().height(ExifIFD0Directory.TAG_IMAGE_HEIGHT).width(ExifIFD0Directory.TAG_IMAGE_WIDTH).build())
            .build();
    private static final Set&lt;Class&lt;? extends Directory&gt;&gt; SUPPORTED_TYPES = SUPPORTED_TYPES_MAP.keySet();

    public static Metadata getMetadata(String url) {
        try {
            final File outputFile = new File(url);
            final long fileSize = outputFile.length();
            final com.drew.metadata.Metadata metadata = ImageMetadataReader.readMetadata(outputFile);
            for (final Class&lt;? extends Directory&gt; type : SUPPORTED_TYPES) {
                if (metadata.containsDirectoryOfType(type)) {
                    final Directory directory = metadata.getFirstDirectoryOfType(type);
                    final NeededImageTag tag = SUPPORTED_TYPES_MAP.get(type);
                    return new Metadata(url, directory.getInt(tag.width), directory.getInt(tag.height), fileSize);
                }
            }
            return null;
        } catch (Exception e) {
            e.printStackTrace();
            System.out.printf("[ERROR] Get metadata from url %s: %s\n", url, e.getMessage());
            return null;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Основная программа:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.rakovets.jmm.main;

import com.rakovets.jmm.entity.Metadata;
import com.rakovets.jmm.utils.ImageMetadataUtils;

public class ImageMetadataExample {

    public static void main(String[] args) {
        try {
            // This application runs very fast and difficult to monitor so, I will sleep in 10 seconds.
            System.out.println("Sleep in 10 seconds");
            Thread.sleep(10000);
            final String url = "/Users/daudm/Desktop/2000x2000px_keepcalm.jpg";
            for (int i = 0; i &lt; 2000; i ++) {
                Metadata metadata = ImageMetadataUtils.getMetadata(url);
                System.out.printf("Count %d URL: %s, metadata: %s\n", i, url, metadata.toString());
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>После этого можно запустить приложение и отследить его с помощью <strong>JVisualVM</strong>:</p>
</div>
<div class="paragraph">
<div class="title">Tab Heap</div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/j-visual-vm-3.png" alt="Tab Heap"></span></p>
</div>
<div class="paragraph">
<p>Приложение работает очень быстро и потребляет всего 21Mb в <strong>HEAP</strong>.</p>
</div>
<div class="paragraph">
<p>Умение управление памятью очень важно для каждого разработчика. Это не зависит от языка программирования: Java, C и т.д. Более глубокое понимание управления памятью поможет написать приложение с высокой производительностью, которое может работать на маломощных машинах. По сути, приложение написанное на Java будет работать на <strong>JVM</strong>. Для того что бы управлять памятью в Java, необходимо сначала понять архитектуру <strong>JVM</strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_архитектура_виртуальной_машины_java_архитектура_jvm">Архитектура виртуальной машины Java (архитектура JVM)</h3>
<div class="paragraph">
<p><strong>JVM</strong> - это всего лишь спецификация, и она имеет множество различных реализаций. Можно провести аналогию с интерфейсом и несколькими реализациями в Java программе. Чтобы узнать информацию о JVM, можно воспользоваться командой <code>java -version</code> в терминале.</p>
</div>
<div class="paragraph">
<p>Если установлена <strong>AdoptOpenJDK</strong>, то отобразится следующая информация:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>openjdk 11.0.7 2020-04-14
OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.7+10)
OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.7+10, mixed mode)</pre>
</div>
</div>
<div class="paragraph">
<p>Как же выглядит архитектура <strong>JVM</strong>?</p>
</div>
<div class="paragraph">
<div class="title"><strong>Java Virtual Machine</strong> Architecture</div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/jvm-architecture.png" alt="JVM Architecture"></span></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Class Loader Subsystem</strong> (<strong>Система загрузчиков классов</strong>): <strong>JVM</strong> работает с <strong>RAM</strong>. Во время выполнения с использованием <strong>Class Loader Subsystem</strong> файлы классов переносятся в <strong>RAM</strong>. Эта функция называется динамической загрузкой классов в Java. Она загружает, связывает и инициализирует <code>.class</code>-файлы, когда идет первое обращение к классу во время выполнения. В конце будет выполнена логика инициализации каждого загруженного класса (например, вызов конструктора класса), всем статическим переменным будут присвоены исходные значения, и будет выполнен статический блок.</p>
</li>
<li>
<p><strong>Runtime Data Area</strong> (<strong>Область данных времени выполнения</strong>): области памяти, которая выдается JVM при запуске программы в ОС.</p>
<div class="ulist">
<ul>
<li>
<p><strong>Method Area</strong> (<strong>Область метода</strong>) общая для потоков. Хранит все данные уровня класса (пул констант времени выполнения, статические переменные, данные полей, методы (данные, код)). Только один <strong>Method Area</strong> на <strong>JVM</strong>.</p>
</li>
<li>
<p><strong>Heap Area</strong> (<strong>Область кучи</strong>) общая для потоков: здесь будут храниться все переменные, объекты, массивы. Один <strong>Heap</strong> на каждую JVM. За <strong>Heap Area</strong> и его очистку от неиспользуемых объектов отвечает <strong>GC</strong>.</p>
</li>
<li>
<p><strong>Stack Area</strong> (<strong>Область стека</strong>) для каждого <strong>thread</strong> (<strong>потока</strong>) своя: для каждого потока в <strong>runtime</strong> будет создан новый <strong>stack area</strong>, для каждого вызова метода в стек будет добавлена одна запись, называемая <strong>stack frame</strong>. Каждый <strong>stack frame</strong> имеет ссылку на массив локальных переменных, стек операндов и пул констант времени выполнения класса, к которому принадлежит выполняемый метод.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Execution Engine</strong> (<strong>Механизм выполнения</strong>): будет выполнять <strong>byte</strong>-код, описанный в программе.</p>
<div class="ulist">
<ul>
<li>
<p><strong>Interpreter</strong> (<strong>Интерпретатор</strong>): быстро интерпретирует <strong>byte</strong>-код, но медленно выполняет его. Недостатком является то, что когда один метод вызывается несколько раз, каждый раз требуется новая интерпретация и более медленное выполнение.</p>
</li>
<li>
<p><strong>JIT Compiler</strong> (<strong>JIT-компилятор</strong>): устраняет недостатки <strong>interpreter</strong>, когда он обнаруживает повторяющийся код, он использует <strong>JIT Compiler</strong>. Он скомпилирует <strong>byte</strong>-код в машинный код. Код хранится в кеше, а не интерпретируется, поэтому скомпилированный код можно выполнить быстрее.</p>
</li>
<li>
<p><strong>Garbage Collector</strong> (<strong>Сборщик мусора</strong>): собирает и удаляет объекты, которые не используются (т.е. на которые нет ссылок). Пока на объект ссылаются, <strong>JVM</strong> считает его живым. Когда на объект больше не ссылаются и, следовательно, он недоступен для кода приложения, <strong>Garbage Collector</strong> удаляет его и освобождает неиспользуемую память. В общем, <strong>Garbage Collector</strong> - это автоматический процесс. Однако его можно запустить, вызвав метод <code>System.gc()</code> или <code>Runtime.getRuntime().gc()</code>. Но выполнение не гарантируется, поэтому следует вызвать <code>Thread.sleep(1000)</code> и дождаться завершения GC.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_модель_памяти_heap_без_heap_другая_память">Модель памяти (HEAP, без HEAP, другая память)</h3>
<div class="paragraph">
<p><strong>JVM</strong> использует доступное пространство памяти в операционной системе. <strong>JVM</strong> включает области памяти:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>HEAP</strong></p>
</li>
<li>
<p><strong>Non-HEAP</strong></p>
</li>
<li>
<p><strong>Other Memory</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">JVM Memory Model</div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/jvm-memory-model.png" alt="JVM Memory Model"></span></p>
</div>
<div class="sect3">
<h4 id="_heap">HEAP</h4>
<div class="paragraph">
<p>HEAP состоит из двух частей:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Young Generation</strong> (<strong>Young Gen</strong>/<strong>Молодое поколение</strong>)</p>
</li>
<li>
<p><strong>Old Generation</strong> (<strong>Old Gen</strong>/<strong>Старое поколение</strong>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title"><strong>JVM</strong> Heap Model</div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/jvm-heap-model.png" alt="JVM Heap Model"></span></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Young Generation</strong>: здесь создаются все новые объекты. Когда <strong>Young Generation</strong> заполнено, выполняется сборщик мусора (<strong>Minor GC</strong>). Он разделен на три части: одно <strong>Eden Space</strong> и два <strong>Survivor Spaces</strong> (<strong>S0</strong>, <strong>S1</strong>). Некоторые тонкости:</p>
<div class="ulist">
<ul>
<li>
<p>Большинство только что созданных объектов находится в <strong>Eden Space</strong>.</p>
</li>
<li>
<p>Если <strong>Eden Space</strong> заполнен объектами, <strong>Minor GC</strong> будет выполнен, и все выжившие объекты перемещается к одному из оставшихся в <strong>Survivor Spaces</strong>.</p>
</li>
<li>
<p>Объекты, уцелевшие после многих циклов <strong>Minor GC</strong>, перемещаются в пространство <strong>Old Generation space</strong>. Обычно это делается путем установления порога возраста объектов <strong>Young Generation</strong>, прежде чем они станут подходящими для продвижения к <strong>Old Generation</strong>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Old Generation</strong>: зарезервировано для содержания долгоживущие объектов, которые выживают после многих раундов в <strong>Minor GC</strong>. Когда <strong>Old Generation</strong> полно, будет выполнен <strong>Major GC</strong>, но как правило, он занимает больше времени.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_non_heap">Non-HEAP</h4>
<div class="paragraph">
<p><strong>Non-HEAP</strong> (<strong>Off-HEAP</strong>): иногда называют <strong>Off-HEAP</strong>. В Java 7 и более ранних версиях это пространство называется <strong>Permanent Generation</strong> (<strong>Perm Gen</strong>). Начиная с Java 8, <strong>Perm Gen</strong> заменяется <strong>Metaspace</strong>.</p>
</div>
<div class="paragraph">
<p><strong>Metaspace</strong> хранит структуры для каждого класса, такие как пул констант времени выполнения, данные полей и методов, а также код методов и конструкторов, а также интернированные строки.</p>
</div>
<div class="paragraph">
<p><strong>Metaspace</strong> по умолчанию автоматически увеличивает свой размер (до того, что предоставляет базовая ОС), в то время как <strong>Perm Gen</strong> всегда имеет фиксированный максимальный размер. Для установки размера метапространства можно использовать два новых флага: <code>-XX:MetaspaceSize</code> и <code>-XX:MaxMetaspaceSize</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_other_memory">Other memory</h4>
<div class="ulist">
<ul>
<li>
<p><strong>CodeCache</strong> содержит <strong>complied</strong>-код (т.е. <strong>native</strong>-код), созданный <strong>JIT-компилятором</strong>, внутренние структуры <strong>JVM</strong>, загруженный код агента профилировщика, данные и т.д.</p>
</li>
<li>
<p><strong>Thread Stacks</strong> относятся к интерпретируемым, скомпилированным и собственным <strong>stack frames</strong>.</p>
</li>
<li>
<p><strong>Direct Memory</strong> используется для выделения прямого буфера (например, <strong>NIO Buffer/ByteBuffer</strong>)</p>
</li>
<li>
<p><strong>C-Heap</strong> используется, например, <strong>JIT-компилятором</strong> или <strong>GC</strong> для выделения памяти для внутренних структур данных.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_garbage_collection">Garbage Collection</h3>
<div class="paragraph">
<p><strong>GC</strong> помогает разработчикам писать код без выделения/освобождения памяти и позволяет не заботиться о проблемах с памятью. Однако в реальном проекте иногда имеются проблем с памятью. Они заставляют приложение работать с неэффективно и очень медленно.</p>
</div>
<div class="paragraph">
<p>Таким образом, мы должны понять, как работает <strong>GC</strong>. Все объекты размещаются в <strong>HEAP</strong>, управляемой <strong>JVM</strong>. Пока на объект ссылаются, <strong>JVM</strong> считает его живым. Когда на объект больше не ссылаются и, следовательно, он недоступен для кода приложения, <strong>garbage collector</strong> удаляет его и освобождает неиспользуемую память.</p>
</div>
<div class="paragraph">
<p>Как <strong>GC</strong> управляет объектами в <strong>HEAP</strong>? Ответ заключается в том, что он строит <strong>Tree</strong> (<strong>дерево</strong>), называемое <strong>Garbage Collection Roots</strong> (<strong>GC roots</strong>/<strong>корни сборки мусора</strong>). Он содержит множество ссылок между кодом приложения и объектами в <strong>HEAP</strong>.</p>
</div>
<div class="paragraph">
<p>Существует четыре типа <strong>Garbage Collection Roots</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Local variables</strong> (<strong>локальные переменные</strong>)</p>
</li>
<li>
<p><strong>Active threads</strong> (<strong>активные потоки</strong>)</p>
</li>
<li>
<p><strong>Static variables</strong> (<strong>статические переменные</strong>)</p>
</li>
<li>
<p><strong>JNI references</strong> (<strong>JNI ссылки</strong>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пока на наш объект прямо или косвенно ссылается один из этих корней GC, а корень GC остается живым, наш объект можно рассматривать как достижимый объект. В тот момент, когда объект теряет ссылку на <strong>Garbage Collection Root</strong>, он становится недоступным, следовательно, может быть удален когда произойдет <strong>GC</strong>.</p>
</div>
<div class="paragraph">
<div class="title">Garbage Collection</div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/gc.png" alt="Garbage Collection"></span></p>
</div>
<div class="paragraph">
<p><strong>Garbage Collection Roots</strong> - это объекты, на которые сама <strong>JVM</strong> ссылается и, таким образом, предотвращает сборку мусора для всех остальных объектов.</p>
</div>
<div class="sect3">
<h4 id="_mark_and_sweep_model">Mark and Sweep Model</h4>
<div class="paragraph">
<p>Чтобы определить, какие объекты больше не используются, <strong>JVM</strong> использует алгоритм <strong>mark-and-sweep</strong>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Алгоритм просматривает все ссылки на объекты, начиная с <strong>Garbage Collection Roots</strong>, и отмечает каждый найденный объект как <em>живой</em>.</p>
</li>
<li>
<p>Требуется вся память *HEAP, которая не занятая отмеченными объектами.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Возможны случаи, когда есть неиспользуемые объекты, но которые все еще доступны для приложения, потому что разработчики просто забыли разыменовать их. В этом случае происходит <strong>memory-leak</strong> (<strong>утечка памяти</strong>). Поэтому следует отслеживать/анализировать приложение, чтобы определить проблему.</p>
</div>
<div class="paragraph">
<div class="title">GC: Mark adn Sweep</div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/gc-mark-and-sweep.png" alt="GC: Mark adn Sweep"></span></p>
</div>
<div class="paragraph">
<p>Когда на объекты больше не ссылается прямо или косвенно корень сборщика мусора, они будут удалены.</p>
</div>
</div>
<div class="sect3">
<h4 id="_stop_the_world_event">Stop the World Event</h4>
<div class="paragraph">
<p>При выполнении <strong>GC</strong> все потоки приложений останавливаются до завершения операции. Поскольку <strong>Young Generation</strong> хранит недолговечные объекты, <strong>Minor GC</strong> работает очень быстро, и это не влияет на приложение. Однако <strong>Major GC</strong> занимает много времени, потому что он проверяет все живые объекты. Количество <strong>Major GC</strong> следует свести к минимуму, поскольку он приведет к тому, что приложение не будет отвечать на все время <strong>GC</strong>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_мониторинг_и_настройка_gc">Мониторинг и настройка <strong>GC</strong></h3>
<div class="paragraph">
<p>Можно отслеживать приложение Java с помощью командной строки и различных инструментов. На самом деле существует множество инструментов: <strong>JVisualVM</strong>, <strong>JProfile</strong>, <strong>Eclipse MAT</strong>, <strong>JetBrains JVM Debugger</strong>, <strong>Netbeans Profiler</strong>, &#8230;&#8203; Рекомендуется использовать <strong>JVisualVM</strong>, который встроен в <strong>JDK</strong>. Этого достаточно для мониторинга приложения.</p>
</div>
<div class="sect3">
<h4 id="_jstat"><code>jstat</code></h4>
<div class="paragraph">
<p><code>jstat</code> - <strong>Java Virtual Machine Statistics Monitoring Tool</strong>. <code>jstat</code> можно использовать для мониторинга памяти <strong>JVM</strong> и активности <strong>GC</strong>. Например, можно печать потребление памяти и данных <strong>GC</strong> каждую секунду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell script" data-lang="shell script">jstat -gc &lt;pid&gt; 1000</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Пример с командой <code>jstat</code></div>
<p><span class="image"><img src="../../../assets/img/java/core/misc/jmm/jstat.png" alt="Пример с командой <code>jstat</code>"></span></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. <code>jstat</code> abbreviations</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Column</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>S0C</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current survivor space 0 capacity (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>S1C</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current survivor space 1 capacity (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>S0U</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Survivor space 0 utilization (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>S1U</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Survivor space 1 utilization (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>EC</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current eden space capacity (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>EU</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Eden space utilization (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>OC</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current old space capacity (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>OU</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Old space utilization (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>PC</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current permanent space capacity (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>PU</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Permanent space utilization (KB).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>YGC</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of young generation GC Events.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>YGCT</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Young generation garbage collection time.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>FGC</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of full GC events.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>FGCT</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Full garbage collection time.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>GCT</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Total garbage collection time.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Если не получается запустить команду или выдает ошибку: <em>Не удалось подключиться к &lt;pid&gt;</em>, тогда следует запустить команду от имени <code>root</code> пользователя.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_jvisualvm">JVisualVM</h4>
<div class="paragraph">
<p>Можно открыть <strong>GUI Tool</strong> через <strong>terminal</strong> с помощью команды <code>jvisualvm</code>. Этот инструмент, использовался в начале. Рекомендую использовать <strong>JVisualVM</strong> для мониторинга/настройки <strong>GC</strong> перед релизом каких-либо функций в <strong>testing</strong>/<strong>staging</strong>/<strong>production</strong> <strong>environment</strong>. Необходимо проверять, есть ли проблемы с памятью, чтобы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>гарантировать, что приложение потребляет мало памяти</p>
</li>
<li>
<p>гарантировать, что приложение работает очень быстро и не имеет проблем с <strong>memory-leak</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Важно, что приложение может использовать <strong>native memory</strong> (<strong>Metaspace</strong>, <strong>Direct Memory</strong>), которая не управляется <strong>GC</strong>. В этом случае необходимо выделить/освободить память вручную. Когда используются сторонние библиотеки, необходимо внимательно проверять их перед использованием.</p>
</div>
<div class="paragraph">
<p>Иногда, используя сторонние библиотеки, можно ожидать что они будут использовать <strong>HEAP</strong> и создавать в нем объекты, но на самом деле, они могут использовать <strong>native memory</strong> (<code>ByteBuffer</code>). Когда приложение будет тестироваться, то все будет работать нормально, только тестирование производительности (например с помощью <strong>Jmeter</strong>) выявит проблему с недостатком памяти.</p>
</div>
</div>
<div class="sect3">
<h4 id="_java_non_standard_options">Java Non-Standard Options</h4>
<div class="paragraph">
<p>Для повышения производительности приложения можно проверить и установить нестандартные параметры для <strong>JVM</strong>. Их можно просмотреть через командную строку с помощью команды:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell script" data-lang="shell script">java -X</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>    -Xbatch           disable background compilation
    -Xbootclasspath/a:&lt;directories and zip/jar files separated by :&gt;
                      append to end of bootstrap class path
    -Xcheck:jni       perform additional checks for JNI functions
    -Xcomp            forces compilation of methods on first invocation
    -Xdebug           provided for backward compatibility
    -Xdiag            show additional diagnostic messages
    -Xfuture          enable strictest checks, anticipating future default
    -Xint             interpreted mode execution only
    -Xinternalversion
                      displays more detailed JVM version information than the
                      -version option
    -Xloggc:&lt;file&gt;    log GC status to a file with time stamps
    -Xmixed           mixed mode execution (default)
    -Xmn&lt;size&gt;        sets the initial and maximum size (in bytes) of the heap
                      for the young generation (nursery)
    -Xms&lt;size&gt;        set initial Java heap size
    -Xmx&lt;size&gt;        set maximum Java heap size
    -Xnoclassgc       disable class garbage collection
    -Xrs              reduce use of OS signals by Java/VM (see documentation)
    -Xshare:auto      use shared class data if possible (default)
    -Xshare:off       do not attempt to use shared class data
    -Xshare:on        require using shared class data, otherwise fail.
    -XshowSettings    show all settings and continue
    -XshowSettings:all
                      show all settings and continue
    -XshowSettings:locale
                      show all locale related settings and continue
    -XshowSettings:properties
                      show all property settings and continue
    -XshowSettings:vm
                      show all vm related settings and continue
    -XshowSettings:system
                      (Linux Only) show host system or container
                      configuration and continue
    -Xss&lt;size&gt;        set java thread stack size
    -Xverify          sets the mode of the bytecode verifier
    --add-reads &lt;module&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*
                      updates &lt;module&gt; to read &lt;target-module&gt;, regardless
                      of module declaration.
                      &lt;target-module&gt; can be ALL-UNNAMED to read all unnamed
                      modules.
    --add-exports &lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*
                      updates &lt;module&gt; to export &lt;package&gt; to &lt;target-module&gt;,
                      regardless of module declaration.
                      &lt;target-module&gt; can be ALL-UNNAMED to export to all
                      unnamed modules.
    --add-opens &lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*
                      updates &lt;module&gt; to open &lt;package&gt; to
                      &lt;target-module&gt;, regardless of module declaration.
    --illegal-access=&lt;value&gt;
                      permit or deny access to members of types in named modules
                      by code in unnamed modules.
                      &lt;value&gt; is one of "deny", "permit", "warn", or "debug"
                      This option will be removed in a future release.
    --limit-modules &lt;module name&gt;[,&lt;module name&gt;...]
                      limit the universe of observable modules
    --patch-module &lt;module&gt;=&lt;file&gt;(:&lt;file&gt;)*
                      override or augment a module with classes and resources
                      in JAR files or directories.
    --disable-@files  disable further argument file expansion
    --source &lt;version&gt;
                      set the version of the source in source-file mode.

These extra options are subject to change without notice.</pre>
</div>
</div>
<div class="paragraph">
<p>В некоторых вариантах часто используются:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-Xms &lt;size&gt;[unit]</code> (<code>g</code> для <strong>GB</strong>, <code>m</code> для <strong>MB</strong> и <code>k</code> для <strong>KB</strong>): для установки начального размера кучи при запуске JVM. По умолчанию: начальный размер кучи 1/64 физической памяти до 1 <strong>GB</strong>.</p>
</li>
<li>
<p><code>-Xmx &lt;size&gt;[unit]</code> (<code>g</code> для <strong>GB</strong>, <code>m</code> для <strong>MB</strong> и <code>k</code> для <strong>KB</strong>): для установки максимального размера кучи. По умолчанию: максимальный размер кучи составляет 1/4 физической памяти до 1 <strong>GB</strong>.</p>
</li>
<li>
<p><code>-Xss &lt;size&gt;[unit]</code> (<code>g</code> для <strong>GB</strong>, <code>m</code> для <strong>MB</strong> и <code>k</code> для <strong>KB</strong>): установить размер стека потока Java. Значение по умолчанию зависит от ОС. Это можно проверить через командную строку:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">java -XX: + PrintFlagsFinal -version | grep ThreadStackSize</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>     intx CompilerThreadStackSize                  = 1024                                   {pd product} {default}
     intx ThreadStackSize                          = 1024                                   {pd product} {default}
     intx VMThreadStackSize                        = 1024                                   {pd product} {default}
openjdk version "11.0.7" 2020-04-14
OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.7+10)
OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.7+10, mixed mode)</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_советы_для_повышения_производительности_при_разработке_веб_приложения">Советы для повышения производительности при разработке веб-приложения</h3>
<div class="ulist">
<ul>
<li>
<p>Следует ограничить, создание новых объектов и как можно скорее освободить память.</p>
</li>
<li>
<p>Использовать <strong>JVisualVM</strong> для мониторинга приложения перед релизом приложения на <strong>testing</strong>/<strong>staging</strong>/<strong>production</strong> <strong>environment</strong>.</p>
</li>
<li>
<p>Внимательно проверить сторонние библиотеки, перед использованием.</p>
</li>
<li>
<p>Изучить и применять лучшие практики борьбы с <strong>memory-leak</strong>: изменяемые статические поля и коллекции, локальные переменные потока, <strong>Circular and Complex Bi-Directional References</strong>, <code>ByteBuffer</code>, <code>BufferImage</code>, незакрытый поток, незакрытое соединение, &#8230;&#8203;</p>
</li>
<li>
<p>Внимательно проверять код.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_модульность_since_java_9">Модульность (@since Java 9)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>С выходом Java 9 появился новый уровень абстракции над пакетами, формально известный как <strong>Java Platform Module System</strong> (<strong>JPMS</strong>), или сокращенно <strong>Modules</strong>.</p>
</div>
<div class="sect2">
<h3 id="_что_такое_модуль">Что такое модуль?</h3>
<div class="paragraph">
<p>Прежде всего, нам нужно понять, что такое модуль, прежде чем его использовать.</p>
</div>
<div class="paragraph">
<p><strong>Модуль</strong> - это группа тесно связанных <strong>пакетов</strong> и <strong>ресурсов</strong> вместе с новым типом файла <strong>дескриптор модуля</strong> (<strong>module descriptor</strong>).</p>
</div>
<div class="paragraph">
<p>Другими словами, это абстракция <strong>пакет с Java-пакетами</strong>, которая позволяет сделать наш код более пригодным для повторного использования.</p>
</div>
<div class="sect3">
<h4 id="_пакеты">Пакеты</h4>
<div class="paragraph">
<p>Пакеты внутри модуля идентичны пакетам Java, которые Java поддерживает с момента создания.</p>
</div>
<div class="paragraph">
<p>Когда создается модуль (фактически: проект), то <strong>код внутри организуется по пакетам, в зависимости от предназначения классов и связей между ними</strong>.</p>
</div>
<div class="paragraph">
<p>Помимо организации нашего кода, пакеты используются для определения того, какой код является общедоступным за пределами модуля, т.е. определяется <strong>API</strong> для данного модуля.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ресурсы">Ресурсы</h4>
<div class="paragraph">
<p><strong>Каждый модуль отвечает за свои ресурсы</strong>, такие как медиа или конфигурационные файлы.</p>
</div>
<div class="paragraph">
<p>Ранешь их помещали в корневой уровень проекта и вручную управляли тем, какие ресурсы и к каким частям приложения относились.</p>
</div>
<div class="paragraph">
<p>С помощью модулей можно поставлять необходимые ресурсы вместе с тем модулем, которому они необходимые. Это значительно упрощает управление проектами.</p>
</div>
</div>
<div class="sect3">
<h4 id="_дескриптор_модуля">Дескриптор модуля</h4>
<div class="paragraph">
<p>При создании модуля в него включается <strong>файл дескриптора</strong>(<strong>descriptor file</strong>), который определяет несколько аспектов нового модуля:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Name</strong> - название модуля</p>
</li>
<li>
<p><strong>Dependencies</strong>  - список модулей, от которых зависит этот модуль</p>
</li>
<li>
<p><strong>Public Packages</strong> - список всех пакетов, которые можно получить вне этого модуля</p>
</li>
<li>
<p><strong>Services Offered</strong> - предоставляет реализацию услуг (<strong>implementation of service</strong>), для использования другими модулями</p>
</li>
<li>
<p><strong>Services Consumed</strong> - использует реализацию услуг из другого модуля</p>
</li>
<li>
<p><strong>Reflection Permissions</strong> - позволяет другим классам использовать <strong>Reflection API</strong> для доступа к <code>private</code> членам данного модуля</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Правила именования модулей похожи на правила именования пакетов (точки разрешены, а тире нет). Обычно используют имена в стиле:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>проекта (<code>my.module</code>)</p>
</li>
<li>
<p><code>Reverse-DNS</code> (<code>com.rakovets.mymodule</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Необходимо помнить, что нужно перечислить все пакеты:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>которые будут общедоступными, потому что по умолчанию все пакеты являются <strong>module private</strong></p>
</li>
<li>
<p>для которых будет доступна <strong>Reflection API</strong>, по тому что по умолчанию нельзя использовать рефлексию для классов, которые импортируются из другого модуля</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_типы_модулей">Типы модулей</h4>
<div class="paragraph">
<p>В новой модульной системе есть четыре типа модулей:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>System Modules</strong>  - это модули Java SE и JDK, которые можно увидеть с помощью команды <code>java --list-modules</code></p>
</li>
<li>
<p><strong>Application Modules</strong> - эти модули, которые необходимо использовать в текущем модуле. Они определены в скомпилированном  файле <code>module-info.class</code>, включенном в собранный JAR-file.</p>
</li>
<li>
<p><strong>Automatic Modules</strong> - это модули, которые включены в текущий неофициально, т.е. добавлением существующих JAR-файлов в путь к модулю. Название модуля будет производным от имени JAR-file. Эти модули будут иметь полный доступ для чтения ко всем аналогичным модулям</p>
</li>
<li>
<p><strong>Unnamed Module</strong>   - это универсальный модуль для обеспечения обратной совместимости с ранее написанным кодом Java. Он содержит классы или JAR-файлы загруженные в путь к классу, но не в путь к модулю</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_распространение_модуля">Распространение модуля</h4>
<div class="paragraph">
<p>Модули, как и любой другой Java-проект, можно распространять в виде:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JAR-файла</p>
</li>
<li>
<p>«скомпонованного» скомпилированного проекта</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Можно создавать многомодульные проекты, которые состоят из «основного приложения» и нескольких библиотечных модулей, но необходимо быть осторожны, потому что в JAR/project может быть только один модуль. Поэтому при настройке сборки (<strong>build</strong>), необходимо убедиться, что каждый модуль проекта упакован в отдельный JAR-файл.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_модули_по_умолчанию">Модули по умолчанию</h3>
<div class="paragraph">
<p>Когда мы устанавливаем Java 9, мы видим, что JDK теперь имеет новую структуру.</p>
</div>
<div class="paragraph">
<p>Они взяли все оригинальные пакеты и перенесли их в новую систему модулей.</p>
</div>
<div class="paragraph">
<p>Мы можем увидеть, что это за модули, набрав в командной строке:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">java --list-modules</code></pre>
</div>
</div>
<div class="paragraph">
<p>Эти модули разделены на четыре основные группы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java</code> - содержит модули являются классами реализации для основной спецификации языка SE</p>
</li>
<li>
<p><code>javafx</code> - содержит библиотеки пользовательского интерфейса FX</p>
</li>
<li>
<p><code>jdk</code> - содержит все, что необходимо JDK</p>
</li>
<li>
<p><code>oracle</code> - содержит проприетарный функционал от Oracle</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_объявления_модуля">Объявления модуля</h3>
<div class="paragraph">
<p>Чтобы создать модуль, нам нужно поместить специальный файл (<strong>дескриптор модуля</strong>/<strong>module descriptor</strong>) в корень наших пакетов с именем <code>module-info.java</code>. Он содержит всю информацию необходимую для построения и использования данного модуля.</p>
</div>
<div class="paragraph">
<p>Создание модуля с объявлением, тело которого либо пусто, либо содержит директивы модуля выглядит следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">module myModuleName {
    // all directives are optional
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Объявление модуля начинается с ключевого слова <code>module</code>, далее указывается имя модуля. Этого достаточно для работы данного модуля, но обычно необходимо использовать другие модули и для этого существую <strong>директивы</strong>(<strong>directives</strong>) модуля.</p>
</div>
<div class="sect3">
<h4 id="_директива_requires">Директива <code>requires</code></h4>
<div class="paragraph">
<p>Директива модуля <code>requires</code> позволяет объявлять зависимости модуля:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">module my.module {
    requires module.name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь <code>my.module</code> имеет доступ во время кампиляции (<strong>Compile-time</strong>) и выполнение (<strong>Runtime</strong>) к зависимому модулю <code>module.name</code>. Все <code>public</code> типы из зависимого модуля, доступны в текущем модуле, благодаря использованию директивы <code>requires</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_директива_requires_static">Директива <code>requires static</code></h4>
<div class="paragraph">
<p>Иногда созданный модуль ссылается на другой модуль, но пользователи нашей библиотеки не хотят его использовать.</p>
</div>
<div class="paragraph">
<p>Например, написана служебная функция, которая красиво печатает внутреннее состояние наших объектов, когда есть зависимость от какого-то модуля логирования. Но не каждый потребитель нашей библиотеки захочет эту функциональность, и они не хотят включать дополнительную библиотеку логирорования.</p>
</div>
<div class="paragraph">
<p>В этих случаях можно использовать необязательную зависимость. Используя директиву <code>require static</code>, создается зависимость только во время компиляции:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">module my.module {
    requires static module.name;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_директива_requires_transitive">Директива <code>requires transitive</code></h4>
<div class="paragraph">
<p>В разработке часто используют сторонние библиотеки, чтобы сделать разработку проще. Но тогда нужно убедиться, что любой модуль, который будет использовать текущий модуль, также внесет эти дополнительные «транзитивные» зависимости, иначе модуль не будет работать.</p>
</div>
<div class="paragraph">
<p>Для этого можно использовать директиву <code>requires transitive</code>, чтобы заставить любых последующих потребителей использовать требуемые для текущего модуля зависимости:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">module my.module {
    requires transitive module.name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь, когда кому-то необходим модуль <code>my.module</code>, то не требуется добавлять и <code>module.name</code> в зависимости для того, чтобы все работало корректно.</p>
</div>
</div>
<div class="sect3">
<h4 id="_директива_exports">Директива <code>exports</code></h4>
<div class="paragraph">
<p>По умолчанию, модуль не предоставляет API другим модулям. Эта <strong>сильная инкапсуляция</strong>(<strong>strong encapsulation</strong>) являлась одним из ключевых факторов для создания модульной системы и это делает код значительно более безопасным, но теперь нужно явно открывать API для потребителей.</p>
</div>
<div class="paragraph">
<p>Что бы открыть API из конкретного пакета используется директива <code>exports</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">module my.module {
    exports com.my.package.name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь у потребителей <code>my.module</code>, будет доступ к <code>public</code> типам из пакета <code>com.my.package.name</code>, но не из любого другом.</p>
</div>
</div>
<div class="sect3">
<h4 id="_директива_export_to">Директива <code>export &#8230;&#8203; to</code></h4>
<div class="paragraph">
<p>С помощью директивы <code>export</code> можно открыть API для потребителя, но что, если нужно, чтобы не все имели доступ к нашему API?</p>
</div>
<div class="paragraph">
<p>Можно ограничить то, какие модули имеют доступ к API. Для этого используется директива <code>export &#8230;&#8203; to</code>.</p>
</div>
<div class="paragraph">
<p>Подобно директиве <code>export</code>, объявляется какой пакет экспортировать, но так же перечисляется, каким модулям разрешаем импортировать этот пакет:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">module my.module {
    export com.my.package.name to com.specific.package;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_директива_uses">Директива <code>uses</code></h4>
<div class="paragraph">
<p><strong>Сервис</strong> обычно является реализацией определенного интерфейса или абстрактного класса, который может использоваться другими классами. Для обозначения сервисов, которые использует модуль, используется директива <code>uses</code>. Стоит обратить внимание, что в качестве имени класса мы используем интерфейс или абстрактный класс, который реализует <strong>service</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">module my.module {
    uses class.name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следует отметить, что существует разница между директивой <code>requires</code> и директивой <code>uses</code>.Когда в модуле содержится сервис, который необходимо использовать, но этот сервис реализует интерфейс или абстрактный класс одной из своих транзитивных зависимостей, тогда вместо использования директивы <code>requires</code> для всех транзитивных зависимостей, используется директива <code>uses</code> для добавления необходимого интерфейса или абстрактного класса к модулю.</p>
</div>
</div>
<div class="sect3">
<h4 id="_директива_provides_with">Директива <code>provides &#8230;&#8203; with</code></h4>
<div class="paragraph">
<p>Модуль может быть поставщиком сервиса, который могут использовать другие модули. Для данного случая применяют директиву <code>provides &#8230;&#8203; with</code></p>
</div>
<div class="paragraph">
<p>Директива содержит ключевое слово <code>provides</code>, после чего указывается имя интерфейса или абстрактного класса. Далее следует <code>with</code>, после которого указывается имя класса реализации для интерфейса, либо наследника для абстрактного класса.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">module my.module {
    provides MyInterface with MyInterfaceImpl;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_директива_open">Директива <code>open</code></h4>
<div class="paragraph">
<p>До Java 9 было возможно использовать <strong>Reflection API</strong> по отношению к любым классам, полям и методам, даже когда они имели модификатор доступа <code>private</code>, т.е. фактически реальной инкапсуляции небыло.</p>
</div>
<div class="paragraph">
<p>Поскольку Java 9 обеспечивает строгую инкапсуляцию, то теперь необходимо явно указать разрешение другим модулям использовать <strong>Reflection API</strong> по отношению к содержимому данного модулю.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">open module my.module {
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_директива_opens">Директива <code>opens</code></h4>
<div class="paragraph">
<p>Если необходимо разрешить использовать <strong>Reflection API</strong>, но не для всего модуля, то используется директивa <code>opens</code>, которая предоставит эту возможность к определенному пакету.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">module my.module {
  opens com.my.package;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_директива_opens_to">Директива <code>opens &#8230;&#8203; to</code></h4>
<div class="paragraph">
<p>Если необходима более сильная инкапсуляция, то можно выборочно открывать пакеты для указанных модулей. Для этого используют  директиву <code>opens &#8230;&#8203; to</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">module my.module {
    opens com.my.package to moduleOne, moduleTwo, etc.;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_параметры_командной_строки">Параметры командной строки</h3>
<div class="paragraph">
<p>В настоящее времени поддержка модулей Java 9 была добавлена ​​в <strong>Maven</strong> и <strong>Gradle</strong>, поэтому нет необходимости делать много ручной работы для сборки проектов. Однако полезно знать, как использовать систему модулей из командной строки. Для этого используют следующие параметры при работе в командной строке:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>module-path</code> - используется для указания пути к модулю. Список из одного или нескольких директорий, которые содержат необходимые модули</p>
</li>
<li>
<p><code>add-reads</code> - объявляет зависимость от модуля (аналогично директиве <code>requires</code>)</p>
</li>
<li>
<p><code>add-exports</code> - предоставляет доступ к API (аналогично директиве <code>exports</code>)</p>
</li>
<li>
<p><code>add-opens</code> - разрешает прмменение <strong>Reflection API</strong> (аналогично директиве <code>open</code>)</p>
</li>
<li>
<p><code>add-modules</code> - добавляет список модулей в набор модулей по умолчанию</p>
</li>
<li>
<p><code>list-modules</code> - выводит список всех модулей и их версий</p>
</li>
<li>
<p><code>patch-module</code> - добавляет или переопределяет классы в модулях</p>
</li>
<li>
<p><code>illegal-access=permit|warn|deny</code> - либо ослабляет сильную инкапсуляцию показывая одно глобальное предупреждение, либо показывает каждое предупреждение, либо выдает ошибку (по умолчанию <code>permit</code>)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_видимость">Видимость</h3>
<div class="paragraph">
<p>Многие библиотеки, что бы работать, зависят от возможности использования <strong>Reflection API</strong>, например: <strong>JUnit</strong> и <strong>Spring</strong>.</p>
</div>
<div class="paragraph">
<p>По умолчанию в Java 9 доступ предоставляется только к <code>public</code> классам, методам и полям в экспортируемых пакетах. Даже если использовать <strong>reflection</strong>, чтобы получить доступ к <code>private</code> членам с вызовом <code>setAccessible(true)</code>, то нельзя получить доступ к этим членам.</p>
</div>
<div class="paragraph">
<p>В таком случае можно использовать директивы <code>open</code>, <code>opens</code>, и <code>opens &#8230;&#8203; to</code> для предоставления доступа использовать <strong>reflection</strong> в <strong>Runtime</strong>. Однако не в <strong>compile-time</strong>.</p>
</div>
<div class="paragraph">
<p>Для этого у нас должен быть доступ к модулю. Когда же доступа к модулю нет (т.е. это сторонний модуль), тогда можно использовать параметр <code>-add-opens</code> в командной строке для предоставления доступа собственных модулей к инкапсулированному модулю в <strong>Runtime</strong>. Но необходимо помнить, что нужно иметь доступ к аргументам командной строки, которые используются для запуска модуля.</p>
</div>
</div>
<div class="sect2">
<h3 id="_создание_модуля_с_помощью_cli">Создание модуля с помощью CLI</h3>
<div class="sect3">
<h4 id="_создание_структуры_проекта">Создание структуры проекта</h4>
<div class="paragraph">
<p>Создадим несколько каталогов для организации файлов.</p>
</div>
<div class="paragraph">
<p>Создадим директорию с проектом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">mkdir module-project
cd module-project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это <strong>root</strong> директория проекта, поэтому она будет содержать в дальнейшем файлы сборки <strong>Maven</strong> или <strong>Gradle</strong>, другие <strong>source</strong> и <strong>resource</strong> директории.</p>
</div>
<div class="paragraph">
<p>Мы также поместили каталог для хранения всех модулей нашего проекта.</p>
</div>
<div class="paragraph">
<p>Далее создадим каталог модуля:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">mkdir simple-modules</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вот как будет выглядеть структура проекта:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-out" data-lang="out">module-project
|- // src if we use the default package
|- // build files also go at this level
+- simple-modules
  +- hello.modules
    +- com
      +- rakovets
        +- modules
          +- hello
  +- main.app
    +- com
      +- rakovets
        +- modules
          +- main</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_первый_модуль">Первый модуль</h4>
<div class="paragraph">
<p>Когда есть базовая структура, можно добавить первый модуль.</p>
</div>
<div class="paragraph">
<p>В директории <code>simple-modules</code> создадим новую директорию с именем <code>hello.modules</code> .</p>
</div>
<div class="paragraph">
<p>Ее можно назвать как угодно, но необходимо следовать правилам именования пакетов (т.е. точки для разделения пакетов и т.д.). Можно использовать имя основного пакета в качестве имени модуля, если необходимо, но обычно придерживаются того же имени, которое необходимо использовать при создании JAR-файла этого модуля.</p>
</div>
<div class="paragraph">
<p>В новом модуле можно создавать нужные пакеты. В текущем случае создим следующую структуру пакета:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-out" data-lang="out">com.rakovets.modules.hello</code></pre>
</div>
</div>
<div class="paragraph">
<p>Затем в этом пакете создадим новый класс с именем <code>HelloModules.java</code>. Этот клас будет содержать очень простой код:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.rakovets.modules.hello;

public class HelloModules {
    public static void doSomething() {
        System.out.println("Hello, Modules!");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Затем в корневой директори <code>hello.modules</code> добавим дескриптор модуля <code>module-info.java</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">module hello.modules {
    exports com.rakovets.modules.hello;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для простоты только экспортируем все открытые члены пакета <code>com.rakovets.modules.hello</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_второй_модуль">Второй модуль</h4>
<div class="paragraph">
<p>Первый самостоятельно ничего не делает. Создадим второй модуль, который будет использовать функционал первого.</p>
</div>
<div class="paragraph">
<p>В директории <code>simple-modules</code> создадим еще одну директорию для модуля с именем <code>main.app</code> и добавим дескриптор модуля:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">module main.app {
    requires hello.modules;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Второй модуль не будет предоставлять API, он только будет использовать первый модуль.</p>
</div>
<div class="paragraph">
<p>Для этого создадим новую структуру пакетов <code>com.rakovets.modules.main</code>.</p>
</div>
<div class="paragraph">
<p>Затем создадим новый файл класса с именем <code>MainApp.java</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.rakovets.modules.main;

import com.rakovets.modules.hello.HelloModules;

public class MainApp {
    public static void main(String[] args) {
        HelloModules.doSomething();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это продемонстрирует принцип создания модулей.</p>
</div>
</div>
<div class="sect3">
<h4 id="_сборка_модулей">Сборка модулей</h4>
<div class="paragraph">
<p>Что бы сделать <code>build</code> проекта, можно создать bash-скрипт и поместить его в корень проекта.</p>
</div>
<div class="paragraph">
<p>Создадим файл с именем <code>compile-simple-modules.sh</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">#!/usr/bin/env bash
javac -d outDir --module-source-path simple-modules $(find simple-modules -name "*.java")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Команда состоит из двух команд:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>javac</code> - компилирует все java-файлы, которые были найдены с помощью команды <code>find</code></p>
</li>
<li>
<p><code>find</code> - выводит список всех java-файлов в директории <code>simple-modules</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Единственное отличие от более старых версий Java, это необходимость предоставить параметр <code>module-source-path</code>, чтобы сообщить компилятору о том, что он делает <code>build</code> модулей.</p>
</div>
<div class="paragraph">
<p>Как только команда будет запущена, появится директория <code>outDir</code> с двумя скомпилированными модулями внутри.</p>
</div>
</div>
<div class="sect3">
<h4 id="_запуск">Запуск</h4>
<div class="paragraph">
<p>Что бы проверить работоспособность модулей необходимо запусти проект.</p>
</div>
<div class="paragraph">
<p>Создадим bash-скрипт в корне проекта `run-simple-module-app.sh:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">#!/usr/bin/env bash
java --module-path outDir -m main.app/com.rakovets.modules.main.MainApp</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы запустить модуль, необходимо указать путь к модулю и основному классу. Запустим и если все верно, то увидим:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">./run-simple-module-app.sh
Hello, Modules!</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_добавление_сервиса">Добавление сервиса</h4>
<div class="paragraph">
<p>Усложним проект, добавив в него <code>service</code>. Для этого используем директивы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>provides…with</code></p>
</li>
<li>
<p><code>uses</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Определим новый файл в модуле <code>hello.modules</code> с именем <code>HelloInterface.java</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface HelloInterface {
    void sayHello();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Реализуем интерфейс в существующем классе <code>HelloModules.java</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class HelloModules implements HelloInterface {
    public static void doSomething() {
        System.out.println("Hello, Modules!");
    }

    public void sayHello() {
        System.out.println("Hello!");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Необходимый <code>service</code> создан. Теперь необходимо указать что модуль предоставляет этот <code>service</code>. Для этого добавим в <code>module-info.java</code> следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">provides com.rakovets.modules.hello.HelloInterface with com.rakovets.modules.hello.HelloModules;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Т.е. объявили интерфейс и класс, который его реализует.</p>
</div>
<div class="paragraph">
<p>В модуле <code>main.app</code>, для использования этого <code>service</code> нужно добавить следующее в <code>module-info.java</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">uses com.rakovets.modules.hello.HelloInterface;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперо в <code>main</code> методе можно использовать этот <code>service</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">HelloModules module = new HelloModules();
module.sayHello();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Компилируем и запускаем:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">./run-simple-module-app.sh
Hello, Modules!
Hello!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так же можно поместить реализацию в приватный пакет, а интерфейс в публичный пакет. Это сделает наш код более безопасным при минимальных усилиях.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_добавление_модулей_в_unnamed_module">Добавление модулей в <strong>Unnamed Module</strong></h3>
<div class="paragraph">
<p>Концепция <strong>Unnamed Module</strong> похожа на пакет по умолчанию, поэтому его не следует считать реальным модулем, но можно рассматриваться как модуль по умолчанию.</p>
</div>
<div class="paragraph">
<p>Если класс не является членом других типов модулей, то он будет автоматически рассматриваться как часть <strong>Unnamed Module</strong>.</p>
</div>
<div class="paragraph">
<p>Иногда, чтобы обеспечить наличие определенных модулей платформы, библиотеки или поставщика услуг в графе модулей, нужно добавить модули в набор по умолчанию. Например, когда пытаемся работать с программами на Java 8 используя компилятор Java 9, тогда может потребоваться добавить модули.</p>
</div>
<div class="paragraph">
<p>Возможность добавления именованных модулей в набор корневых модулей по умолчанию выглядит  <code>-add-modules &lt;module&gt;, &#8230;&#8203;, &lt;module&gt;</code>,  где <code>&lt;module&gt;</code> - это имя модуля.</p>
</div>
<div class="paragraph">
<p>Например, чтобы обеспечить доступ всех модулей к модулю <code>java.xml.bind</code>, синтаксис должен быть следующим:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">--add-modules java.xml.bind</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы использовать это с помощью <strong>Maven</strong>, необходимо добавит это в конфигурацию для <code>maven-compiler-plugin</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.8.0&lt;/version&gt;
    &lt;configuration&gt;
        &lt;source&gt;9&lt;/source&gt;
        &lt;target&gt;9&lt;/target&gt;
        &lt;compilerArgs&gt;
            &lt;arg&gt;--add-modules&lt;/arg&gt;
            &lt;arg&gt;java.xml.bind&lt;/arg&gt;
        &lt;/compilerArgs&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-02-05 05:23:52 UTC
</div>
</div>
</body>
</html>