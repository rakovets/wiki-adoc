<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.15">
<title>Java Input/Output</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Java Input/Output</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_java_io">Java IO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Отличительной чертой многих языков программирования является работа с файлами и потоками. В Java основной функционал работы с потоками сосредоточен в классах из пакета <code>java.io</code>.</p>
</div>
<div class="paragraph">
<p>Ключевым понятием здесь является понятие <strong>потока</strong>. Хотя понятие "поток" в программировании довольно перегружено и может обозначать множество различных концепций. В данном случае применительно к работе с файлами и вводом-выводом будет говориться о <strong>потоке</strong> (<strong>stream</strong>), как об абстракции, которая используется для чтения или записи информации (файлов, сокетов, текста консоли и т.д.).</p>
</div>
<div class="paragraph">
<p><strong>Поток</strong> связан с реальным физическим устройством с помощью системы ввода-вывода Java. Может быть определен поток, который связан с файлом и через который можно вести чтение или запись файла. Это также может быть поток, связанный с сетевым сокетом, с помощью которого можно получить или отправить данные в сети. Все эти задачи: чтение и запись различных файлов, обмен информацией по сети, ввод-ввывод в консоли решаются в Java с помощью потоков.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../../assets/img/java/core/io/java-io.png" alt="Java IO"></span></p>
</div>
<div class="paragraph">
<p>Объект, из которого можно считать данные, называется <strong>потоком ввода</strong>, а объект, в который можно записывать данные, - <strong>потоком вывода</strong>. Например, если надо считать содержание файла, то применяется поток ввода, а если надо записать в файл - то поток вывода.</p>
</div>
<div class="paragraph">
<p>В основе всех классов, управляющих <strong>потоками байтов</strong>, находятся два абстрактных класса: <code>InputStream</code> (представляющий потоки ввода) и <code>OutputStream</code> (представляющий потоки вывода)</p>
</div>
<div class="paragraph">
<p>Но поскольку работать с байтами не очень удобно, то для работы с <strong>потоками символов</strong> были добавлены абстрактные классы <code>Reader</code> (для чтения потоков символов) и <code>Writer</code> (для записи потоков символов).</p>
</div>
<div class="paragraph">
<p>Все остальные классы, работающие с потоками, являются наследниками этих абстрактных классов. Основные классы потоков:</p>
</div>
<div class="paragraph">
<p>Byte Based:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Type</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Input</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Output</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Basic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">InputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OutputStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Arrays</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ByteArrayInputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ByteArrayOutputStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Files</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FileInputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FileOutputStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Files</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RandomAccessFile</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RandomAccessFile</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pipes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PipedInputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PipedOutputStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Buffering</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BufferedInputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BufferedOutputStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Filtering</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FilterInputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FilterOutputStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parsing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PushbackInputStream</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parsing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">StreamTokenizer</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Data</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DataInputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DataOutputStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Data-Formatted</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PrintStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Objects</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ObjectInputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ObjectOutputStream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Utilities</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SequenceInputStream</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Character Based:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Type</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Input</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Output</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Basic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Writer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Basic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">InputStreamReader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OutputStreamWriter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Arrays</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CharArrayReader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CharArrayWriter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Files</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FileReader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FileWriter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pipes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PipedReader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PipedWriter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Buffering</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BufferedReader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BufferedWriter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Filtering</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FilterReader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FilterWriter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parsing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PushbackReader</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parsing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LineNumberReader</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Strings</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">StringReader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">StringWriter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Data-Formatted</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PrintWriter</p></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_абстрактный_класс_inputstream">Абстрактный класс <code>InputStream</code></h3>
<div class="paragraph">
<p>Класс <code>InputStream</code> является базовым для всех классов, управляющих байтовыми потоками ввода. Рассмотрим его основные методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>int available()</code> возвращает количество байтов, доступных для чтения в потоке</p>
</li>
<li>
<p><code>void close()</code> закрывает поток</p>
</li>
<li>
<p><code>int read()</code> возвращает целочисленное представление следующего байта в потоке. Когда в потоке не останется доступных для чтения байтов, данный метод возвратит число <code>-1</code></p>
</li>
<li>
<p><code>int read(byte[] buffer)</code> считывает байты из потока в массив <code>buffer</code>. После чтения возвращает число считанных байтов. Если ни одного байта не было считано, то возвращается число <code>-1</code></p>
</li>
<li>
<p><code>int read(byte[] buffer, int offset, int length)</code> считывает некоторое количество байтов, равное <code>length</code>, из потока в массив <code>buffer</code>. При этом считанные байты помещаются в массиве, начиная со смещения <code>offset</code>, то есть с элемента <code>buffer[offset]</code>. Метод возвращает число успешно прочитанных байтов.</p>
</li>
<li>
<p><code>long skip(long number)</code> пропускает в потоке при чтении некоторое количество байт, которое равно <code>number</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_абстрактный_класс_outputstream">Абстрактный класс <code>OutputStream</code></h3>
<div class="paragraph">
<p>Класс <code>OutputStream</code> является базовым классом для всех классов, которые работают с бинарными потоками записи. Свою функциональность он реализует через следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void close()</code> закрывает поток</p>
</li>
<li>
<p><code>void flush()</code> очищает буфер вывода, записывая все его содержимое</p>
</li>
<li>
<p><code>void write(int b)</code> записывает в выходной поток один байт, который представлен целочисленным параметром <code>b</code></p>
</li>
<li>
<p><code>void write(byte[] buffer)</code> записывает в выходной поток массив байтов <code>buffer</code></p>
</li>
<li>
<p><code>void write(byte[] buffer, int offset, int length)</code> записывает в выходной поток некоторое число байтов, равное <code>length</code>, из массива <code>buffer</code>, начиная со смещения <code>offset</code>, то есть с элемента <code>buffer[offset]</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_абстрактный_класс_reader">Абстрактный класс <code>Reader</code></h4>
<div class="paragraph">
<p>Абстрактный класс <code>Reader</code> предоставляет функционал для чтения текстовой информации. Рассмотрим его основные методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>absract void close()</code> закрывает поток ввода</p>
</li>
<li>
<p><code>int read()</code> возвращает целочисленное представление следующего символа в потоке. Если таких символов нет, и достигнут конец файла, то возвращается число <code>-1</code></p>
</li>
<li>
<p><code>int read(char[] buffer)</code> считывает в массив <code>buffer</code> из потока символы, количество которых равно длине массива <code>buffer</code>. Возвращает количество успешно считанных символов. При достижении конца файла возвращает <code>-1</code></p>
</li>
<li>
<p><code>int read(CharBuffer buffer)</code> считывает в объект <code>CharBuffer</code> из потока символы. Возвращает количество успешно считанных символов. При достижении конца файла возвращает <code>-1</code></p>
</li>
<li>
<p><code>absract int read(char[] buffer, int offset, int count)</code> считывает в массив <code>buffer</code>, начиная со смещения <code>offset</code>, из потока символы, количество которых равно <code>count</code></p>
</li>
<li>
<p><code>long skip(long count)</code> пропускает количество символов, равное <code>count</code>. Возвращает число успешно пропущенных символов</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_абстрактный_класс_writer">Абстрактный класс <code>Writer</code></h3>
<div class="paragraph">
<p>Класс <code>Writer</code> определяет функционал для всех символьных потоков вывода. Его основные методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Writer append(char c)</code> добавляет в конец выходного потока символ <code>c</code>. Возвращает объект <code>Writer</code></p>
</li>
<li>
<p><code>Writer append(CharSequence chars)</code> добавляет в конец выходного потока набор символов <code>chars</code>. Возвращает объект <code>Writer</code></p>
</li>
<li>
<p><code>abstract void close()</code> закрывает поток</p>
</li>
<li>
<p><code>abstract void flush()</code> очищает буферы потока</p>
</li>
<li>
<p><code>void write(int c)</code> записывает в поток один символ, который имеет целочисленное представление</p>
</li>
<li>
<p><code>void write(char[] buffer)</code> записывает в поток массив символов</p>
</li>
<li>
<p><code>absract void write(char[] buffer, int off, int len) ` записывает в поток только несколько символов из массива `buffer</code>. Причем количество символов равно <code>len</code>, а отбор символов из массива начинается с индекса <code>off</code></p>
</li>
<li>
<p><code>void write(String str)</code> записывает в поток строку</p>
</li>
<li>
<p><code>void write(String str, int off, int len)</code> записывает в поток из строки некоторое количество символов, которое равно <code>len</code>, причем отбор символов из строки начинается с индекса <code>off</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_интерфейс_closeable">Интерфейс <code>Closeable</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>При завершении работы с потоком его надо закрыть с помощью метода <code>close()</code>, который определен в интерфейсе <code>Closeable</code>. Метод <code>close</code> имеет следующее определение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">void close() throws IOException</code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот интерфейс уже реализуется в классах <code>InputStream</code> и <code>OutputStream</code>, а через них и во всех классах потоков.</p>
</div>
<div class="paragraph">
<p>При закрытии потока освобождаются все выделенные для него ресурсы, например, файл. В случае, если поток окажется не закрыт, может происходить утечка памяти.</p>
</div>
<div class="paragraph">
<p>Есть два способа закрытия файла:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>использование блока <code>try..catch..finally</code></p>
</li>
<li>
<p>использование конструкции <code>try-with-resource</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Используем первый (традиционный) способ и считаем данные из файла:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.FileInputStream;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        FileInputStream fin = null;
        try {
            fin = new FileInputStream("C://SomeDir//notes.txt");
            int i = -1;
            while ((i = fin.read()) != -1) {
                System.out.print((char) i);
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        } finally {
            try {
                if (fin != null)
                    fin.close();
            } catch (IOException ex) {
                System.out.println(ex.getMessage());
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Поскольку при открытии или считывании файла может произойти ошибка ввода-вывода, то код считывания помещается в блок <code>try</code>. И чтобы быть уверенным, что поток в любом случае закроется, даже если при работе с ним возникнет ошибка, вызов метода <code>close()</code> помещается в блок <code>finally</code>. И, так как метод <code>close()</code> также в случае ошибки может генерировать исключение <code>IOException</code>, то его вызов также помещается во вложенный блок <code>try..catch</code>.</p>
</div>
<div class="paragraph">
<p>Начиная с Java 7 можно использовать второй способ, который автоматически вызывает метод <code>close</code>. Этот способ заключается в использовании конструкции <strong>try-with-resources</strong> (<strong>try с ресурсами</strong>). Данная конструкция работает с объектами, которые реализуют интерфейс <code>AutoCloseable</code>. Так как все классы потоков реализуют интерфейс <code>Closeable</code>, который в свою очередь наследуется от <code>AutoCloseable</code>, то их также можно использовать в данной конструкции.</p>
</div>
<div class="paragraph">
<p>Предыдущий пример с использованием конструкции <strong>try-with-resources</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.FileInputStream;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        try (FileInputStream fin = new FileInputStream("C://SomeDir//notes.txt")) {
            int i = -1;
            while ((i = fin.read()) != -1) {
                System.out.print((char) i);
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Синтаксис конструкции следующий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try(название_класса имя_переменной = конструктор_класса) {
    // code
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Данная конструкция также не исключает использования блоков <code>catch</code>.</p>
</div>
<div class="paragraph">
<p>После окончания работы в блоке <code>try</code> у ресурса (в данном случае у объекта <code>FileInputStream</code>) автоматически вызывается метод <code>close()</code>.</p>
</div>
<div class="paragraph">
<p>Если нам надо использовать несколько потоков, которые после выполнения надо закрыть, то мы можем указать объекты потоков через точку с запятой:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try (FileInputStream fin = new FileInputStream("C://SomeDir//Hello.txt");
        FileOutputStream fos = new FileOutputStream("C://SomeDir//Hello2.txt")) {
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_класс_file">Класс <code>File</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Класс <code>File</code>, определенный в пакете <code>java.io</code>, не работает напрямую с потоками. Его задачей является управление информацией о файлах и директориях. Хотя на уровне операционной системы файлы и директории отличаются, но в Java они описываются одним классом <code>File</code>.</p>
</div>
<div class="paragraph">
<p>В зависимости от того, что должен представлять объект <code>File</code> - файл или директория, мы можем использовать один из конструкторов для создания объекта:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>File(String путь_к_директории)</code></p>
</li>
<li>
<p><code>File(String путь_к_директории, String имя_файла)</code></p>
</li>
<li>
<p><code>File(File каталог, String имя_файла)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// создаем объект File для директории
File dir1 = new File("C://SomeDir");
// создаем объекты для файлов, которые находятся в директории
File file1 = new File("C://SomeDir", "Hello.txt");
File file2 = new File(dir1, "Hello2.txt");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Класс <code>File</code> имеет ряд методов, которые позволяют управлять файлами и директориями. Рассмотрим некоторые из них:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boolean createNewFile()</code> создает новый файл по пути, который передан в конструктор. В случае удачного создания возвращает <code>true</code>, иначе <code>false</code></p>
</li>
<li>
<p><code>boolean delete()</code> удаляет директорию или файл по пути, который передан в конструктор. При удачном удалении возвращает <code>true</code></p>
</li>
<li>
<p><code>boolean exists()</code> проверяет, существует ли по указанному в конструкторе пути файл или директория. И если файл или директория существует, то возвращает <code>true</code>, иначе возвращает <code>false</code></p>
</li>
<li>
<p><code>String getAbsolutePath()</code> возвращает абсолютный путь для пути, переданного в конструктор объекта</p>
</li>
<li>
<p><code>String getName()</code> возвращает краткое имя файла или директории</p>
</li>
<li>
<p><code>String getParent()</code> возвращает имя родительской директории</p>
</li>
<li>
<p><code>boolean isDirectory()</code> возвращает значение <code>true</code>, если по указанному пути располагается директория</p>
</li>
<li>
<p><code>boolean isFile()</code> возвращает значение <code>true</code>, если по указанному пути находится файл</p>
</li>
<li>
<p><code>boolean isHidden()</code> возвращает значение <code>true</code>, если директория или файл являются скрытыми</p>
</li>
<li>
<p><code>long length()</code> возвращает размер файла в байтах</p>
</li>
<li>
<p><code>long lastModified()</code> возвращает время последнего изменения файла или директории. Значение представляет количество миллисекунд, прошедших с начала эпохи <strong>Unix</strong></p>
</li>
<li>
<p><code>String[] list()</code> возвращает массив файлов и поддиректорий, которые находятся в определенной директории</p>
</li>
<li>
<p><code>File[] listFiles()</code> возвращает массив файлов и поддиректорий, которые находятся в определенной директории</p>
</li>
<li>
<p><code>boolean mkdir()</code> создает новую директорию и при удачном создании возвращает значение <code>true</code></p>
</li>
<li>
<p><code>boolean renameTo(File dest)</code> переименовывает файл или директорию</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_работа_с_директориями">Работа с директориями</h3>
<div class="paragraph">
<p>Если объект <code>File</code> представляет директорию, то его метод <code>isDirectory()</code> возвращает <code>true</code>. И поэтому мы можем получить ее содержимое - вложенные поддиректории и файлы с помощью методов <code>list()</code> и <code>listFiles()</code>. Получим все поддиректории и файлы в определенной директории:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.File;

public class Program {
    public static void main(String[] args) {
        // определяем объект для каталога
        File dir = new File("C://SomeDir");
        // если объект представляет каталог
        if (dir.isDirectory()) {
            // получаем все вложенные объекты в каталоге
            for (File item : dir.listFiles()) {
                if (item.isDirectory()) {
                    System.out.println(item.getName() + "  \t folder");
                } else {
                    System.out.println(item.getName() + "\t file");
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь выполним еще ряд операций с директорией, как удаление, переименование и создание:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.File;

public class Program {
    public static void main(String[] args) {
        // определяем объект для каталога
        File dir = new File("C://SomeDir//NewDir");
        boolean created = dir.mkdir();
        if (created) {
            System.out.println("Folder has been created");
        }
        // переименуем каталог
        File newDir = new File("C://SomeDir//NewDirRenamed");
        dir.renameTo(newDir);
        // удалим каталог
        boolean deleted = newDir.delete();
        if (deleted) {
            System.out.println("Folder has been deleted");
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_работа_с_файлами">Работа с файлами</h3>
<div class="paragraph">
<p>Работа с файлами аналогична работе с директориями. Например, получим данные по одному из файлов и создадим еще один файл:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.File;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        // определяем объект для каталога
        File myFile = new File("C://SomeDir//notes.txt");
        System.out.println("File name: " + myFile.getName());
        System.out.println("Parent folder: " + myFile.getParent());
        if (myFile.exists()) {
            System.out.println("File exists");
        } else {
            System.out.println("File not found");
        }

        System.out.println("File size: " + myFile.length());
        if (myFile.canRead()) {
            System.out.println("File can be read");
        } else {
            System.out.println("File can not be read");
        }

        if (myFile.canWrite()) {
            System.out.println("File can be written");
        } else {
            System.out.println("File can not be written");
        }
        // создадим новый файл
        File newFile = new File("C://SomeDir//MyFile");
        try {
            boolean created = newFile.createNewFile();
            if (created) {
                System.out.println("File has been created");
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>При создании нового файла метод <code>createNewFile()</code> в случае неудачи выбрасывает исключение <code>IOException</code>, поэтому нам надо его отлавливать, например, в блоке <code>try&#8230;&#8203;catch</code>, как делается в примере выше.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_классы_fileoutputstream_и_fileinputstream">Классы <code>FileOutputStream</code> и <code>FileInputStream</code></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_запись_файлов_и_класс_fileoutputstream">Запись файлов и класс <code>FileOutputStream</code></h3>
<div class="paragraph">
<p>Класс <code>FileOutputStream</code> предназначен для записи байтов в файл. Он является производным от класса <code>OutputStream</code>, поэтому наследует всю его функциональность.</p>
</div>
<div class="paragraph">
<p>Через конструктор класса <code>FileOutputStream</code> задается файл, в который производится запись. Класс поддерживает несколько конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FileOutputStream(String filePath)</code></p>
</li>
<li>
<p><code>FileOutputStream(File fileObj)</code></p>
</li>
<li>
<p><code>FileOutputStream(String filePath, boolean append)</code></p>
</li>
<li>
<p><code>FileOutputStream(File fileObj, boolean append)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Файл задается либо через строковый путь, либо через объект <code>File</code>. Второй параметр - <code>append</code> задает способ записи: eсли он равен <code>true</code>, то данные дозаписываются в конец файла, а при <code>false</code> - файл полностью перезаписывается</p>
</div>
<div class="paragraph">
<p>Например, запишем в файл строку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.FileOutputStream;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        String text = "Hello world!"; // строка для записи
        try (FileOutputStream fos = new FileOutputStream("C://SomeDir//notes.txt")) {
            byte[] buffer = text.getBytes(); // перевод строки в байты
            fos.write(buffer, 0, buffer.length);
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
        System.out.println("The file has been written");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для создания объекта <code>FileOutputStream</code> используется конструктор, принимающий в качестве параметра путь к файлу для записи. Если такого файла нет, то он автоматически создается при записи. Так как здесь записываем строку, то ее надо сначала перевести в массив байтов. И с помощью метода <code>write()</code> строка записывается в файл.</p>
</div>
<div class="paragraph">
<p>Для автоматического закрытия файла и освобождения ресурса объект <code>FileOutputStream</code> создается с помощью конструктции <code>try&#8230;&#8203;catch</code>.</p>
</div>
<div class="paragraph">
<p>При этом необязательно записывать весь массив байтов. Используя перегрузку метода <code>write()</code>, можно записать и одиночный байт:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">fos.write(buffer[0]); // запись первого байта</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_чтение_файлов_и_класс_fileinputstream">Чтение файлов и класс <code>FileInputStream</code></h3>
<div class="paragraph">
<p>Для считывания данных из файла предназначен класс <code>FileInputStream</code>, который является наследником класса <code>InputStream</code> и поэтому реализует все его методы.</p>
</div>
<div class="paragraph">
<p>Для создания объекта <code>FileInputStream</code> мы можем использовать ряд конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FileInputStream(File file)</code> открывает соединение с файлом, <code>file</code> является <code>Object</code> типа <code>File</code> к считываемому файлу</p>
</li>
<li>
<p><code>​​FileInputStream(FileDescriptor fdObj)</code> используя файловый дескриптор <code>fdObj</code>, который представляет существующее соединение с файлом в файловой системе</p>
</li>
<li>
<p><code>FileInputStream(String name)</code> открывает соединение с файлом, <code>name</code> является путем к считываемому файлу</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если файл не может быть открыт, например, по указанному пути такого файла не существует, то генерируется исключение <code>FileNotFoundException</code>.</p>
</div>
<div class="paragraph">
<p>Считаем данные из ранее записанного файла и выведем на консоль:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.FileInputStream;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        try (FileInputStream fin = new FileInputStream("C://SomeDir//notes.txt")) {
            System.out.printf("File size: %d bytes \n", fin.available());
            int i = -1;
            while ((i = fin.read()) != -1) {
                System.out.print((char) i);
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае мы считываем каждый отдельный байт в переменную <code>i</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">while ((i = fin.read()) != -1) {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Когда в потоке больше нет данных для чтения, метод возвращает число <code>-1</code>.</p>
</div>
<div class="paragraph">
<p>Затем каждый считанный байт конвертируется в объект типа <code>char</code> и выводится на консоль.</p>
</div>
<div class="paragraph">
<p>Подобным образом можно считать данные в массив байтов и затем производить с ним манипуляции:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">byte[] buffer = new byte[fin.available()]; // считаем файл в буфер
fin.read(buffer, 0, fin.available());
System.out.println("File data:");
for (int i = 0; i &lt; buffer.length; i++) {
    System.out.print((char) buffer[i]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Совместим оба класса и выполним чтение из одного и запись в другой файл:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        try (FileInputStream fin = new FileInputStream("C://SomeDir//notes.txt");
             FileOutputStream fos = new FileOutputStream("C://SomeDir//notes_new.txt")) {
            byte[] buffer = new byte[fin.available()]; // считываем буфер
            fin.read(buffer, 0, buffer.length); // записываем из буфера в файл
            fos.write(buffer, 0, buffer.length);
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Классы <code>FileInputStream</code> и <code>FileOutputStream</code> предназначены прежде всего для записи двоичных файлов, то есть для записи и чтения байтов. И хотя они также могут использоваться для работы с текстовыми файлами, но все же для этой задачи больше подходят другие классы.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_классы_bytearrayinputstream_и_bytearrayoutputstream">Классы <code>ByteArrayInputStream</code> и <code>ByteArrayOutputStream</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для работы с массивами байтов - их чтения и записи используются классы <code>ByteArrayInputStream</code> и <code>ByteArrayOutputStream</code>.</p>
</div>
<div class="sect2">
<h3 id="_чтение_массива_байтов_и_класс_bytearrayinputstream">Чтение массива байтов и класс <code>ByteArrayInputStream</code></h3>
<div class="paragraph">
<p>Класс ByteArrayInputStream представляет входной поток, использующий в качестве источника данных массив байтов. Он имеет следующие конструкторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ByteArrayInputStream(byte[] buf)</code></p>
</li>
<li>
<p><code>ByteArrayInputStream(byte[] buf, int offset, int length)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В качестве параметров конструкторы используют массив байтов <code>buf</code>, из которого производится считывание, смещение относительно начала массива <code>offset</code> и количество считываемых символов <code>length</code>.</p>
</div>
<div class="paragraph">
<p>Считаем массив байтов и выведем его на экран:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.ByteArrayInputStream;

public class Program {
    public static void main(String[] args) {
        byte[] array1 = new byte[] {1, 3, 5, 7};
        ByteArrayInputStream byteStream1 = new ByteArrayInputStream(array1);
        int b;
        while ((b = byteStream1.read()) != -1) {
            System.out.println(b);
        }
        String text = "Hello world!";
        byte[] array2 = text.getBytes();
        ByteArrayInputStream byteStream2 = new ByteArrayInputStream(array2, 0, 5); // считываем 5 символов
        int c;
        while ((c = byteStream2.read()) != -1) {
            System.out.println((char) c);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В отличие от других классов потоков для закрытия объекта <code>ByteArrayInputStream</code> не требуется вызывать метод <code>close()</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_запись_массива_байт_и_класс_bytearrayoutputstream">Запись массива байт и класс <code>ByteArrayOutputStream</code></h3>
<div class="paragraph">
<p>Класс <code>ByteArrayOutputStream</code> представляет поток вывода, использующий массив байтов в качестве места вывода.</p>
</div>
<div class="paragraph">
<p>Чтобы создать объект данного класса, мы можем использовать один из его конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ByteArrayOutputStream()</code></p>
</li>
<li>
<p><code>ByteArrayOutputStream(int size)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Первая версия создает массив для хранения байтов длиной в <strong>32 байта</strong>, а вторая версия создает массив длиной <code>size</code>.</p>
</div>
<div class="paragraph">
<p>Рассмотрим применение класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.ByteArrayOutputStream;

public class Program {
    public static void main(String[] args) {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        String text = "Hello Wolrd!";
        byte[] buffer = text.getBytes();
        try {
            baos.write(buffer);
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        System.out.println(baos.toString()); // превращаем массив байтов в строку
        byte[] array = baos.toByteArray(); // получаем массив байтов и выводим по символьно
        for (byte b : array) {
            System.out.print((char) b);
        }
        System.out.println();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как и в других потоках вывода в классе <code>ByteArrayOutputStream</code> определен метод <code>write()</code>, который записывает в поток некоторые данные. В данном случае мы записываем в поток массив байтов. Этот массив байтов записывается в объекте <code>ByteArrayOutputStream</code> в защищенное поле <code>buf</code>, которое представляет также массив байтов <code>(protected byte[] buf)</code>.</p>
</div>
<div class="paragraph">
<p>Так как метод <code>write()</code> может сгенерировать исключение, то вызов этого метода помещается в блок <code>try&#8230;&#8203;catch</code>.</p>
</div>
<div class="paragraph">
<p>Используя методы <code>toString()</code> и <code>toByteArray()</code>, можно получить массив байтов <code>buf</code> в виде текста или непосредственно в виде массива байт.</p>
</div>
<div class="paragraph">
<p>С помощью метода <code>writeTo()</code> мы можем вывести массив байт в другой поток. Данный метод в качестве параметра принимает объект <code>OutputStream</code>, в который производится запись массива байт:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ByteArrayOutputStream baos = new ByteArrayOutputStream();
String text = "Hello Wolrd!";
byte[] buffer = text.getBytes();
try {
    baos.write(buffer);
} catch (Exception ex) {
    System.out.println(ex.getMessage());
}
try (FileOutputStream fos = new FileOutputStream("hello.txt")) {
    baos.writeTo(fos);
} catch (IOException e) {
    System.out.println(e.getMessage());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>После выполнения этой программы в папке с программой появится файл <code>hello.txt</code>, который будет содержать строку <code>Hello Wolrd!</code>.</p>
</div>
<div class="paragraph">
<p>И в заключении также надо сказать, что как и для объектов <code>ByteArrayInputStream</code>, для <code>ByteArrayOutputStream</code> не надо явным образом закрывать поток с помощью метода <code>close()</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_классы_bufferedinputstream_and_bufferedoutputstream">Классы <code>BufferedInputStream</code> and <code>BufferedOutputStream</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для оптимизации операций ввода-вывода используются буферизуемые потоки. Эти потоки добавляют к стандартным специальный буфер в памяти, с помощью которого повышается производительность при чтении и записи потоков.</p>
</div>
<div class="sect2">
<h3 id="_класс_bufferedinputstream">Класс <code>BufferedInputStream</code></h3>
<div class="paragraph">
<p>Класс <code>BufferedInputStream</code> накапливает вводимые данные в специальном буфере без постоянного обращения к устройству ввода. Класс <code>BufferedInputStream</code> определяет два конструктора:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BufferedInputStream(InputStream inputStream)</code></p>
</li>
<li>
<p><code>BufferedInputStream(InputStream inputStream, int bufSize)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Первый параметр - это поток ввода, с которого данные будут считываться в буфер. Второй параметр - размер буфера.</p>
</div>
<div class="paragraph">
<p>Например, буферизируем считывание данных из потока <code>ByteArrayInputStream</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;

public class Program {
    public static void main(String[] args) {
        String text = "Hello world!";
        byte[] buffer = text.getBytes();
        ByteArrayInputStream in = new ByteArrayInputStream(buffer);
        try (BufferedInputStream bis = new BufferedInputStream(in)) {
            int c;
            while ((c = bis.read()) != -1) {
                System.out.print((char) c);
            }
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        System.out.println();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Класс <code>BufferedInputStream</code> в конструкторе принимает объект <code>InputStream</code>. В данном случае таким объектом является экземпляр класса <code>ByteArrayInputStream</code>.</p>
</div>
<div class="paragraph">
<p>Как и все потоки ввода <code>BufferedInputStream</code> обладает методом <code>read()</code>, который считывает данные. И здесь мы считываем с помощью метода <code>read()</code> каждый байт из массива <code>buffer</code>.</p>
</div>
<div class="paragraph">
<p>Фактические все то же самое можно было сделать и с помощью одного <code>ByteArrayInputStream</code>, не прибегая к буферизированному потоку. Класс <code>BufferedInputStream</code> просто оптимизирует производительность при работе с потоком <code>ByteArrayInputStream</code>. Естественно вместо <code>ByteArrayInputStream</code> может использоваться любой другой класс, который унаследован от <code>InputStream</code>.</p>
</div>
<div class="sect3">
<h4 id="_класс_bufferedoutputstream">Класс <code>BufferedOutputStream</code></h4>
<div class="paragraph">
<p>Класс <code>BufferedOutputStream</code> аналогично создает буфер для потоков вывода. Этот буфер накапливает выводимые байты без постоянного обращения к устройству. И когда буфер заполнен, производится запись данных.</p>
</div>
<div class="paragraph">
<p><code>BufferedOutputStream</code> определяет два конструктора:
- <code>BufferedOutputStream(OutputStream outputStream)</code>
- <code>BufferedOutputStream(OutputStream outputStream, int bufSize)</code></p>
</div>
<div class="paragraph">
<p><code>outputStream</code> - это поток вывода, который унаследован от <code>OutputStream</code>, а <code>bufSize</code> - размер буфера.</p>
</div>
<div class="paragraph">
<p>Рассмотрим на примере записи в файл:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        String text = "Hello world!"; // строка для записи
        try (FileOutputStream out = new FileOutputStream("notes.txt");
             BufferedOutputStream bos = new BufferedOutputStream(out)) {
            byte[] buffer = text.getBytes(); // перевод строки в байты
            bos.write(buffer, 0, buffer.length);
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Класс <code>BufferedOutputStream</code> в конструкторе принимает в качестве параметра объект <code>OutputStream</code> - в данном случае это файловый поток вывода <code>FileOutputStream</code>. И также производится запись в файл. Опять же <code>BufferedOutputStream</code> не добавляет много новой функциональности, он просто оптимизирует действие потока вывода.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_классы_dataoutputstream_и_datainputstream">Классы <code>DataOutputStream</code> и <code>DataInputStream</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Классы <code>DataOutputStream</code> и <code>DataInputStream</code> позволяют записывать и считывать данные примитивных типов.</p>
</div>
<div class="sect2">
<h3 id="_запись_данных_и_dataoutputstream">Запись данных и <code>DataOutputStream</code></h3>
<div class="paragraph">
<p>Класс <code>DataOutputStream</code> представляет поток вывода и предназначен для записи данных примитивных типов. Для записи каждого из примитивных типов предназначен свой метод:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>writeBoolean(boolean v)</code> записывает в поток булевое однобайтовое значение</p>
</li>
<li>
<p><code>writeByte(int v)</code> записывает в поток 1 байт, которые представлен в виде целочисленного значения</p>
</li>
<li>
<p><code>writeChar(int v)</code> записывает 2-байтовое значение <code>char</code></p>
</li>
<li>
<p><code>writeDouble(double v)</code> записывает в поток 8-байтовое значение <code>double</code></p>
</li>
<li>
<p><code>writeFloat(float v)</code> записывает в поток 4-байтовое значение <code>float</code></p>
</li>
<li>
<p><code>writeInt(int v)</code> записывает в поток целочисленное значение <code>int</code></p>
</li>
<li>
<p><code>writeLong(long v)</code> записывает в поток значение <code>long</code></p>
</li>
<li>
<p><code>writeShort(int v)</code> записывает в поток значение <code>short</code></p>
</li>
<li>
<p><code>writeUTF(String str)</code> записывает в поток строку в кодировке <code>UTF-8</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_считывание_данных_и_datainputstream">Считывание данных и <code>DataInputStream</code></h3>
<div class="paragraph">
<p>Класс <code>DataInputStream</code> действует противоположным образом - он считывает из потока данные примитивных типов. Соответственно для каждого примитивного типа определен свой метод для считывания:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boolean readBoolean()</code> считывает из потока булевое однобайтовое значение</p>
</li>
<li>
<p><code>byte readByte()</code> считывает из потока 1 байт</p>
</li>
<li>
<p><code>char readChar()</code> считывает из потока значение <code>char</code></p>
</li>
<li>
<p><code>double readDouble()</code> считывает из потока 8-байтовое значение <code>double</code></p>
</li>
<li>
<p><code>float readFloat()</code> считывает из потока 4-байтовое значение <code>float</code></p>
</li>
<li>
<p><code>int readInt()</code> считывает из потока целочисленное значение <code>int</code></p>
</li>
<li>
<p><code>long readLong()</code> считывает из потока значение <code>long</code></p>
</li>
<li>
<p><code>short readShort()</code> считывает значение <code>short</code></p>
</li>
<li>
<p><code>String readUTF()</code> считывает из потока строку в кодировке <code>UTF-8</code></p>
</li>
<li>
<p><code>int skipBytes(int n)</code> пропускает при чтении из потока n байтов</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Рассмотрим применение классов на примере:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.*;

public class Program {
    public static void main(String[] args) {
        Person tom = new Person("Tom", 34, 1.68, false);
        // запись в файл
        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream("data.bin"))) {
            dos.writeUTF(tom.name);
            dos.writeInt(tom.age);
            dos.writeDouble(tom.height);
            dos.writeBoolean(tom.married);
            System.out.println("File has been written");
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }

        // обратное считывание из файла
        try (DataInputStream dos = new DataInputStream(new FileInputStream("data.bin"))) {
            String name = dos.readUTF();
            int age = dos.readInt();
            double height = dos.readDouble();
            boolean married = dos.readBoolean();
            System.out.printf("Name: %s  Age: %d  Height: %f  Married: %b", name, age, height, married);
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {
    public String name;
    public int age;
    public double height;
    public boolean married;

    public Person(String n, int a, double h, boolean m) {
        this.name = n;
        this.height = h;
        this.age = a;
        this.married = m;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь мы последовательно записываем в файл данные объекта <code>Person</code>.</p>
</div>
<div class="paragraph">
<p>Объект <code>DataOutputStream</code> в конструкторе принимает поток вывода: <code>DataOutputStream(OutputStream out)</code>. В данном случае в качестве потока вывода используется объект <code>FileOutputStream</code>, поэтому вывод будет происходить в файл. И с помощью выше рассмотренных методов типа <code>writeUTF()</code> производится запись значений в бинарный файл.</p>
</div>
<div class="paragraph">
<p>Затем происходит чтение ранее записанных данных. Объект <code>DataInputStream</code> в конструкторе принимает поток для чтения: <code>DataInputStream(InputStream in)</code>. Здесь таким потоком выступает объект <code>FileInputStream</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_классы_printstream_и_printwriter">Классы <code>PrintStream</code> и <code>PrintWriter</code></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_класс_printstream">Класс <code>PrintStream</code></h3>
<div class="paragraph">
<p>Класс <code>PrintStream</code> - это именно тот класс, который используется для вывода на консоль. Когда мы выводим на консоль некоторую информацию с помощью вызова <code>System.out.println()</code>, то тем самым мы задействует <code>PrintStream</code>, так как переменная <code>out</code> в классе <code>System</code> как раз и представляет объект класса <code>PrintStream</code>, а метод <code>println()</code> - это метод класса <code>PrintStream</code>.</p>
</div>
<div class="paragraph">
<p>Но <code>PrintStream</code> полезен не только для вывода на консоль. Мы можем использовать данный класс для записи информации в поток вывода. Для этого <code>PrintStream</code> определяет ряд конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PrintStream(OutputStream outputStream)</code></p>
</li>
<li>
<p><code>PrintStream(OutputStream outputStream, boolean autoFlushingOn)</code></p>
</li>
<li>
<p><code>PrintStream(OutputStream outputStream, boolean autoFlushingOn, String charSet) throws UnsupportedEncodingException</code></p>
</li>
<li>
<p><code>PrintStream(File outputFile) throws FileNotFoundException</code></p>
</li>
<li>
<p><code>PrintStream(File outputFile, String charSet) throws FileNotFoundException, UnsupportedEncodingException</code></p>
</li>
<li>
<p><code>PrintStream(String outputFileName) throws FileNotFoundException</code></p>
</li>
<li>
<p><code>PrintStream(String outputFileName, String charSet) throws FileNotFoundException, UnsupportedEncodingException</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Параметр <code>outputStream</code> - это объект <code>OutputStream</code>, в который производится запись. Параметр <code>autoFlushingOn</code> при значении <code>true</code> позволяет автоматически записывать данные в поток вывода. По умолчанию этот параметр равен <code>false</code>. Параметр <code>charSet</code> позволяет указать кодировку символов.</p>
</div>
<div class="paragraph">
<p>В качестве источника для записи данных вместо <code>OutputStream</code> можно использовать объект <code>File</code> или строковый путь, по которому будет создаваться файл.</p>
</div>
<div class="paragraph">
<p>Для вывода информации в выходной поток <code>PrintStream</code> использует следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>println()</code> вывод строковой информации с переводом строки</p>
</li>
<li>
<p><code>print()</code> вывод строковой информации без перевода строки</p>
</li>
<li>
<p><code>printf()</code> форматированный вывод</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Например, запишем информацию в файл:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;

public class Program {
    public static void main(String[] args) {
        String text = "Привет мир!"; // строка для записи
        try (FileOutputStream fos = new FileOutputStream("C://SomeDir//notes3.txt");
             PrintStream printStream = new PrintStream(fos)) {
            printStream.println(text);
            System.out.println("Запись в файл произведена");
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае применяется форма конструктора <code>PrintStream</code>, которая в качестве параметра принимает поток вывода: <code>PrintStream (OutputStream out)</code>. Кроме того, мы могли бы использовать ряд других форм конструктора, например, указывая названия файла для записи: <code>PrintStream (string filename)</code></p>
</div>
<div class="paragraph">
<p>В качестве потока вывода используется объект <code>FileOutputStream</code>. С помощью метода <code>println()</code> производится запись информации в выходной поток - то есть в объект <code>FileOutputStream</code>. (В случае с выводом на консоль с помощью <code>System.out.println()</code> в качестве потока вывода выступает консоль)</p>
</div>
<div class="paragraph">
<p>Кроме того, как и любой поток вывода и наследник класса <code>OutputStream</code> он имеет метод <code>write()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.IOException;
import java.io.PrintStream;

public class Program {
    public static void main(String[] args) {
        try (PrintStream printStream = new PrintStream("notes3.txt")) {
            printStream.print("Hello World!");
            printStream.println("Welcome to Java!");
            printStream.printf("Name: %s Age: %d \n", "Tom", 34);
            String message = "PrintStream";
            byte[] messageToBytes = message.getBytes();
            printStream.write(messageToBytes);
            System.out.println("The file has been written");
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>После выполнения этой программы получится файл со следующим содержанием:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-out" data-lang="out">Hello World!Welcome to Java!
Name: Tom Age: 34
PrintStream</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_printwriter"><code>PrintWriter</code></h3>
<div class="paragraph">
<p>На <code>PrintStream</code> похож другой класс <code>PrintWriter</code>. Его можно использовать как для вывода информации на консоль, так и в файл или любой другой поток вывода. Данный класс имеет ряд конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PrintWriter(File file)</code> автоматически добавляет информацию в указанный файл</p>
</li>
<li>
<p><code>PrintWriter(File file, String csn)</code> автоматически добавляет информацию в указанный файл с учетом кодировки <code>csn</code></p>
</li>
<li>
<p><code>PrintWriter(OutputStream out)</code> для вывода информации используется существующий объект <code>OutputStream</code>, автоматически сбрасывая в него данные</p>
</li>
<li>
<p><code>PrintWriter(OutputStream out, boolean autoFlush)</code> для вывода информации используется существующий объект <code>OutputStream</code>, второй параметр указывает, надо ли автоматически добавлять в <code>OutputStream</code> данные</p>
</li>
<li>
<p><code>PrintWriter(String fileName)</code> автоматически добавляет информацию в файл по указанному имени</p>
</li>
<li>
<p><code>PrintWriter(String fileName, String csn)</code> автоматически добавляет информацию в файл по указанному имени, используя кодировку <code>csn</code></p>
</li>
<li>
<p><code>PrintWriter(Writer out)</code> для вывода информации используется существующий объект <code>Writer</code>, в который автоматически идет запись данных</p>
</li>
<li>
<p><code>PrintWriter(Writer out, boolean autoFlush)</code> для вывода информации используется существующий объект <code>Writer</code>, второй параметр указывает, надо ли автоматически добавлять в <code>Writer</code> данные</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>PrintWriter</code> реализует интерфейсы <code>Appendable</code>, <code>Closable</code> и <code>Flushable</code>, и поэтому после использования представляемый им поток надо закрывать.</p>
</div>
<div class="paragraph">
<p>Для записи данных в поток он также используется методы <code>printf()</code> и <code>println()</code>.</p>
</div>
<div class="paragraph">
<p>Например, применим данный класс для вывода на консоль:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try (PrintWriter pw = new PrintWriter(System.out)) {
    pw.println("Hello world!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В качестве потока вывода здесь применяется <code>System.out</code>, а на консоль будет выведена строка <code>Hello world!</code></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_класс_filewriter_и_filereader">Класс <code>FileWriter</code> и <code>FileReader</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Хотя с помощью ранее рассмотренных классов можно записывать текст в файлы, однако они предназначены прежде всего для работы с бинарными потоками данных, и их возможностей для полноценной работы с текстовыми файлами недостаточно. И для этой цели служат совсем другие классы, которые являются наследниками абстрактных классов <code>Reader</code> и <code>Writer</code>.</p>
</div>
<div class="sect2">
<h3 id="_запись_файлов_класс_filewriter">Запись файлов. Класс <code>FileWriter</code></h3>
<div class="paragraph">
<p>Класс <code>FileWriter</code> является производным от класса <code>Writer</code>. Он используется для записи текстовых файлов.</p>
</div>
<div class="paragraph">
<p>Чтобы создать объект <code>FileWriter</code>, можно использовать один из следующих конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FileWriter(File file)</code></p>
</li>
<li>
<p><code>FileWriter(File file, boolean append)</code></p>
</li>
<li>
<p><code>FileWriter(FileDescriptor fd)</code></p>
</li>
<li>
<p><code>FileWriter(String fileName)</code></p>
</li>
<li>
<p>`FileWriter(String fileName, boolean append) `</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Так, в конструктор передается либо путь к файлу в виде строки, либо объект <code>File</code>, который ссылается на конкретный текстовый файл. Параметр <code>append</code> указывает, должны ли данные дозаписываться в конец файла (если параметр равен <code>true</code>), либо файл должен перезаписываться.</p>
</div>
<div class="paragraph">
<p>Запишем в файл какой-нибудь текст:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.FileWriter;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        try (FileWriter writer = new FileWriter("notes3.txt", false)) {
            String text = "Hello Gold!";
            writer.write(text); // запись всей строки
            writer.append('\n'); // запись одного символа
            writer.append('E');
            writer.flush();
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В конструкторе использовался параметр <code>append</code> со значением <code>false</code> - то есть файл будет перезаписываться. Затем с помощью методов, определенных в базовом классе <code>Writer</code> производится запись данных.</p>
</div>
<div class="sect3">
<h4 id="_чтение_файлов_класс_filereader">Чтение файлов. Класс <code>FileReader</code></h4>
<div class="paragraph">
<p>Класс <code>FileReader</code> наследуется от абстрактного класса <code>Reader</code> и предоставляет функциональность для чтения текстовых файлов.</p>
</div>
<div class="paragraph">
<p>Для создания объекта <code>FileReader</code> мы можем использовать один из его конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FileReader(String fileName)</code></p>
</li>
<li>
<p><code>FileReader(File file)</code></p>
</li>
<li>
<p><code>FileReader(FileDescriptor fd)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>А используя методы, определенные в базом классе <code>Reader</code>, произвести чтение файла:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.FileReader;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        try (FileReader reader = new FileReader("notes3.txt")) {
            // читаем посимвольно
            int c;
            while ((c = reader.read()) != -1) {
                System.out.print((char) c);
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Также мы можем считывать в промежуточный буфер из массива символов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

public class Program {
    public static void main(String[] args) {
        try (FileReader reader = new FileReader("notes3.txt")) {
            char[] buf = new char[256];
            int c;
            while ((c = reader.read(buf)) &gt; 0) {
                if (c &lt; 256) {
                    buf = Arrays.copyOf(buf, c);
                }
                System.out.print(buf);
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае считываем последовательно символы из файла в массив из 256 символов, пока не дойдем до конца файла в этом случае метод <code>read()</code> возвратит число <code>-1</code>.</p>
</div>
<div class="paragraph">
<p>Поскольку считанная порция файла может быть меньше 256 символов (например, в файле всего 73 символа), и если количество считанных данных меньше размера буфера (256), то выполняем копирование массива с помощью метода <code>Arrays.copyOf()</code>. То есть фактически обрезаем массив <code>buf</code>, оставляя в нем только те символы, которые считаны из файла.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_классы_bufferedwriter_and_bufferedreader">Классы <code>BufferedWriter</code> and <code>BufferedReader</code></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_запись_текста_через_буфер_и_bufferedwriter">Запись текста через буфер и <code>BufferedWriter</code></h3>
<div class="paragraph">
<p>Класс <code>BufferedWriter</code> записывает текст в поток, предварительно буферизируя записываемые символы, тем самым снижая количество обращений к физическому носителю для записи данных.</p>
</div>
<div class="paragraph">
<p>Класс <code>BufferedWriter</code> имеет следующие конструкторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BufferedWriter(Writer out)</code></p>
</li>
<li>
<p><code>BufferedWriter(Writer out, int sz)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В качестве параметра он принимает поток вывода, в который надо осуществить запись. Второй параметр указывает на размер буфера.</p>
</div>
<div class="paragraph">
<p>Например, осуществим запись в файл:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter("notes4.txt"))) {
            String text = "Hello  World!\nHey! Teachers! Leave them kids alone.";
            bw.write(text);
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_чтение_текста_и_bufferedreader">Чтение текста и <code>BufferedReader</code></h3>
<div class="paragraph">
<p>Класс <code>BufferedReader</code> считывает текст из символьного потока ввода, буферизируя прочитанные символы. Использование буфера призвано увеличить производительность чтения данных из потока.</p>
</div>
<div class="paragraph">
<p>Класс <code>BufferedReader</code> имеет следующие конструкторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BufferedReader(Reader in)</code></p>
</li>
<li>
<p><code>BufferedReader(Reader in, int sz)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Второй конструктор, кроме потока ввода, из которого производится чтение, также определяет размер буфера, в который будут считываться символы.</p>
</div>
<div class="paragraph">
<p>Так как <code>BufferedReader</code> наследуется от класса <code>Reader</code>, то он может использовать все те методы для чтения из потока, которые определены в <code>Reader</code>. И также <code>BufferedReader</code> определяет свой собственный метод <code>readLine()</code>, который позволяет считывать из потока построчно.</p>
</div>
<div class="paragraph">
<p>Рассмотрим применение <code>BufferedReader</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Program {
    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader("notes4.txt"))) {
            // чтение посимвольно
            int c;
            while ((c = br.read()) != -1) {
                System.out.print((char) c);
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Также можно считать текст построчно:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try (BufferedReader br = new BufferedReader(new FileReader("notes4.txt"))) {
    //чтение построчно
    String s;
    while ((s = br.readLine()) != null) {
        System.out.println(s);
    }
} catch (IOException ex) {
    System.out.println(ex.getMessage());
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_считывание_с_консоли_в_файл">Считывание с консоли в файл</h3>
<div class="paragraph">
<p>Соединим оба класса <code>BufferedReader</code> и <code>BufferedWriter</code> для считывания с консоли в файл. Для этого определим следующий код программы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.*;

public class Program {
    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
             BufferedWriter bw = new BufferedWriter(new FileWriter("notes5.txt"))) {
            // чтение построчно
            String text;
            while (!(text = br.readLine()).equals("ESC")) {
                bw.write(text + "\n");
                bw.flush();
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь объект <code>BufferedReader</code> устанавливается для чтения с консоли с помощью объекта <code>new InputStreamReader(System.in)</code>. В цикле <code>while</code> считывается введенный текст. И пока пользователь не введет строку <code>ESC</code>, объект <code>BufferedWriter</code> будет записывать текст файл.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_сериализация">Сериализация</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Сериализация</strong> представляет процесс записи состояния объекта в поток, соответственно процесс извлечения или восстановления состояния объекта из потока называется <strong>десериализацией</strong>. Сериализация очень удобна, когда идет работа со сложными объектами.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../../assets/img/java/core/io/serialization.png" alt="Serialization"></span></p>
</div>
<div class="sect2">
<h3 id="_интерфейс_serializable">Интерфейс <code>Serializable</code></h3>
<div class="paragraph">
<p>Сразу надо сказать, что сериализовать можно только те объекты, которые реализуют интерфейс <code>Serializable</code>. Этот интерфейс не определяет никаких методов, просто он служит указателем системе, что объект, реализующий его, может быть сериализован.</p>
</div>
</div>
<div class="sect2">
<h3 id="_сериализация_класс_objectoutputstream">Сериализация. Класс <code>ObjectOutputStream</code></h3>
<div class="paragraph">
<p>Для сериализации объектов в поток используется класс <code>ObjectOutputStream</code>. Он записывает данные в поток.</p>
</div>
<div class="paragraph">
<p>Для создания объекта <code>ObjectOutputStream</code> в конструктор передается поток, в который производится запись:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ObjectOutputStream(OutputStream out)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для записи данных <code>ObjectOutputStream</code> использует ряд методов, среди которых можно выделить следующие:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void close()</code> закрывает поток</p>
</li>
<li>
<p><code>void flush()</code> очищает буфер и сбрасывает его содержимое в выходной поток</p>
</li>
<li>
<p><code>void write(byte[] buf)</code> записывает в поток массив байтов</p>
</li>
<li>
<p><code>void write(int val)</code> записывает в поток один младший байт из <code>val</code></p>
</li>
<li>
<p><code>void writeBoolean(boolean val)</code> записывает в поток значение <code>boolean</code></p>
</li>
<li>
<p><code>void writeByte(int val)</code> записывает в поток один младший байт из <code>val</code></p>
</li>
<li>
<p><code>void writeChar(int val)</code> записывает в поток значение типа <code>char</code>, представленное целочисленным значением</p>
</li>
<li>
<p><code>void writeDouble(double val)</code> записывает в поток значение типа <code>double</code></p>
</li>
<li>
<p><code>void writeFloat(float val)</code> записывает в поток значение типа <code>float</code></p>
</li>
<li>
<p><code>void writeInt(int val)</code> записывает целочисленное значение <code>int</code></p>
</li>
<li>
<p><code>void writeLong(long val)</code> записывает значение типа <code>long</code></p>
</li>
<li>
<p><code>void writeShort(int val)</code> записывает значение типа <code>short</code></p>
</li>
<li>
<p><code>void writeUTF(String str)</code> записывает в поток строку в кодировке <code>UTF-8</code></p>
</li>
<li>
<p><code>void writeObject(Object obj)</code> записывает в поток отдельный объект</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Эти методы охватывают весь спектр данных, которые можно сериализовать.</p>
</div>
<div class="paragraph">
<p>Например, сохраним в файл один объект класса <code>Person</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class Program {
    public static void main(String[] args) {
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.dat"))) {
            Person p = new Person("Sam", 33, 178, true);
            oos.writeObject(p);
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
    }
}

class Person implements Serializable {
    private String name;
    private int age;
    private double height;
    private boolean married;

    Person(String n, int a, double h, boolean m) {
        name = n;
        age = a;
        height = h;
        married = m;
    }

    String getName() {
        return name;
    }

    int getAge() {
        return age;
    }

    double getHeight() {
        return height;
    }

    boolean getMarried() {
        return married;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_десериализация_класс_objectinputstream">Десериализация. Класс <code>ObjectInputStream</code></h3>
<div class="paragraph">
<p>Класс <code>ObjectInputStream</code> отвечает за обратный процесс - чтение ранее сериализованных данных из потока. В конструкторе он принимает ссылку на поток ввода:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ObjectInputStream(InputStream in)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функционал <code>ObjectInputStream</code> сосредоточен в методах, предназначенных для чтения различных типов данных. Рассмотрим основные методы этого класса:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void close()</code> закрывает поток</p>
</li>
<li>
<p><code>int skipBytes(int len)</code> пропускает при чтении несколько байт, количество которых равно <code>len</code></p>
</li>
<li>
<p><code>int available()</code> возвращает количество байт, доступных для чтения</p>
</li>
<li>
<p><code>int read()</code> считывает из потока один байт и возвращает его целочисленное представление</p>
</li>
<li>
<p><code>boolean readBoolean()</code> считывает из потока одно значение <code>boolean</code></p>
</li>
<li>
<p><code>byte readByte()</code> считывает из потока один байт</p>
</li>
<li>
<p><code>char readChar()</code> считывает из потока один символ <code>char</code></p>
</li>
<li>
<p><code>double readDouble()</code> считывает значение типа <code>double</code></p>
</li>
<li>
<p><code>float readFloat()</code> считывает из потока значение типа <code>float</code></p>
</li>
<li>
<p><code>int readInt()</code> считывает целочисленное значение <code>int</code></p>
</li>
<li>
<p><code>long readLong()</code> считывает значение типа <code>long</code></p>
</li>
<li>
<p><code>short readShort()</code> считывает значение типа <code>short</code></p>
</li>
<li>
<p><code>String readUTF()</code> считывает строку в кодировке <code>UTF-8</code></p>
</li>
<li>
<p><code>Object readObject()</code> считывает из потока объект</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Например, извлечем выше сохраненный объект <code>Person</code> из файла:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.FileInputStream;
import java.io.ObjectInputStream;

public class Program {
    public static void main(String[] args) {
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("person.dat"))) {
            Person p = (Person) ois.readObject();
            System.out.printf("Name: %s \t Age: %d \n", p.getName(), p.getAge());
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь совместим сохранение и восстановление из файла на примере списка объектов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.*;
import java.util.ArrayList;

public class Program {
    //@SuppressWarnings("unchecked")
    public static void main(String[] args) {
        String filename = "people.dat";
        // создадим список объектов, которые будем записывать
        ArrayList&lt;Person&gt; people = new ArrayList&lt;Person&gt;();
        people.add(new Person("Tom", 30, 175, false));
        people.add(new Person("Sam", 33, 178, true));

        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename))) {
            oos.writeObject(people);
            System.out.println("File has been written");
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }

        // десериализация в новый список
        ArrayList&lt;Person&gt; newPeople = new ArrayList&lt;Person&gt;();
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename))) {
            newPeople = ((ArrayList&lt;Person&gt;) ois.readObject());
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }

        for (Person p : newPeople) {
            System.out.printf("Name: %s \t Age: %d \n", p.getName(), p.getAge());
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person implements Serializable {
    private String name;
    private int age;
    private double height;
    private boolean married;

    public Person(String n, int a, double h, boolean m) {
        this.name = n;
        this.age = a;
        this.height = h;
        this.married = m;
    }

    public String getName() {
        return this.name;
    }

    public int getAge() {
        return this.age;
    }

    public double getHeight() {
        return this.height;
    }

    public boolean getMarried() {
        return this.married;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_исключение_данных_из_сериализации">Исключение данных из сериализации</h3>
<div class="paragraph">
<p>По умолчанию сериализуются все переменные объекта. Однако, возможно, мы хотим, чтобы некоторые поля были исключены из сериализации. Для этого они должны быть объявлены с модификатором <code>transient</code>. Например, исключим из сериализации объекта <code>Person</code> переменные <code>height</code> и <code>married</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.Serializable;

class Person implements Serializable {
    private String name;
    private int age;
    private transient double height;
    private transient boolean married;

    public Person(String n, int a, double h, boolean m) {
        this.name = n;
        this.age = a;
        this.height = h;
        this.married = m;
    }

    public String getName() {
        return this.name;
    }

    public int getAge() {
        return this.age;
    }

    public double getHeight() {
        return this.height;
    }

    public boolean getMarried() {
        return this.married;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_классы_zipoutputstream_и_zipinputstream">Классы <code>ZipOutputStream</code> и <code>ZipInputStream</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Кроме общего функционала для работы с файлами Java предоставляет функциональность для работы с таким видом файлов как zip-архивы. Для этого в пакете <code>java.util.zip</code> определены два класса - <code>ZipInputStream</code> и <code>ZipOutputStream</code>.</p>
</div>
<div class="sect2">
<h3 id="_zipoutputstream_запись_архивов"><code>ZipOutputStream</code>. Запись архивов</h3>
<div class="paragraph">
<p>Для создания архива используется класс <code>ZipOutputStream</code>. Для создания объекта <code>ZipOutputStream</code> в его конструктор передается поток вывода:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ZipOutputStream(OutputStream out)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для записи файлов в архив для каждого файла создается объект <code>ZipEntry</code>, в конструктор которого передается имя архивируемого файла. А чтобы добавить каждый объект <code>ZipEntry</code> в архив, применяется метод <code>putNextEntry()</code>.</p>
</div>
<div class="paragraph">
<p>Создадим архив:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class Program {
    public static void main(String[] args) {
        String filename = "C:\\SomeDir\\notes.txt";
        try (ZipOutputStream zout = new ZipOutputStream(new FileOutputStream("C:\\SomeDir\\output.zip"));
             FileInputStream fis = new FileInputStream(filename);) {
            ZipEntry entry1 = new ZipEntry("notes.txt");
            zout.putNextEntry(entry1);
            // считываем содержимое файла в массив byte
            byte[] buffer = new byte[fis.available()];
            fis.read(buffer);
            // добавляем содержимое к архиву
            zout.write(buffer);
            // закрываем текущую запись для новой записи
            zout.closeEntry();
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>После добавления объекта <code>ZipEntry</code> в поток нам также надо добавить в него и содержимое файла. Для этого используется метод <code>write()</code>, записывающий в поток массив байтов: <code>zout.write(buffer);</code>. В конце надо закрыть <code>ZipEntry</code> с помощью метода <code>closeEntry()</code>. После этого можно добавлять в архив новые файлы - в этом случае все вышеописанные действия для каждого нового файла повторяются.</p>
</div>
</div>
<div class="sect2">
<h3 id="_чтение_архивов_zipinputstream">Чтение архивов. <code>ZipInputStream</code></h3>
<div class="paragraph">
<p>Для чтения архивов применяется класс <code>ZipInputStream</code>. В конструкторе он принимает поток, указывающий на zip-архив:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ZipInputStream(InputStream in)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для считывания файлов из архива <code>ZipInputStream</code> использует метод <code>getNextEntry()</code>, который возвращает объект <code>ZipEntry</code>. Объект <code>ZipEntry</code> представляет отдельную запись в zip-архиве. Например, считаем какой-нибудь архив:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public class Program {
    public static void main(String[] args) {
        try (ZipInputStream zin = new ZipInputStream(new FileInputStream("C:\\SomeDir\\output.zip"))) {
            ZipEntry entry;
            String name;
            long size;
            while ((entry = zin.getNextEntry()) != null) {
                name = entry.getName(); // получим название файла
                size = entry.getSize();  // получим его размер в байтах
                System.out.printf("File name: %s \t File size: %d \n", name, size);
                // распаковка
                FileOutputStream fout = new FileOutputStream("C:\\somedir\\new" + name);
                for (int c = zin.read(); c != -1; c = zin.read()) {
                    fout.write(c);
                }
                fout.flush();
                zin.closeEntry();
                fout.close();
            }
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ZipInputStream</code> в конструкторе получает ссылку на поток ввода. И затем в цикле выводятся все файлы и их размер в байтах, которые находятся в данном архиве.</p>
</div>
<div class="paragraph">
<p>Затем данные извлекаются из архива и сохраняются в новые файлы, которые находятся в той же папке и которые начинаются с <code>new</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_класс_console">Класс <code>Console</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Специально для работы с консолью в Java определен класс <code>Console</code>, который хранится в пакете <code>java.io</code>. Он не получает консольный ввод-вывод сам по себе, а использует уже имеющиеся потоки <code>System.in</code> и <code>System.out</code>. Но в то же время <code>Console</code> значительно упрощает ряд операций, связанных с консолью.</p>
</div>
<div class="paragraph">
<p>Для получения объекта консоли надо вызвать статический метод <code>System.console()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Console console = System.console();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Основные методы класса <code>Console</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>flush()</code> выводит на консоль все данные из буфера</p>
</li>
<li>
<p><code>format()</code> выводит на консоль строку с использованием форматирования</p>
</li>
<li>
<p><code>printf()</code> выводит на консоль строку с использованием форматирования (фактически то же самое, что и предыдущий метод)</p>
</li>
<li>
<p><code>String readLine()</code> считывает с консоли введенную пользователем строку</p>
</li>
<li>
<p><code>char[] readPassword()</code> считывает с консоли введенную пользователем строку, при этом символы строки не отображаются на консоли</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Используем класс <code>Console</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.Console;

public class Program {
    public static void main(String[] args) {
        // получаем консоль
        Console console = System.console();
        if (console != null) {
            // считываем данные с консоли
            String login = console.readLine("Введите логин:");
            char[] password = console.readPassword("Введите пароль:");
            console.printf("Введенный логин: %s \n", login);
            console.printf("Введенный пароль: %s \n", new String(password));
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Важно, что доступ к консоли мы можем получить только из самой консоли. При запуске, например, в <strong>IntelliJ IDEA</strong> вызов <code>System.console()</code> будет возвращать значение <code>null</code>. Поэтому при работе с консолью желательно проверять полученное значение на <code>null</code>. Ну а если мы запустим программу в командной строке, то естественно у нас все будет работать.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-06-11 09:16:47 UTC
</div>
</div>
</body>
</html>