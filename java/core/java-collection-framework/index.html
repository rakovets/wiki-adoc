<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.15">
<title>Java Collection Framework</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Java Collection Framework</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_типы_коллекций">Типы коллекций</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для хранения наборов данных в Java предназначены массивы. Однако их не всегда удобно использовать, прежде всего потому, что они имеют фиксированную длину. Эту проблему в Java решают коллекции. Однако суть не только в гибких по размеру наборах объектов, но в и том, что классы коллекций реализуют различные алгоритмы и структуры данных, например, такие как стек, очередь, дерево и ряд других.</p>
</div>
<div class="paragraph">
<p>Классы коллекций располагаются в пакете <code>java.util</code>, поэтому перед применением коллекций следует подключить данный пакет.</p>
</div>
<div class="paragraph">
<p>Хотя в Java существует множество коллекций, но все они образуют стройную и логичную систему. Во-первых, в основе всех коллекций лежит применение того или иного интерфейса, который определяет базовый функционал. Среди этих интерфейсов можно выделить следующие:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Collection</code> базовый интерфейс для всех коллекций и других интерфейсов коллекций</p>
</li>
<li>
<p><code>Queue</code>: наследует интерфейс <code>Collection</code> и представляет функционал для структур данных в виде очереди</p>
</li>
<li>
<p><code>Deque</code>: наследует интерфейс <code>Queue</code> и представляет функционал для двунаправленных очередей</p>
</li>
<li>
<p><code>List</code>: наследует интерфейс <code>Collection</code> и представляет функциональность простых списков</p>
</li>
<li>
<p><code>Set</code>: также расширяет интерфейс <code>Collection</code> и используется для хранения множеств уникальных объектов</p>
</li>
<li>
<p><code>SortedSet</code>: расширяет интерфейс Set для создания сортированных коллекций</p>
</li>
<li>
<p><code>NavigableSet</code>: расширяет интерфейс SortedSet для создания коллекций, в которых можно осуществлять поиск по соответствию</p>
</li>
<li>
<p><code>Map</code>: предназначен для созданий структур данных в виде словаря, где каждый элемент имеет определенный ключ и значение. В отличие от других интерфейсов коллекций не наследуется от интерфейса <code>Collection</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Эти интерфейсы частично реализуются абстрактными классами:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AbstractCollection</code>: базовый абстрактный класс для других коллекций, который применяет интерфейс <code>Collection</code></p>
</li>
<li>
<p><code>AbstractList</code>: расширяет класс <code>AbstractCollection</code> и применяет интерфейс <code>List</code>, предназначен для создания коллекций в виде списков</p>
</li>
<li>
<p><code>AbstractSet</code>: расширяет класс <code>AbstractCollection</code> и применяет интерфейс <code>Set</code> для создания коллекций в виде множеств</p>
</li>
<li>
<p><code>AbstractQueue</code>: расширяет класс <code>AbstractCollection</code> и применяет интерфейс <code>Queue</code>, предназначен для создания коллекций в виде очередей и стеков</p>
</li>
<li>
<p><code>AbstractSequentialList</code>: также расширяет класс <code>AbstractList</code> и реализует интерфейс <code>List</code>. Используется для создания связанных списков</p>
</li>
<li>
<p><code>AbstractMap</code>: применяет интерфейс <code>Map</code>, предназначен для создания наборов по типу словаря с объектами в виде пары <code>key</code>-<code>value</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>С помощью применения вышеописанных интерфейсов и абстрактных классов в Java реализуется широкая палитра классов коллекций - списки, множества, очереди, отображения и другие, среди которых можно выделить следующие:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ArrayList</code>: простой список объектов</p>
</li>
<li>
<p><code>LinkedList</code>: представляет связанный список</p>
</li>
<li>
<p><code>ArrayDeque</code>: класс двунаправленной очереди, в которой мы можем произвести вставку и удаление как в начале коллекции, так и в ее конце</p>
</li>
<li>
<p><code>HashSet</code>: набор объектов или хеш-множество, где каждый элемент имеет ключ - уникальный хеш-код</p>
</li>
<li>
<p><code>TreeSet</code>: набор отсортированных объектов в виде дерева</p>
</li>
<li>
<p><code>LinkedHashSet</code>: связанное хеш-множество</p>
</li>
<li>
<p><code>PriorityQueue</code>: очередь приоритетов</p>
</li>
<li>
<p><code>HashMap</code>: структура данных в виде словаря, в котором каждый объект имеет уникальный ключ и некоторое значение</p>
</li>
<li>
<p><code>TreeMap</code>: структура данных в виде дерева, где каждый элемент имеет уникальный ключ и некоторое значение</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Схематично всю систему можно представить следующим образом:
<span class="image"><img src="../../../assets/img/java/core/java-collection-framework/java-collection-hierarchy.png" alt="Java Collection Hierarchy"></span></p>
</div>
<div class="paragraph">
<p>Следует отметить, что в отличие от других интерфейсов, которые представляют коллекции, интерфейс <code>Map</code> <strong>НЕ расширяет</strong> интерфейс <code>Collection</code>.
<span class="image"><img src="../../../assets/img/java/core/java-collection-framework/java-map-hierarchy.png" alt="Java Map Hierarchy"></span></p>
</div>
<div class="sect2">
<h3 id="_interface_collection">Interface <code>Collection</code></h3>
<div class="paragraph">
<p>Интерфейс <code>Collection</code> является базовым для всех коллекций, определяя основной функционал:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;{
    // определения методов
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Интерфейс <code>Collection</code> является обобщенным и расширяет интерфейс <code>Iterable</code>, поэтому все объекты коллекций можно перебирать в цикле по типу <code>for-each</code>.</p>
</div>
<div class="paragraph">
<p>Среди методов интерфейса <code>Collection</code> можно выделить следующие:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boolean add(E item)</code>: добавляет в коллекцию объект <code>item</code>. При удачном добавлении возвращает <code>true</code>, при неудачном - <code>false</code></p>
</li>
<li>
<p><code>boolean addAll(Collection&lt;? extends E&gt; col)</code>: добавляет в коллекцию все элементы из коллекции <code>col</code>. При удачном добавлении возвращает <code>true</code>, при неудачном - <code>false</code></p>
</li>
<li>
<p><code>void clear()</code>: удаляет все элементы из коллекции</p>
</li>
<li>
<p><code>boolean contains(Object item)</code>: возвращает <code>true</code>, если объект <code>item</code> содержится в коллекции, иначе возвращает <code>false</code></p>
</li>
<li>
<p><code>boolean isEmpty()</code>: возвращает <code>true</code>, если коллекция пуста, иначе возвращает <code>false</code></p>
</li>
<li>
<p><code>Iterator&lt;E&gt; iterator()</code>: возвращает объект Iterator для обхода элементов коллекции</p>
</li>
<li>
<p><code>boolean remove(Object item)</code>: возвращает <code>true</code>, если объект <code>item</code> удачно удален из коллекции, иначе возвращается <code>false</code></p>
</li>
<li>
<p><code>boolean removeAll(Collection&lt;?&gt; col)</code>: удаляет все объекты коллекции <code>col</code> из текущей коллекции. Если текущая коллекция изменилась, возвращает <code>true</code>, иначе возвращается <code>false</code></p>
</li>
<li>
<p><code>boolean retainAll(Collection&lt;?&gt; col)</code>: удаляет все объекты из текущей коллекции, кроме тех, которые содержатся в коллекции <code>col</code>. Если текущая коллекция после удаления изменилась, возвращает <code>true</code>, иначе возвращается <code>false</code></p>
</li>
<li>
<p><code>int size()</code>: возвращает число элементов в коллекции</p>
</li>
<li>
<p><code>Object[] toArray()</code>: возвращает массив, содержащий все элементы коллекции</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Все эти и остальные методы, которые имеются в интерфейсе <code>Collection</code>, реализуются всеми коллекциями, поэтому в целом общие принципы работы с коллекциями будут одни и те же. Единообразный интерфейс упрощает понимание и работу с различными типами коллекций. Так, добавление элемента будет производиться с помощью метода <code>add()</code>, который принимает добавляемый элемент в качестве параметра. Для удаления вызывается метод <code>remove()</code>. Метод <code>clear()</code> будет очищать коллекцию, а метод <code>size()</code> возвращать количество элементов в коллекции.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interface_iterator">Interface <code>Iterator</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Одним из ключевых методов интерфейса <code>Collection</code>, который он унаследовал от интерфейса <code>Iterable</code> является метод <code>Iterator&lt;E&gt; iterator()</code>. Он возвращает <strong>итератор</strong> - то есть объект, реализующий интерфейс <code>Iterator</code>.</p>
</div>
<div class="paragraph">
<p>Интерфейс <code>Iterator</code> имеет следующее определение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface Iterator &lt;E&gt; {
    E next();

    boolean hasNext();

    void remove();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Реализация интерфейса предполагает, что с помощью вызова метода <code>next()</code> можно получить следующий элемент. С помощью метода <code>hasNext()</code> можно узнать, есть ли следующий элемент, и не достигнут ли конец коллекции. И если элементы еще имеются, то <code>hasNext()</code> вернет значение <code>true</code>. Метод <code>hasNext()</code> следует вызывать перед методом <code>next()</code>, так как при достижении конца коллекции метод <code>next()</code> выбрасывает исключение <code>NoSuchElementException</code>. И метод <code>remove()</code> удаляет текущий элемент, который был получен последним вызовом <code>next()</code>.</p>
</div>
<div class="paragraph">
<p>Используем итератор для перебора коллекции <code>ArrayList</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.ArrayList;
import java.util.Iterator;

public class Program {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; states = new ArrayList&lt;String&gt;();
        states.add("Germany");
        states.add("France");
        states.add("Italy");
        states.add("Spain");

        Iterator&lt;String&gt; iter = states.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next());
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interface_list">Interface <code>List</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для создания простых списков применяется интерфейс <code>List</code>, который расширяет функцональность интерфейса <code>Collection</code>. Некоторые наиболее часто используемые методы интерфейса <code>List</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void add(int index, E obj)</code> добавляет в список по индексу <code>index</code> объект <code>obj</code></p>
</li>
<li>
<p><code>boolean addAll(int index, Collection&lt;? extends E&gt; col)</code> добавляет в список по индексу <code>index</code> все элементы коллекции <code>col</code>. Если в результате добавления список был изменен, то возвращается <code>true</code>, иначе возвращается <code>false</code></p>
</li>
<li>
<p><code>E get(int index)</code> возвращает объект из списка по индексу <code>index</code></p>
</li>
<li>
<p><code>int indexOf(Object obj)</code> возвращает индекс первого вхождения объекта <code>obj</code> в список. Если объект не найден, то возвращается <code>-1</code></p>
</li>
<li>
<p><code>int lastIndexOf(Object obj)</code> возвращает индекс последнего вхождения объекта <code>obj</code> в список. Если объект не найден, то возвращается <code>-1</code></p>
</li>
<li>
<p><code>ListIterator&lt;E&gt; listIterator ()</code> возвращает объект <code>ListIterator</code> для обхода элементов списка</p>
</li>
<li>
<p><code>static &lt;E&gt; List&lt;E&gt; of(Object &#8230;&#8203;)</code> создает из набора элементов объект <code>List</code></p>
</li>
<li>
<p><code>E remove(int index)</code> удаляет объект из списка по индексу <code>index</code>, возвращая при этом удаленный объект</p>
</li>
<li>
<p><code>E set(int index, E obj)</code> присваивает значение объекта <code>obj</code> элементу, который находится по индексу <code>index</code></p>
</li>
<li>
<p><code>void sort(Comparator&lt;? super E&gt; comp)</code> сортирует список с помощью компаратора <code>comp</code></p>
</li>
<li>
<p><code>List&lt;E&gt; subList(int start, int end)</code> получает набор элементов, которые находятся в списке между индексами <code>start</code> и <code>end</code></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_class_arraylist">Class <code>ArrayList</code></h3>
<div class="paragraph">
<p>По умолчанию в Java есть встроенная реализация этого интерфейса - класс <code>ArrayList</code>. Класс <code>ArrayList</code> представляет обобщенную коллекцию, которая наследует свою функциональность от класса <code>AbstractList</code> и применяет интерфейс <code>List</code>. Проще говоря, <code>ArrayList</code> представляет простой список, аналогичный массиву, за тем исключением, что количество элементов в нем не фиксировано.</p>
</div>
<div class="paragraph">
<p><code>ArrayList</code> имеет следующие конструкторы`:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ArrayList()</code> создает пустой список</p>
</li>
<li>
<p><code>ArrayList(Collection &lt;? extends E&gt; col)</code> создает список, в который добавляются все элементы коллекции <code>col</code></p>
</li>
<li>
<p><code>ArrayList (int capacity)</code> создает список, который имеет начальную емкость <code>capacity</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Емкость в <code>ArrayList</code> представляет размер массива, который будет использоваться для хранения объектов. При добавлении элементов фактически происходит перераспределение памяти - создание нового массива и копирование в него элементов из старого массива. Изначальное задание емкости <code>ArrayList</code> позволяет снизить подобные перераспределения памяти, тем самым повышая производительность.</p>
</div>
<div class="paragraph">
<p>Используем класс <code>ArrayList</code> и некоторые его методы в программе:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.ArrayList;

public class Program {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; people = new ArrayList&lt;String&gt;();
        // добавим в список ряд элементов
        people.add("Tom");
        people.add("Alice");
        people.add("Kate");
        people.add("Sam");
        people.add(1, "Bob"); // добавляем элемент по индексу 1

        System.out.println(people.get(1));// получаем 2-й объект
        people.set(1, "Robert"); // установка нового значения для 2-го объекта

        System.out.printf("ArrayList has %d elements \n", people.size());
        for (String person : people) {
            System.out.println(person);
        }
        // проверяем наличие элемента
        if (people.contains("Tom")) {
            System.out.println("ArrayList contains Tom");
        }

        // удалим несколько объектов
        // удаление конкретного элемента
        people.remove("Robert");
        // удаление по индексу
        people.remove(0);

        Object[] peopleArray = people.toArray();
        for (Object person : peopleArray) {
            System.out.println(person);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь объект <code>ArrayList</code> типизируется классом <code>String</code>, поэтому список будет хранить только строки. Поскольку класс <code>ArrayList</code> применяет интерфейс <code>Collection&lt;E&gt;</code>, то мы можем использовать методы данного интерфейса для управления объектами в списке.</p>
</div>
<div class="paragraph">
<p>Для добавления вызывается метод <code>add()</code>. С его помощью мы можем добавлять объект в конец списка. Также мы можем добавить объект на определенное место в списке. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">people.add("Tom") // добавит элемент в конец списка
people.add(1, "Bob") // добавит элемент на 1 позицию в списке</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>size()</code> позволяет узнать количество объектов в коллекции.</p>
</div>
<div class="paragraph">
<p>Проверку на наличие элемента в коллекции производится с помощью метода <code>contains()</code>. А удаление с помощью метода <code>remove()</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">people.remove("Tom") // удаление элемента с данным значением из списка
people.remove(0) // удаление элемента на 0 позиции в списке</code></pre>
</div>
</div>
<div class="paragraph">
<p>Получить определенный элемент по индексу мы можем с помощью метода <code>get()</code>, а установить элемент по индексу с помощью метода <code>set</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String person = people.get(1);
people.set(1, "Robert");</code></pre>
</div>
</div>
<div class="paragraph">
<p>С помощью метода <code>toArray()</code> мы можем преобразовать список в массив объектов.</p>
</div>
<div class="paragraph">
<p>И поскольку класс <code>ArrayList</code> реализует интерфейс <code>Iterable</code>, то мы можем пробежаться по списку в цикле типа <code>for-each</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">for(String person : people) {
    // some opeartors
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Хотя мы можем свободно добавлять в объект <code>ArrayList</code> дополнительные объекты, в отличие от массива, однако в реальности <code>ArrayList</code> использует для хранения объектов опять же массив. По умолчанию данный массив предназначен для 10 объектов. Если в процессе программы добавляется гораздо больше, то создается новый массив, который может вместить в себя все количество. Подобные перераспределения памяти <strong>уменьшают производительность</strong>. Поэтому если мы точно знаем, что у нас список не будет содержать больше определенного количества элементов, например, 25, то мы можем сразу же явным образом установить это количество, либо в конструкторе: <code>ArrayList&lt;String&gt; people = new ArrayList&lt;String&gt;(25);</code>, либо с помощью метода <code>ensureCapacity</code>: <code>people.ensureCapacity(25);</code></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interface_listiterator">Interface <code>ListIterator</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Интерфейс <code>Iterator</code> предоставляет ограниченный функционал. Гораздо больший набор методов предоставляет другой итератор - интерфейс <code>ListIterator</code>. Данный итератор используется классами, реализующими интерфейс <code>List</code>, то есть классами <code>LinkedList</code>, <code>ArrayList</code> и др.</p>
</div>
<div class="paragraph">
<p>Интерфейс <code>ListIterator</code> расширяет интерфейс <code>Iterator</code> и определяет ряд дополнительных методов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void add(E obj)</code> вставляет объект <code>obj</code> перед элементом, который должен быть возвращен следующим вызовом <code>next()</code></p>
</li>
<li>
<p><code>boolean hasNext()</code> возвращает <code>true</code>, если в коллекции имеется следующий элемент, иначе возвращает <code>false</code></p>
</li>
<li>
<p><code>boolean hasPrevious()</code> возвращает <code>true</code>, если в коллекции имеется предыдущий элемент, иначе возвращает <code>false</code></p>
</li>
<li>
<p><code>E next()</code> возвращает текущий элемент и переходит к следующему, если такого нет, то генерируется исключение <code>NoSuchElementException</code></p>
</li>
<li>
<p><code>E previous()</code> возвращает текущий элемент и переходит к предыдущему, если такого нет, то генерируется исключение <code>NoSuchElementException</code></p>
</li>
<li>
<p><code>int nextIndex()</code> возвращает индекс следующего элемента. Если такого нет, то возвращается размер списка</p>
</li>
<li>
<p><code>int previousIndex()</code> возвращает индекс предыдущего элемента. Если такого нет, то возвращается число <code>-1</code></p>
</li>
<li>
<p><code>void remove()</code> удаляет текущий элемент из списка. Таким образом, этот метод должен быть вызван после методов <code>next()</code> или <code>previous()</code>, иначе будет сгенерировано исключение <code>IllegalStateException</code></p>
</li>
<li>
<p><code>void set(E obj)</code> присваивает текущему элементу, выбранному вызовом методов <code>next()</code> или <code>previous()</code>, ссылку на объект <code>obj</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Используем <code>ListIterator</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.ArrayList;
import java.util.ListIterator;

public class Program {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; states = new ArrayList&lt;String&gt;();
        states.add("Germany");
        states.add("France");
        states.add("Italy");
        states.add("Spain");

        ListIterator&lt;String&gt; listIter = states.listIterator();

        while (listIter.hasNext()) {
            System.out.println(listIter.next());
        }
        // сейчас текущий элемент - Испания
        // изменим значение этого элемента
        listIter.set("Португалия");
        // пройдемся по элементам в обратном порядке
        while (listIter.hasPrevious()) {
            System.out.println(listIter.previous());
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interface_comparable_and_comparator">Interface <code>Comparable</code> and <code>Comparator</code></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_interface_comparable">Interface <code>Comparable</code></h3>
<div class="paragraph">
<p>Рассмотрим коллекции <code>TreeSet</code>, типизированную объектами <code>String</code>. При добавлении новых элементов объект <code>TreeSet</code> автоматически проводит сортировку, помещая новый объект на правильное для него место. Что если бы использовались не строки, а классы, например, следующий класс <code>Person</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {
    private String name;

    Person(String name) {
        this.name = name;
    }

    String getName() {
        return name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Объект <code>TreeSet</code> нельзя типизировать данным классом, поскольку в случае добавления объектов <code>TreeSet</code> не будет знать, как их сравнивать, и следующий код не будет работать:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TreeSet&lt;Person&gt; people = new TreeSet&lt;Person&gt;();
people.add(new Person("Tom"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>При выполнении этого кода возникнет ошибка, которая скажет, что объект <code>Person</code> не может быть преобразован к типу <code>java.lang.Comparable</code>.</p>
</div>
<div class="paragraph">
<p>Для того, чтобы объекты <code>Person</code> можно было сравнить и сортировать, они должны применять интерфейс <code>Comparable&lt;E&gt;</code>. При применении интерфейса он типизируется текущим классом. Применим его к классу <code>Person</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person implements Comparable&lt;Person&gt; {
    private String name;

    Person(String name) {
        this.name = name;
    }

    String getName() {
        return name;
    }

    public int compareTo(Person p) {
        return name.compareTo(p.getName());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Интерфейс <code>Comparable</code> содержит один единственный метод <code>int compareTo(E item)</code>, который сравнивает текущий объект с объектом, переданным в качестве параметра. Если этот метод возвращает отрицательное число, то текущий объект будет располагаться перед тем, который передается через параметр. Если метод вернет положительное число, то, наоборот, после второго объекта. Если метод возвратит <code>0</code>, значит, оба объекта равны.</p>
</div>
<div class="paragraph">
<p>В данном случае мы не возвращаем явным образом никакое число, а полагаемся на встроенный механизм сравнения, который есть у класса <code>String</code>. Но мы также можем определить и свою логику, например, сравнивать по длине имени:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public int compareTo(Person p) {
    return name.length() - p.getName().length();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь можно типизировать <code>TreeSet</code> типом <code>Person</code> и добавлять в дерево соответствующие объекты:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TreeSet&lt;Person&gt; people = new TreeSet&lt;Person&gt;();
people.add(new Person("Tom"));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interface_comparator">Interface <code>Comparator</code></h3>
<div class="paragraph">
<p>Однако перед нами может возникнуть проблема, что если разработчик не реализовал в своем классе, который мы хотим использовать, интерфейс <code>Comparable</code>, либо реализовал, но нас не устраивает его функциональность, и мы хотим ее переопределить? На этот случай есть еще более гибкий способ, предполагающий применение интерфейса <code>Comparator&lt;E&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Интерфейс <code>Comparator</code> содержит ряд методов, ключевым из которых является метод <code>compare()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface Comparator&lt;E&gt; {
    int compare(T a, T b);
    // остальные методы
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>compare()</code> также возвращает числовое значение - если оно отрицательное, то объект <code>a</code> предшествует объекту <code>b</code>, иначе - наоборот. А если метод возвращает <code>0</code>, то объекты равны. Для применения интерфейса нам вначале надо создать класс компаратора, который реализует этот интерфейс:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class PersonComparator implements Comparator&lt;Person&gt; {
    public int compare(Person a, Person b) {
        return a.getName().compareTo(b.getName());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь опять же проводим сравнение по строкам. Теперь используем класс компаратора для создания объекта <code>TreeSet</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">PersonComparator pcomp = new PersonComparator();
TreeSet&lt;Person&gt; people = new TreeSet&lt;Person&gt;(pcomp);
people.add(new Person("Tom"));
people.add(new Person("Nick"));
people.add(new Person("Alice"));
people.add(new Person("Bill"));
for (Person p : people) {
    System.out.println(p.getName());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для создания <code>TreeSet</code> здесь используется одна из версий конструктора, которая в качестве параметра принимает компаратор. Теперь вне зависимости от того, реализован ли в классе <code>Person</code> интерфейс <code>Comparable</code>, логика сравнения и сортировки будет использоваться та, которая определена в классе компаратора.</p>
</div>
</div>
<div class="sect2">
<h3 id="_сортировка_по_нескольким_критериям">Сортировка по нескольким критериям</h3>
<div class="paragraph">
<p>Начиная с JDK 8 в механизм работы компараторов были внесены некоторые дополнения. В частности, теперь мы можем применять сразу несколько компараторов по принципу приоритета. Например, изменим класс <code>Person</code> следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    String getName() {
        return this.name;
    }

    int getAge() {
        return this.age;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь добавлено поле для хранения возраста пользователя. И, допустим, нам надо отсортировать пользователей по имени и по возрасту. Для этого определим два компаратора:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class PersonNameComparator implements Comparator&lt;Person&gt; {
    public int compare(Person a, Person b) {
        return a.getName().compareTo(b.getName());
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class PersonAgeComparator implements Comparator&lt;Person&gt; {
    public int compare(Person a, Person b) {
        int result = 0;
        if (a.getAge() &gt; b.getAge()) {
            result = 1;
        } else if (a.getAge() &lt; b.getAge()) {
            result = -1;
        }
        return result;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Интерфейс компаратора определяет специальный метод по умолчанию <code>thenComparing()</code>, который позволяет использовать цепочки компараторов для сортировки набора:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Comparator&lt;Person&gt; pcomp = new PersonNameComparator().thenComparing(new PersonAgeComparator());
TreeSet&lt;Person&gt; people = new TreeSet(pcomp);
people.add(new Person("Tom", 23));
people.add(new Person("Nick", 34));
people.add(new Person("Tom", 10));
people.add(new Person("Bill", 14));

for (Person p : people) {
    System.out.println(p.getName() + " " + p.getAge());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае сначала применяется сортировка по имени, а потом по возрасту.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interface_queue">Interface <code>Queue</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Очереди представляют структуру данных, работающую по принципу <strong>FIFO (first in - first out)</strong>. То есть чем раньше был добавлен элемент в коллекцию, тем раньше он из нее удаляется. Это стандартная модель однонаправленной очереди. Однако бывают и двунаправленные - то есть такие, в которых мы можем добавить элемент не только в начала, но и в конец. И соответственно удалить элемент не только из конца, но и из начала.</p>
</div>
<div class="paragraph">
<p>Особенностью классов очередей является то, что они реализуют специальные интерфейсы <code>Queue</code> или <code>Deque</code>.</p>
</div>
<div class="paragraph">
<p>Обобщенный интерфейс <code>Queue&lt;E&gt;</code> расширяет базовый интерфейс <code>Collection</code> и определяет поведение класса в качестве однонаправленной очереди. Свою функциональность он раскрывает через следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>E element()</code>: возвращает, но не удаляет, элемент из начала очереди. Если очередь пуста, генерирует исключение <code>NoSuchElementException</code></p>
</li>
<li>
<p><code>boolean offer(E obj)</code>: добавляет элемент <code>obj</code> в конец очереди. Если элемент удачно добавлен, возвращает <code>true</code>, иначе - <code>false</code></p>
</li>
<li>
<p><code>E peek()</code>: возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение <code>null</code></p>
</li>
<li>
<p><code>E poll()</code>: возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение <code>null</code></p>
</li>
<li>
<p><code>E remove()</code>: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение <code>NoSuchElementException</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Таким образом, у всех классов, которые реализуют данный интерфейс, будет метод <code>offer</code> для добавления в очередь, метод <code>poll</code> для извлечения элемента из головы очереди, и методы <code>peek</code> и <code>element</code>, позволяющие просто получить элемент из головы очереди.</p>
</div>
<div class="sect2">
<h3 id="_interface_deque">Interface <code>Deque</code></h3>
<div class="paragraph">
<p>Интерфейс <code>Deque</code> расширяет вышеописанный интерфейс Queue и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, либо как стек, действующий по принципу <strong>LIFO (последний вошел - первый вышел)</strong>.</p>
</div>
<div class="paragraph">
<p>Интерфейс <code>Deque</code> определяет следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void addFirst(E obj)</code>: добавляет элемент в начало очереди</p>
</li>
<li>
<p><code>void addLast(E obj)</code>: добавляет элемент <code>obj</code> в конец очереди</p>
</li>
<li>
<p><code>E getFirst()</code>: возвращает без удаления элемент из головы очереди. Если очередь пуста, генерирует исключение <code>NoSuchElementException</code></p>
</li>
<li>
<p><code>E getLast()</code>: возвращает без удаления последний элемент очереди. Если очередь пуста, генерирует исключение <code>NoSuchElementException</code></p>
</li>
<li>
<p><code>boolean offerFirst(E obj)</code>: добавляет элемент <code>obj</code> в самое начало очереди. Если элемент удачно добавлен, возвращает <code>true</code>, иначе - <code>false</code></p>
</li>
<li>
<p><code>boolean offerLast(E obj)</code>: добавляет элемент <code>obj</code> в конец очереди. Если элемент удачно добавлен, возвращает <code>true</code>, иначе - <code>false</code></p>
</li>
<li>
<p><code>E peekFirst()</code>: возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение <code>null</code></p>
</li>
<li>
<p><code>E peekLast()</code>: возвращает без удаления последний элемент очереди. Если очередь пуста, возвращает значение <code>null</code></p>
</li>
<li>
<p><code>E pollFirst()</code>: возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение <code>null</code></p>
</li>
<li>
<p><code>E pollLast()</code>: возвращает с удалением последний элемент очереди. Если очередь пуста, возвращает значение <code>null</code></p>
</li>
<li>
<p><code>E pop()</code>: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение <code>NoSuchElementException</code></p>
</li>
<li>
<p><code>void push(E element)</code>: добавляет элемент в самое начало очереди</p>
</li>
<li>
<p><code>E removeFirst()</code>: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение <code>NoSuchElementException</code></p>
</li>
<li>
<p><code>E removeLast()</code>: возвращает с удалением элемент из конца очереди. Если очередь пуста, генерирует исключение <code>NoSuchElementException</code></p>
</li>
<li>
<p><code>boolean removeFirstOccurrence(Object obj)</code>: удаляет первый встреченный элемент <code>obj</code> из очереди. Если удаление произшло, то возвращает <code>true</code>, иначе возвращает <code>false</code>.</p>
</li>
<li>
<p><code>boolean removeLastOccurrence(Object obj)</code>: удаляет последний встреченный элемент <code>obj</code> из очереди. Если удаление произшло, то возвращает <code>true</code>, иначе возвращает <code>false</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Таким образом, наличие методов <code>pop</code> и <code>push</code> позволяет классам, реализующим этот элемент, действовать в качестве стека. В тоже время имеющийся функционал также позволяет создавать двунаправленные очереди, что делает классы, применяющие данный интерфейс, довольно гибкими.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arraydeque"><code>ArrayDeque</code></h3>
<div class="paragraph">
<p>В Java очереди представлены рядом классов. Одни из низ - класс <code>ArrayDeque&lt;E&gt;</code>. Этот класс представляют обобщенную двунаправленную очередь, наследуя функционал от класса <code>AbstractCollection</code> и применяя интерфейс <code>Deque</code>.</p>
</div>
<div class="paragraph">
<p>В классе <code>ArrayDeque</code> определены следующие конструкторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ArrayDeque()</code>: создает пустую очередь</p>
</li>
<li>
<p><code>ArrayDeque(Collection&lt;? extends E&gt; col)</code>: создает очередь, наполненную элементами из коллекции <code>col</code></p>
</li>
<li>
<p><code>ArrayDeque(int capacity)</code>: создает очередь с начальной емкостью <code>capacity</code>. Если мы явно не указываем начальную емкость, то <strong>емкость по умолчанию будет равна 16</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример использования класса`:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.ArrayDeque;

public class Program {
    public static void main(String[] args) {
        ArrayDeque&lt;String&gt; states = new ArrayDeque&lt;String&gt;();
        // стандартное добавление элементов
        states.add("Germany");
        states.addFirst("France"); // добавляем элемент в самое начало
        states.push("Great Britain"); // добавляем элемент в самое начало
        states.addLast("Spain"); // добавляем элемент в конец коллекции
        states.add("Italy");

        // получаем первый элемент без удаления
        String sFirst = states.getFirst();
        System.out.println(sFirst);     // Great Britain
        // получаем последний элемент без удаления
        String sLast = states.getLast();
        System.out.println(sLast);      // Italy

        System.out.printf("Queue size: %d \n", states.size());  // 5

        // перебор коллекции
        while (states.peek() != null) {
            // извлечение c начала
            System.out.println(states.pop());
        }

        // очередь из объектов Person
        ArrayDeque&lt;Person&gt; people = new ArrayDeque&lt;Person&gt;();
        people.addFirst(new Person("Tom"));
        people.addLast(new Person("Nick"));
        // перебор без извлечения
        for (Person p : people) {
            System.out.println(p.getName());
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {
    private String name;

    public Person(String value) {

        name = value;
    }

    String getName() {
        return name;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_linkedlist">LinkedList</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Обобщенный класс <code>LinkedList&lt;E&gt;</code> представляет структуру данных в виде связанного списка. Он наследуется от класса <code>AbstractSequentialList</code> и реализует интерфейсы <code>List</code>, <code>Dequeue</code> и <code>Queue</code>. То есть он соединяет функциональность работы со списком и фукциональность очереди.</p>
</div>
<div class="paragraph">
<p>Класс <code>LinkedList</code> имеет следующие конструкторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>LinkedList()</code>: создает пустой список</p>
</li>
<li>
<p><code>LinkedList(Collection&lt;? extends E&gt; col)</code>: создает список, в который добавляет все элементы коллекции <code>col</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>LinkedList</code> содержит все те методы, которые определены в интерфейсах <code>List</code>, <code>Queue</code>, <code>Deque</code>. Некоторые из них:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>addFirst() / offerFirst()</code> добавляет элемент в начало списка</p>
</li>
<li>
<p><code>addLast() / offerLast()</code> добавляет элемент в конец списка</p>
</li>
<li>
<p><code>removeFirst() / pollFirst()</code> удаляет первый элемент из начала списка</p>
</li>
<li>
<p><code>removeLast() / pollLast()</code> удаляет последний элемент из конца списка</p>
</li>
<li>
<p><code>getFirst() / peekFirst()</code> получает первый элемент</p>
</li>
<li>
<p><code>getLast() / peekLast()</code> получает последний элемент</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Рассмотрим применение связанного списка:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.LinkedList;

public class Program {
    public static void main(String[] args) {
        LinkedList&lt;String&gt; states = new LinkedList&lt;String&gt;();
        // добавим в список ряд элементов
        states.add("Germany");
        states.add("France");
        states.addLast("Great Britain"); // добавляем на последнее место
        states.addFirst("Spain"); // добавляем на первое место
        states.add(1, "Italy"); // добавляем элемент по индексу 1

        System.out.printf("List has %d elements \n", states.size());
        System.out.println(states.get(1));
        states.set(1, "Portugal");
        for (String state : states) {
            System.out.println(state);
        }
        // проверка на наличие элемента в списке
        if (states.contains("Germany")) {
            System.out.println("List contains Germany");
        }

        states.remove("Germany");
        states.removeFirst(); // удаление первого элемента
        states.removeLast(); // удаление последнего элемента

        LinkedList&lt;Person&gt; people = new LinkedList&lt;Person&gt;();
        people.add(new Person("Mike"));
        people.addFirst(new Person("Tom"));
        people.addLast(new Person("Nick"));
        people.remove(1); // удаление второго элемента

        for (Person p : people) {
            System.out.println(p.getName());
        }
        Person first = people.getFirst();
        System.out.println(first.getName()); // вывод первого элемента
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {
    private String name;

    public Person(String value) {

        name = value;
    }

    String getName() {
        return name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь создаются и используются два списка: для строк и для объектов класса <code>Person</code>. При этом в дополнение к методам <code>addFirst()</code>, <code>removeLast()</code> и т.д., нам также доступны стандартные методы, определенные в интерфейсе <code>Collection</code>: <code>add()</code>, <code>remove()</code>, <code>contains()</code>, <code>size()</code> и другие. Поэтому мы можем использовать разные методы для одного и того же действия. Например, добавление в самое начало списка можно сделать так: <code>states.addFirst("Spain");</code>, а можно сделать так: <code>states.add(0, "Spain");</code></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interface_set">Interface <code>Set</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Интерфейс <code>Set</code> расширяет интерфейс <code>Collection</code> и представляет набор уникальных элементов. <code>Set</code> не добавляет новых методов, только вносит изменения в унаследованные. В частности, метод <code>add()</code> добавляет элемент в коллекцию и возвращает <code>true</code>, если в коллекции еще нет такого элемента.</p>
</div>
<div class="sect2">
<h3 id="_hashset">HashSet</h3>
<div class="paragraph">
<p>Обобщенный класс <code>HashSet</code> представляет <strong>хеш-таблицу</strong>. Он наследует свой функционал от класса <code>AbstractSet</code>, а также реализует интерфейс <code>Set</code>.</p>
</div>
<div class="paragraph">
<p><strong>Хеш-таблица</strong> представляет такую структуру данных, в которой все объекты имеют уникальный ключ или <strong>хеш-код</strong>. Данный ключ позволяет уникально идентифицировать объект в таблице.</p>
</div>
<div class="paragraph">
<p>Для создания объекта <code>HashSet</code> можно воспользоваться одним из следующих конструкторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>HashSet()</code> создает пустой список</p>
</li>
<li>
<p><code>HashSet(Collection&lt;? extends E&gt; col)</code> создает хеш-таблицу, в которую добавляет все элементы коллекции <code>col</code></p>
</li>
<li>
<p><code>HashSet(int capacity)</code> параметр <code>capacity</code> указывает начальную емкость таблицы, которая <strong>по умолчанию равна 16</strong></p>
</li>
<li>
<p><code>HashSet(int capacity, float koef)</code> параметр <code>koef</code> или <strong>коэффициент заполнения</strong>, значение которого должно быть в пределах от <code>0.0</code> до <code>1.0</code>, указывает, насколько должна быть заполнена емкость объектами прежде чем произойдет ее расширение.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Класс <code>HashSet</code> не добавляет новых методов, реализуя лишь те, что объявлены в родительских классах и применяемых интерфейсах:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.HashSet;

public class Program {
    public static void main(String[] args) {
        HashSet&lt;String&gt; states = new HashSet&lt;String&gt;();

        // добавим в список ряд элементов
        states.add("Germany");
        states.add("France");
        states.add("Italy");
        // пытаемся добавить элемент, который уже есть в коллекции
        boolean isAdded = states.add("Germany");
        System.out.println(isAdded);    // false

        System.out.printf("Set contains %d elements \n", states.size());    // 3

        for (String state : states) {
            System.out.println(state);
        }
        // удаление элемента
        states.remove("Germany");

        // хеш-таблица объектов Person
        HashSet&lt;Person&gt; people = new HashSet&lt;Person&gt;();
        people.add(new Person("Mike"));
        people.add(new Person("Tom"));
        people.add(new Person("Nick"));
        for (Person p : people) {
            System.out.println(p.getName());
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    String getName() {
        return this.name;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interface_sortedset">Interface <code>SortedSet</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Интерфейс <code>SortedSet</code> предназначен для создания коллекций, который хранят элементы в отсортированном виде (<strong>сортировка по возрастанию</strong>). <code>SortedSet</code> расширяет интерфейс <code>Set</code>, поэтому такая коллекция опять же хранит только уникальные значения. <code>SortedSet</code> предоставляет следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>E first()</code> возвращает первый элемент набора</p>
</li>
<li>
<p><code>E last()</code> возвращает последний элемент набора</p>
</li>
<li>
<p><code>SortedSet&lt;E&gt; headSet(E end)</code> возвращает объект <code>SortedSet</code>, который содержит все элементы первичного набора до элемента <code>end</code></p>
</li>
<li>
<p><code>SortedSet&lt;E&gt; subSet(E start, E end)</code> возвращает объект <code>SortedSet</code>, который содержит все элементы первичного набора между элементами <code>start</code> и <code>end</code></p>
</li>
<li>
<p><code>SortedSet&lt;E&gt; tailSet(E start)</code> возвращает объект <code>SortedSet</code>, который содержит все элементы первичного набора, начиная с элемента <code>start</code></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_interface_navigableset">Interface <code>NavigableSet</code></h3>
<div class="paragraph">
<p>Интерфейс <code>NavigableSet</code> расширяет интерфейс <code>SortedSet</code> и позволяет извлекать элементы на основании их значений. <code>NavigableSet</code> определяет следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>E ceiling(E obj)</code> ищет в наборе наименьший элемент <code>e</code>, который больше либо равен элементу <code>obj</code> (<code>e &gt;= obj</code>). Если такой элемент найден, то он возвращается в качестве результата. Иначе возвращается <code>null</code>.</p>
</li>
<li>
<p><code>E floor(E obj)</code> ищет в наборе наибольший элемент <code>e</code>, который меньше либо равен элементу <code>obj</code> (<code>e &#8656; obj</code>). Если такой элемент найден, то он возвращается в качестве результата. Иначе возвращается <code>null</code>.</p>
</li>
<li>
<p><code>E higher(E obj)</code> ищет в наборе наименьший элемент <code>e</code>, который больше элемента <code>obj</code> (<code>e &gt; obj</code>). Если такой элемент найден, то он возвращается в качестве результата. Иначе возвращается <code>null</code>.</p>
</li>
<li>
<p><code>E lower(E obj)</code> ищет в наборе наибольший элемент <code>e</code>, который меньше элемента <code>obj</code> (<code>e &lt; obj</code>). Если такой элемент найден, то он возвращается в качестве результата. Иначе возвращается <code>null</code>.</p>
</li>
<li>
<p><code>E pollFirst()</code> возвращает первый элемент</p>
</li>
<li>
<p><code>E pollLast()</code> возвращает последний элемент</p>
</li>
<li>
<p><code>NavigableSet&lt;E&gt; descendingSet()</code> возвращает объект <code>NavigableSet</code>, который содержит все элементы первичного набора <code>NavigableSet</code> в обратном порядке</p>
</li>
<li>
<p><code>NavigableSet&lt;E&gt; headSet(E upperBound, boolean incl)</code>: возвращает объект <code>NavigableSet</code>, который содержит все элементы первичного набора <code>NavigableSet</code> до <code>upperBound</code>. Параметр <code>incl</code> при значении <code>true</code>, позволяет включить в выходной набор элемент <code>upperBound</code></p>
</li>
<li>
<p><code>NavigableSet&lt;E&gt; tailSet(E lowerBound, boolean incl)</code> возвращает объект <code>NavigableSet</code>, который содержит все элементы первичного набора <code>NavigableSet</code>, начиная с <code>lowerBound</code>. Параметр <code>incl</code> при значении <code>true</code>, позволяет включить в выходной набор элемент <code>lowerBound</code></p>
</li>
<li>
<p><code>NavigableSet&lt;E&gt; subSet(E lowerBound, boolean lowerIncl, E upperBound, boolean highIncl)</code> возвращает объект <code>NavigableSet</code>, который содержит все элементы первичного набора <code>NavigableSet</code> от <code>lowerBound</code> до <code>upperBound</code>.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_treeset"><code>TreeSet</code></h4>
<div class="paragraph">
<p>Обобщенный класс <code>TreeSet&lt;E&gt;</code> представляет структуру данных в виде <strong>дерева</strong>, в котором все объекты хранятся в <strong>отсортированном виде по возрастанию</strong>. <code>TreeSet</code> является наследником класса <code>AbstractSet</code> и реализует интерфейс <code>NavigableSet</code>, а следовательно, и интерфейс <code>SortedSet</code>.</p>
</div>
<div class="paragraph">
<p>В классе <code>TreeSet</code> определены следующие конструкторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TreeSet()</code> создает пустое дерево</p>
</li>
<li>
<p><code>TreeSet(Collection&lt;? extends E&gt; col)</code> создает дерево, в которое добавляет все элементы коллекции <code>col</code></p>
</li>
<li>
<p><code>TreeSet(SortedSet &lt;E&gt; set)</code> создает дерево, в которое добавляет все элементы сортированного набора <code>set</code></p>
</li>
<li>
<p><code>TreeSet(Comparator&lt;? super E&gt; comparator)</code> создает пустое дерево, где все добавляемые элементы впоследствии будут отсортированы с помощью <code>comparator</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>TreeSet</code> поддерживает все стандартные методы для вставки и удаления элементов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.TreeSet;

public class Program {
    public static void main(String[] args) {
        TreeSet&lt;String&gt; states = new TreeSet&lt;String&gt;();

        // добавим в список ряд элементов
        states.add("Germany");
        states.add("France");
        states.add("Italy");
        states.add("Great Britain");

        System.out.printf("TreeSet contains %d elements \n", states.size());

        // удаление элемента
        states.remove("Germany");
        for (String state : states) {
            System.out.println(state);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>И поскольку при вставке объекты сразу же сортируются по возрастанию, то при выводе в цикле <code>for</code> мы получим отсортированный набор.</p>
</div>
<div class="paragraph">
<p>Так как <code>TreeSet</code> реализует интерфейс <code>NavigableSet</code>, а через него и <code>SortedSet</code>, то мы можем применить к структуре дерева различные методы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.NavigableSet;
import java.util.SortedSet;
import java.util.TreeSet;

public class Program {
    public static void main(String[] args) {
        TreeSet&lt;String&gt; states = new TreeSet&lt;String&gt;();

        // добавим в список ряд элементов
        states.add("Germany");
        states.add("France");
        states.add("Italy");
        states.add("Spain");
        states.add("Great Britain");

        System.out.println(states.first()); // получим первый - самый меньший элемент
        System.out.println(states.last()); // получим последний - самый больший элемент
        // получим поднабор от одного элемента до другого
        SortedSet&lt;String&gt; set = states.subSet("Germany", "Italy");
        System.out.println(set);
        // элемент из набора, который больше текущего
        String greater = states.higher("Germany");
        // элемент из набора, который меньше текущего
        String lower = states.lower("Germany");
        // возвращаем набор в обратном порядке
        NavigableSet&lt;String&gt; navSet = states.descendingSet();
        // возвращаем набор в котором все элементы меньше текущего
        SortedSet&lt;String&gt; setLower = states.headSet("Germany");
        // возвращаем набор в котором все элементы больше текущего
        SortedSet&lt;String&gt; setGreater = states.tailSet("Germany");
        System.out.println(navSet);
        System.out.println(setLower);
        System.out.println(setGreater);
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interface_map">Interface <code>Map</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Интерфейс <code>Map&lt;K, V&gt;</code> представляет <strong>отображение</strong> или иначе говоря <strong>словарь</strong>, где каждый элемент представляет пару <code>key</code>-<code>value</code>. При этом все ключи уникальные в рамках объекта <code>Map</code>. Такие коллекции облегчают поиск элемента, если нам известен <strong>ключ</strong> - уникальный идентификатор объекта.</p>
</div>
<div class="paragraph">
<p>Следует отметить, что в отличие от других интерфейсов, которые представляют коллекции, интерфейс <code>Map</code> <strong>НЕ расширяет</strong> интерфейс <code>Collection</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../../assets/img/java/core/java-collection-framework/java-map-hierarchy.png" alt="Java Map Hierarchy"></span></p>
</div>
<div class="paragraph">
<p>Среди методов интерфейса <code>Map</code> можно выделить следующие:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void clear()</code> очищает коллекцию</p>
</li>
<li>
<p><code>boolean containsKey(Object k)</code>: возвращает <code>true</code>, если коллекция содержит ключ <code>k</code></p>
</li>
<li>
<p><code>boolean containsValue(Object v)</code>: возвращает <code>true</code>, если коллекция содержит значение <code>v</code></p>
</li>
<li>
<p><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>: возвращает набор элементов коллекции. Все элементы представляют объект <code>Map.Entry</code></p>
</li>
<li>
<p><code>boolean equals(Object obj)</code> возвращает <code>true</code>, если коллекция идентична коллекции, передаваемой через параметр <code>obj</code></p>
</li>
<li>
<p><code>boolean isEmpty</code> возвращает <code>true</code>, если коллекция пуста</p>
</li>
<li>
<p><code>V get(Object k)</code> возвращает значение объекта, ключ которого равен <code>k</code>. Если такого элемента не окажется, то возвращается значение <code>null</code></p>
</li>
<li>
<p><code>V getOrDefault(Object k, V defaultValue)</code> возвращает значение объекта, ключ которого равен <code>k</code>. Если такого элемента не окажется, то возвращается значение <code>defaultVlue</code></p>
</li>
<li>
<p><code>V put(K k, V v)</code> помещает в коллекцию новый объект с ключом <code>k</code> и значением <code>v</code>. Если в коллекции уже есть объект с подобным ключом, то он перезаписывается. После добавления возвращает предыдущее значение для ключа <code>k</code>, если он уже был в коллекции. Если же ключа еще не было в коллекции, то возвращается значение <code>null</code></p>
</li>
<li>
<p><code>V putIfAbsent(K k, V v)</code> помещает в коллекцию новый объект с ключом <code>k</code> и значением <code>v</code>, если в коллекции еще нет элемента с подобным ключом.</p>
</li>
<li>
<p><code>Set&lt;K&gt; keySet()</code> возвращает набор всех ключей отображения</p>
</li>
<li>
<p><code>Collection&lt;V&gt; values()</code> возвращает набор всех значений отображения</p>
</li>
<li>
<p><code>void putAll(Map&lt;? extends K, ? extends V&gt; map)</code> добавляет в коллекцию все объекты из отображения <code>map</code></p>
</li>
<li>
<p><code>V remove(Object k)</code> удаляет объект с ключом <code>k</code></p>
</li>
<li>
<p><code>int size()</code> возвращает количество элементов коллекции</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Чтобы положить объект в коллекцию, используется метод <code>put()</code>, а чтобы получить по ключу - метод <code>get()</code>. Реализация интерфейса <code>Map</code> также позволяет получить наборы как ключей, так и значений. А метод <code>entrySet()</code> возвращает набор всех элементов в виде объектов <code>Map.Entry&lt;K, V&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Обобщенный интерфейс <code>Map.Entry&lt;K, V&gt;</code> представляет объект с ключом типа <code>K</code> и значением типа <code>V</code> и определяет следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boolean equals(Object obj)</code> возвращает <code>true</code>, если объект <code>obj</code>, представляющий интерфейс <code>Map.Entry</code>, идентичен текущему</p>
</li>
<li>
<p><code>K getKey()</code> возвращает ключ объекта отображения</p>
</li>
<li>
<p><code>V getValue()</code> возвращает значение объекта отображения</p>
</li>
<li>
<p><code>Set&lt;K&gt; keySet()</code> возвращает набор всех ключей отображения</p>
</li>
<li>
<p><code>V setValue(V v)</code> устанавливает для текущего объекта значение <code>v</code></p>
</li>
<li>
<p><code>int hashCode()</code> возвращает хеш-код данного объекта</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>При переборе объектов отображения мы будем оперировать этими методами для работы с ключами и значениями объектов.</p>
</div>
<div class="sect2">
<h3 id="_hashmap"><code>HashMap</code></h3>
<div class="paragraph">
<p>Базовым классом для всех отображений является абстрактный класс <code>AbstractMap</code>, который реализует большую часть методов интерфейса <code>Map</code>. Наиболее распространенным классом отображений является <code>HashMap</code>, который реализует интерфейс <code>Map</code> и наследуется от класса <code>AbstractMap</code>.</p>
</div>
<div class="paragraph">
<p>Пример использования класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class Program {
    public static void main(String[] args) {
        Map&lt;Integer, String&gt; states = new HashMap&lt;Integer, String&gt;();
        states.put(1, "Germany");
        states.put(2, "Spain");
        states.put(4, "France");
        states.put(3, "Italy");

        // получим объект по ключу 2
        String first = states.get(2);
        System.out.println(first);
        // получим весь набор ключей
        Set&lt;Integer&gt; keys = states.keySet();
        // получить набор всех значений
        Collection&lt;String&gt; values = states.values();
        //заменить элемент
        states.replace(1, "Poland");
        // удаление элемента по ключу 2
        states.remove(2);
        // перебор элементов
        for (Map.Entry&lt;Integer, String&gt; item : states.entrySet()) {
            System.out.printf("Key: %d  Value: %s \n", item.getKey(), item.getValue());
        }

        Map&lt;String, Person&gt; people = new HashMap&lt;String, Person&gt;();
        people.put("1240i54", new Person("Tom"));
        people.put("1564i55", new Person("Bill"));
        people.put("4540i56", new Person("Nick"));

        for (Map.Entry&lt;String, Person&gt; item : people.entrySet()) {
            System.out.printf("Key: %s  Value: %s \n", item.getKey(), item.getValue().getName());
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    String getName() {
        return this.name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы добавить или заменить элемент, используется метод <code>put()</code>, либо <code>replace()</code>, а чтобы получить его значение по ключу - метод <code>get()</code>. С помощью других методов интерфейса <code>Map</code> также производятся другие манипуляции над элементами:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>перебор</strong></p>
</li>
<li>
<p><strong>получение ключей</strong></p>
</li>
<li>
<p><strong>значений</strong></p>
</li>
<li>
<p><strong>удаление</strong></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interface_sortedmap">Interface <code>SortedMap</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Интерфейс <code>SortedMap</code> расширяет <code>Map</code> и создает отображение, в котором все элементы отсортированы в порядке возрастания их ключей. <code>SortedMap</code> добавляет ряд методов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>K firstKey()</code> возвращает ключ первого элемента отображения</p>
</li>
<li>
<p><code>K lastKey()</code> возвращает ключ последнего элемента отображения</p>
</li>
<li>
<p><code>SortedMap&lt;K, V&gt; headMap(K end)</code> возвращает отображение <code>SortedMap</code>, которые содержит все элементы оригинального <code>SortedMap</code> вплоть до элемента с ключом <code>end</code></p>
</li>
<li>
<p><code>SortedMap&lt;K, V&gt; tailMap(K start)</code> возвращает отображение <code>SortedMap</code>, которые содержит все элементы оригинального <code>SortedMap</code>, начиная с элемента с ключом <code>start</code></p>
</li>
<li>
<p><code>SortedMap&lt;K, V&gt; subMap(K start, K end)</code> возвращает отображение <code>SortedMap</code>, которые содержит все элементы оригинального <code>SortedMap</code> вплоть от элемента с ключом <code>start</code> до элемента с ключом <code>end</code></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_interface_navigablemap">Interface <code>NavigableMap</code></h3>
<div class="paragraph">
<p>Интерфейс <code>NavigableMap</code> расширяет интерфейс <code>SortedMap</code> и обеспечивает возможность получения элементов отображения относительно других элементов. Его основные методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Map.Entry&lt;K, V&gt; ceilingEntry(K obj)</code> возвращает элемент с наименьшим ключом <code>k</code>, который больше или равен ключу <code>obj</code> (<code>k</code> &gt;= <code>obj</code>). Если такого ключа нет, то возвращается <code>null</code></p>
</li>
<li>
<p><code>Map.Entry&lt;K, V&gt; floorEntry(K obj)</code> возвращает элемент с наибольшим ключом <code>k</code>, который меньше или равен ключу <code>obj</code> (<code>k</code> &#8656; <code>obj</code>). Если такого ключа нет, то возвращается <code>null</code></p>
</li>
<li>
<p><code>Map.Entry&lt;K, V&gt; higherEntry(K obj)</code> возвращает элемент с наименьшим ключом <code>k</code>, который больше ключа <code>obj</code> (<code>k</code> &gt;`obj`). Если такого ключа нет, то возвращается <code>null</code></p>
</li>
<li>
<p><code>Map.Entry&lt;K, V&gt; lowerEntry(K obj)</code> возвращает элемент с наибольшим ключом <code>k</code>, который меньше ключа <code>obj</code> (<code>k</code> &lt;`obj`). Если такого ключа нет, то возвращается <code>null</code></p>
</li>
<li>
<p><code>Map.Entry&lt;K, V&gt; firstEntry()</code> возвращает первый элемент отображения</p>
</li>
<li>
<p><code>Map.Entry&lt;K, V&gt; lastEntry()</code> возвращает последний элемент отображения</p>
</li>
<li>
<p><code>Map.Entry&lt;K, V&gt; pollFirstEntry()</code> возвращает и одновременно удаляет первый элемент из отображения</p>
</li>
<li>
<p><code>Map.Entry&lt;K, V&gt; pollLastEntry()</code> возвращает и одновременно удаляет последний элемент из отображения</p>
</li>
<li>
<p><code>K ceilingKey(K obj)</code> возвращает наименьший ключ <code>k</code>, который больше или равен ключу <code>obj</code> (<code>k</code> &gt;=<code>obj</code>). Если такого ключа нет, то возвращается <code>null</code></p>
</li>
<li>
<p><code>K floorKey(K obj)</code> возвращает наибольший ключ <code>k</code>, который меньше или равен ключу <code>obj</code> (<code>k</code> &#8656; <code>obj</code>). Если такого ключа нет, то возвращается <code>null</code></p>
</li>
<li>
<p><code>K lowerKey(K obj)</code> возвращает наибольший ключ <code>k</code>, который меньше ключа <code>obj</code> (<code>k</code> &lt;`obj`). Если такого ключа нет, то возвращается <code>null</code></p>
</li>
<li>
<p><code>K higherKey(K obj)</code> возвращает наименьший ключ <code>k</code>, который больше ключа <code>obj</code> (<code>k</code> &gt;`obj`). Если такого ключа нет, то возвращается <code>null</code></p>
</li>
<li>
<p><code>NavigableSet&lt;K&gt; descendingKeySet()</code> возвращает объект <code>NavigableSet</code>, который содержит все ключи отображения в обратном порядке</p>
</li>
<li>
<p><code>NavigableMap&lt;K, V&gt; descendingMap()</code> возвращает отображение <code>NavigableMap</code>, которое содержит все элементы в обратном порядке</p>
</li>
<li>
<p><code>NavigableSet&lt;K&gt; navigableKeySet()</code> возвращает объект <code>NavigableSet</code>, который содержит все ключи отображения</p>
</li>
<li>
<p><code>NavigableMap&lt;K, V&gt; headMap(K upperBound, boolean incl)</code> возвращает отображение <code>NavigableMap</code>, которое содержит все элементы оригинального <code>NavigableMap</code> вплоть от элемента с ключом <code>upperBound</code>. Параметр <code>incl</code> при значении <code>true</code> указывает, что элемент с ключом <code>upperBound</code> также включается в выходной набор.</p>
</li>
<li>
<p><code>NavigableMap&lt;K, V&gt; tailMap(K lowerBound, boolean incl)</code> возвращает отображение <code>NavigableMap</code>, которое содержит все элементы оригинального <code>NavigableMap</code>, начиная с элемента с ключом <code>lowerBound</code>. Параметр <code>incl</code> при значении <code>true</code> указывает, что элемент с ключом <code>lowerBound</code> также включается в выходной набор.</p>
</li>
<li>
<p><code>NavigableMap&lt;K, V&gt; subMap(K lowerBound, boolean lowIncl, K upperBound, boolean highIncl)</code> возвращает отображение <code>NavigableMap</code>, которое содержит все элементы оригинального <code>NavigableMap</code> от элемента с ключом <code>lowerBound</code> до элемента с ключом <code>upperBound</code>. Параметры <code>lowIncl</code> и <code>highIncl</code> при значении <code>true</code> включают в выходной набор элементы с ключами <code>lowerBound</code> и <code>upperBound</code> соответственно</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_treemap"><code>TreeMap</code></h3>
<div class="paragraph">
<p><code>Класс TreeMap&lt;K, V&gt;</code> представляет отображение в виде дерева. Он наследуется от класса <code>AbstractMap</code> и реализует интерфейс <code>NavigableMap</code>, а следовательно, также и интерфейс <code>SortedMap</code>. Поэтому в отличие от коллекции <code>HashMap</code> в <code>TreeMap</code> все объекты автоматически сортируются по возрастанию их ключей.</p>
</div>
<div class="paragraph">
<p>Класс <code>TreeMap</code> имеет следующие конструкторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TreeMap()</code> создает пустое отображение в виде дерева</p>
</li>
<li>
<p><code>TreeMap(Map&lt;K, ? extends V&gt; map)</code> создает дерево, в которое добавляет все элементы из отображения <code>map</code></p>
</li>
<li>
<p><code>TreeMap(SortedMap&lt;K, ? extends V&gt; smap)</code> создает дерево, в которое добавляет все элементы из отображения <code>smap</code></p>
</li>
<li>
<p><code>TreeMap(Comparator&lt;? super K&gt; comparator)</code> создает пустое дерево, где все добавляемые элементы впоследствии будут отсортированы компаратором.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Используем класс в программе:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

public class Program {
    public static void main(String[] args) {
        TreeMap&lt;Integer, String&gt; states = new TreeMap&lt;Integer, String&gt;();
        states.put(10, "Germany");
        states.put(2, "Spain");
        states.put(14, "France");
        states.put(3, "Italy");

        // получим объект по ключу 2
        String first = states.get(2);
        // перебор элементов
        for (Map.Entry&lt;Integer, String&gt; item : states.entrySet()) {
            System.out.printf("Key: %d  Value: %s \n", item.getKey(), item.getValue());
        }
        // получим весь набор ключей
        Set&lt;Integer&gt; keys = states.keySet();
        // получить набор всех значений
        Collection&lt;String&gt; values = states.values();

        // получаем все объекты, которые стоят после объекта с ключом 4
        Map&lt;Integer, String&gt; afterMap = states.tailMap(4);

        // получаем все объекты, которые стоят до объекта с ключом 10
        Map&lt;Integer, String&gt; beforeMap = states.headMap(10);

        // получим последний элемент дерева
        Map.Entry&lt;Integer, String&gt; lastItem = states.lastEntry();

        System.out.printf("Last item has key %d value %s \n", lastItem.getKey(), lastItem.getValue());

        Map&lt;String, Person&gt; people = new TreeMap&lt;String, Person&gt;();
        people.put("1240i54", new Person("Tom"));
        people.put("1564i55", new Person("Bill"));
        people.put("4540i56", new Person("Nick"));

        for (Map.Entry&lt;String, Person&gt; item : people.entrySet()) {
            System.out.printf("Key: %s  Value: %s \n", item.getKey(), item.getValue().getName());
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    String getName() {
        return name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Кроме собственно методов интерфейса <code>Map</code> класс <code>TreeMap</code> реализует методы интерфейса <code>NavigableMap</code>. Например, мы можем получить все объекты до или после определенного ключа с помощью методов <code>headMap()</code> и <code>tailMap()</code>. Также мы можем получить первый и последний элементы и провести ряд дополнительных манипуляций с объектами.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-06-11 06:55:56 UTC
</div>
</div>
</body>
</html>