= Введение Stream API

Начиная с JDK 8 в Java появился новый API - *Stream API*. Его задача - упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными. Вся основная функциональность данного API сосредоточена в пакете `java.util.stream`.

Ключевым понятием в *Stream API* является *поток данных*. Вообще сам термин "поток" довольно перегружен в программировании в целом и в Java в частности. Применительно к *Stream API* поток представляет канал передачи данных из источника данных. Причем в качестве источника могут выступать как файлы, так и массивы и коллекции.

Одной из отличительных черт *Stream API* является применение лямбда-выражений, которые позволяют значительно сократить запись выполняемых действий.

image:/assets/img/java/basics/java-stream.jpg[Java Stream]

При ближайшем рассмотрении можно найти в других технологиях программирования аналоги подобного *API*. В частности, в языке *C#* некоторым аналогом *Stream API* будет технология *LINQ*.

Рассмотрим простейший пример. Допустим, у нас есть задача: найти в массиве количество всех чисел, которые больше `0`. До JDK 8 мы бы могли написать что-то наподобие следующего:

[source, java]
----
public class Test {
    public static void main(String[] args) {
        int[] numbers = {-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5};
        int count = 0;
        for (int i : numbers) {
            if (i > 0) count++;
        }
        System.out.println(count);
    }
}
----

Теперь применим Stream API:

[source, java]
----
import java.util.stream.IntStream;

public class Test {
    public static void main(String[] args) {
        long count = IntStream.of(-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5)
            .filter(w -> w > 0)
            .count();
        System.out.println(count);
    }
}
----

Теперь вместо цикла и кучи условных конструкций, которые мы бы использовали до JDK 8, мы можем записать цепочку методов, которые будут выполнять те же действия.

При работе со Stream API важно понимать, что все операции с потоками бывают либо *терминальными* (*terminal*), либо *промежуточными* (*intermediate*). Промежуточные операции возвращают трансформированный поток. Например, выше в примере метод `filter` принимал поток чисел и возвращал уже преобразованный поток, в котором только числа больше `0`. К возвращенному потоку также можно применить ряд промежуточных операций.

Терминальные операции возвращают конкретный результат. Например, в примере выше метод `count()` представляет терминальную операцию и возвращает число. После этого никаких промежуточных операций естественно применять нельзя.

Все потоки производят вычисления, в том числе в промежуточных операциях, только тогда, когда к ним применяется терминальная операция. То есть в данном случае применяется отложенное выполнение.

В основе Stream API лежит интерфейс `BaseStream`. Его полное определение:

[source, java]
----
interface BaseStream<T , S extends BaseStream<T , S>>
----

Здесь параметр `T` означает тип данных в потоке, а `S` - тип потока, который наследуется от интерфейса `BaseStream`.

`BaseStream` определяет базовый функционал для работы с потоками, которые реализуется через его методы:

* `void close()` закрывает поток
* `boolean isParallel()` возвращает true, если поток является параллельным
* `Iterator<Т> iterator()` возвращает ссылку на итератор потока
* `Spliterator<Т> spliterator()` возвращает ссылку на сплитератор потока
* `S parallel()` возвращает параллельный поток (параллельные потоки могут задействовать несколько ядер процессора в многоядерных архитектурах)
* `S sequential()` возвращает последовательный поток
* `S unordered()` возвращает неупорядоченный поток

От интерфейса BaseStream наследуется ряд интерфейсов, предназначенных для создания конкретных потоков:

* `Stream<T>` используется для потоков данных, представляющих любой ссылочный тип
* `IntStream` используется для потоков с типом данных `int`
* `DoubleStream` используется для потоков с типом данных `double`
* `LongStream` используется для потоков с типом данных `long`

При работе с потоками, которые представляют определенный примитивный тип - `double`, `int`, `long` проще использовать интерфейсы `DoubleStream`, `IntStream`, `LongStream`. Но в большинстве случаев, как правило, работа происходит с более сложными данными, для которых предназначен интерфейс `Stream<T>`. Рассмотрим некоторые его методы:

* `boolean allMatch(Predicate<? super T> predicate)` возвращает `true`, если все элементы потока удовлетворяют условию в предикате
* `boolean anyMatch(Predicate<? super T> predicate)` возвращает `true`, если хоть один элемент потока удовлетворяют условию в предикате
* `<R, A> R collect(Collector<? super T, A, R> collector)` добавляет элементы в неизменяемый контейнер с типом `R`. `T` представляет тип данных из вызывающего потока, а `A` - тип данных в контейнере
* `long count()` возвращает количество элементов в потоке
* `Stream<T> concat​(Stream<? extends T> a, Stream<? extends T> b)` объединяет два потока
* `Stream<T> distinct()` возвращает поток, в котором имеются только уникальные данные с типом `T`
* `Stream<T> dropWhile​(Predicate<? super T> predicate)` пропускает элементы, которые соответствуют условию в `predicate`, пока не попадется элемент, который не соответствует условию. Выбранные элементы возвращаются в виде потока
* `Stream<T> filter(Predicate<? super T> predicate)` фильтрует элементы в соответствии с условием в предикате
* `Optional<T> findFirst()` возвращает первый элемент из потока
* `Optional<T> findAny()` возвращает первый попавшийся элемент из потока
* `void forEach(Consumer<? super T> action)` для каждого элемента выполняется действие `action`
* `Stream<T> limit(long maxSize)` оставляет в потоке только `maxSize` элементов
* `Optional<T> max(Comparator<? super T> comparator)` возвращает максимальный элемент из потока. Для сравнения элементов применяется компаратор comparator
* `Optional<T> min(Comparator<? super T> comparator)` возвращает минимальный элемент из потока. Для сравнения элементов применяется компаратор comparator
* `<R> Stream<R> map(Function<? super T,? extends R> mapper)` преобразует элементы типа `T` в элементы типа `R` и возвращает поток с элементами `R`
* `<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)` позволяет преобразовать элемент типа `T` в несколько элементов типа `R` и возвращает поток с элементами `R`
* `boolean noneMatch(Predicate<? super T> predicate)` возвращает true, если ни один из элементов в потоке не удовлетворяет условию в предикате
* `Stream<T> skip(long n)` возвращает поток, в котором отсутствуют первые n элементов
* `Stream<T> sorted()` возвращает отсортированный поток
* `Stream<T> sorted(Comparator<? super T> comparator)` возвращает отсортированный в соответствии с компаратором поток
* `Stream<T> takeWhile​(Predicate<? super T> predicate)` выбирает из потока элементы, пока они соответствуют условию в `predicate`. Выбранные элементы возвращаются в виде потока
* `Object[] toArray()` возвращает массив из элементов потока

Несмотря на то, что все эти операции позволяют взаимодействовать с потоком как неким набором данных наподобие коллекции, важно понимать отличие коллекций от потоков:

* потоки не хранят элементы. Элементы, используемые в потоках, могут храниться в коллекции, либо при необходимости могут быть напрямую сгенерированы
* операции с потоками не изменяют источника данных. Операции с потоками лишь возвращают новый поток с результатами этих операций
* для потоков характерно отложенное выполнение. То есть выполнение всех операций с потоком происходит лишь тогда, когда выполняется терминальная операция и возвращается конкретный результат, а не новый поток
